<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html >
<html xmlns="http://www.w3.org/1999/xhtml" >

<head>

<title>
C++11: Syntax and Feature
</title>

<style type="text/css">
<![CDATA[

body
{
    background-color : #efefef  ;
    margin-left : 1em ;
    font-size : large ;
}

p
{

}

h1, h2, h3, h4, h5, h6
{
    font-size : x-large ;
    font-weight : normal ;
}

div#content pre 
{
    display : block ;
    font-family: "Inconsolata", "Consolas", monospace ;
    border-style: solid ;
    border-width: medium ;
    border-color: black ;
    padding: 0em 1em 1em 1em  ;
    background-color: #ffffdd ;
    word-wrap: break-word ;
    white-space : pre-wrap ;

    border-radius: 0.4em ;
}


/*
* i element represents represents syntactic categories.
* b element represents other technical terms.
* as defined in HTML5 draft.
*/
i, b
{
    font-weight : normal ;
    font-style : normal ;
    text-decoration : none ;
}


#index > li
{
    margin-bottom : 1em  ;
}

a
{
    text-decoration : none  ;
}

a:hover
{
    background-color : #ffffdd  ;
    border-radius: 0.4em  ;
    -moz-border-radius: 0.4em  ;
    -webkit-border-radius: 0.4em  ;
}


.maybe
{
    background-color : #dfdfdf ;
    border-radius: 0.4em  ;
    -moz-border-radius: 0.4em  ;
    -webkit-border-radius: 0.4em  ;
}

.maybe a
{
    color : black  ;
}

.maybe > a:before
{
    content : "[書かないかも] "  ;
}

.hide
{
    background-color : #dfdfdf ;
    border-radius: 0.4em  ;
}

.hide a
{
    color : black  ;
}
.hide > a:before
{
    content : "[ネストが深すぎる] "  ;
}

.editorial-note
{
    padding : 1em ;
    border : red thick solid ;
}

article
{
    display : block ;
    
    margin-bottom : 4em ;
}

#content > article.toplevel
{
    display : block ;
}

section
{
    display : block ;
    padding-left : 2em ;
}

.todo
{
    padding : 1em ;
    border : red thick solid ;
}

.todo:before
{
    content : "TODO: " ;
}

table
{
    border-collapse:collapse;
}

table, th, td
{
    padding : 0.5em ;
    border : black thin solid ;
} 

]]>
</style>



<script type="application/javascript" >
<![CDATA[
"use strict"  ;



// helper functions
// calculate nth <li> child element from parent node.
function calculate_nth_child_element(element)
{
    var n = 1 ;
    var iter = element.parentNode.firstElementChild ;
    while (!iter.isSameNode(element))
    {
        ++n ;
        iter = iter.nextElementSibling ;
    }

    return n ;
}

// generate chapter numbers for a given li element.
function generate_chapter_numbers( li )
{
    var number = calculate_nth_child_element( li ) ;

    // parent node shall be an ul element.
    var parent = li.parentNode ;

    // if ul's parent element's id attribute is "index"
    if ( parent.parentNode.getAttribute( "id" ) == "index" )
    { // we reached the top of the index list.
        return number ;
    }
    else
    { // continues to the upper chapter.
        /// parent.parentNode shall be an li element.
        return generate_chapter_numbers( parent.parentNode ) + "." + number ;
    }        
}

// add chapter numbers to all anchor elements.
function add_chapter_numbers()
{
    var content = document.getElementById("content") ;
    var index = document.getElementById("index") ;
    var anchor_list = document.getElementsByTagName("a") ;

    // itarete through each anchor element to insert the corresponding chapter numbers.
    for (var i = 0 ; i != anchor_list.length ; ++i)
    {
        var node = anchor_list.item(i) ;

        var href = node.getAttribute("href") ;
        var selector = 'a[href="' + href + '"]' ;
        var query = index.querySelector(selector) ;
        if ( query == null )
        {
            continue ;
        }

        var li = query.parentNode ;

        if (li == null)
            continue ;

        var chapter_numbers = generate_chapter_numbers(li) ;
        node.parentNode.insertBefore( document.createTextNode(chapter_numbers + " "), node ) ;
    }
}

// recursively construct the index.
function generate_nested_index( parent, element, selector )
{
    var list = element.querySelectorAll( selector ) ;

    if ( list.length == 0 )
        return ;

    var ul = document.createElement("ul") ;
    parent.appendChild( ul ) ;



    for ( var i = 0 ; i != list.length ; ++i )
    {
        var elem = list.item(i) ;
        var heading = elem.firstElementChild ; // must be heading element
/*
        var pattern = /h[1-6]/ ;
        if ( heading == null ||
             pattern.test(heading.nodeName) == false ||
             // workaround
             heading.firstElementChild == null
            )
        {
            continue ;
        }
*/
        
        var li = document.createElement("li") ;
        li.appendChild( heading.firstElementChild.cloneNode( true ) ) ;
        ul.appendChild( li ) ;

        generate_nested_index( li, elem, selector + " > article" ) ;
    }
}

// construct a index from content's DOM.
function generate_index()
{
    var index = document.getElementById("index") ;
    var content = document.getElementById("content") ;
    generate_nested_index( index, content, "#content > article" ) ;
}

function listener()
{
    generate_index() ;
    add_chapter_numbers() ;
}


window.addEventListener("load", listener, false ) ;

]]>
</script>




</head>


<body>

<h1>C++11の文法と機能(C++11: Syntax and Feature)</h1>


<pre>
    Copyright (C)  2013 江添亮.
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".
</pre>

<p>
筆者について
</p>

<p>
名前：江添亮<br />
Mail : boostcpp@gmail.com<br />
Blog : <a href="http://cpplover.blogspot.jp/">http://cpplover.blogspot.jp/</a><br />
GitHub: <a href="https://github.com/EzoeRyou/cpp-book">https://github.com/EzoeRyou/cpp-book</a>
</p>

<h1>序</h1>

<p>
本書はC++11のコア言語の文法と機能を、標準規格書に従って解説したものである。正式なC++規格書として発行された後の、ひとつ後のドラフト規格、<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf">N3337
</a>を参考にしている。ドラフト規格を参考にした理由は、正式なC++規格書は、個人での入手が煩わしいためである。読者に入手が困難な資料を元に記述された参考書は価値がない。そのため、読者が容易に入手できるドラフト規格のうち、正式なC++規格書とほとんどかわらないN3337を参考にした。
</p>

<p>
本書の対象読者は、C++を記述するものである。C++実装者ではない。そのため、サンプルコードを増やし、冗長な解説を増やし、C++コンパイラーを実装するための詳細な定義は省いた。そもそも本書はC++規格の翻訳ではなく、C++規格の検証に使うことはできない。
</p>


<p>
本書の執筆は、まだC++11がC++0xと呼ばれていた2010年から始まっている。そのため、当時のドラフト規格を参考に書かれた部分もあり、正式なC++11規格とは異なっている可能性がある。また、正式に発行されたC++11規格には不具合も多数見つかっているため、C++14では異なっている部分もある。また、ドラフトの時点であまりにも変更が激しい箇所は飛ばしたので、漏れもある。
</p>

<p>
このような未完成品を公開するのは忍びないが、且は執筆資金枯渇のため、且は執筆環境消失のため、今公開することにした。
</p>

<p>
本書はC++11を解説する目的で書き始めたが、C++11の正式規格には様々な不具合が見つかり、誤りを正すために、マイナーアップデートなるC++14の制定が2014年に予定されている。また、その次の2017年には、メジャーアップデートとなるC++17が控えている。C++14はアップデートとはいえ、文面的にかなり大きな変更を含むため、もともとC++0xドラフトによって書かれ、C++11規格を参考にした本書の小手先の修正では対応できない。
</p>

<p>
本書の執筆は2010年から始まっているが、C++14が真剣に議論されだした2012年から、執筆が滞りがちになった。
</p>

<p>
筆者は常に最新のC++ドラフトを参照しているが、本書はC++11の参考書であるし、また、まだ不安定なドラフト規格の文面を参考にすることはできない。結果として、本書の執筆には、普段参照している最新のC++ドラフトからは、はるかに遅れたC++11規格を参照しなければならず、執筆の妨げとなった。
</p>

<p>
また、本書を記述するHTML/CSS/JavaScriptも、何年も前の未熟な理解により、甚だ稚拙であり、編集の妨げとなった。
</p>

<p>
この問題を解決するには、フルスクラッチからの書き直しが必要になるが、それはすでに費やした労力を捨て去ることになり、やはり意味がない。
</p>

<p>
あるいはこれ、伽藍とバザールの典型例かもしれず、早期に公開していれば、今とは違った結果になったかもしれない。
</p>

<p>
筆者は、プログラミングの参考書は、自由であるべきだと信じており、この参考書は、自由を保証するコピーレフトなライセンスで公開する。
</p>

<p>
2013年10月26日<br />
江添亮
</p>

<div id="index">

</div>



<div id="content">

<article class="toplevel">
<h1 id="intro"><a href="#intro">概要（General）</a></h1>

<article>
<h1 id="what-is-Cpp"><a href="#what-is-Cpp">C++とは</a></h1>

<p>
TODO:C++に関する一般的な説明
</p>
</article>

<article>
<h1 id="intro.defs"><a href="#intro.defs">用語（Definitions）</a></h1>

<article>
<h1 id="intro.defs.argument.and.parameter"><a href="#intro.defs.argument.and.parameter">実引数（argument）と、仮引数（parameter）</a></h1>
<p>
引数には、ふたつの種類がある。実引数とは、関数やマクロ、throw文、テンプレートに、実際に渡す引数のことをいう。仮引数とは、関数宣言や関数の定義、例外ハンドラーのcatch句、マクロ、テンプレート仮引数のことをいう。たとえば、関数の場合、
</p>

<pre>
// xは仮引数
void f( int x ) ;

int main()
{
// 0は実引数
    f(0) ;
// argは実引数
    int arg = 0 ;
    f( arg ) ;
}
</pre>

<p>
このように、関数の宣言や定義などの引数を、仮引数といい、関数の呼び出しの際に指定する引数を、実引数という。仮引数と実引数は、厳密に区別される。
</p>
</article>

<article>
<h1 id="intro.defs.static.and.dynamic"><a href="#intro.defs.static.and.dynamic">静的な型（static type）と、動的な型（dynamic type）</a></h1>

<p>
静的な型とは、実行しなくても、その意味が分かる型のことである。動的な型は、実行しなければ、その意味が決定出来ない型のことである。
</p>
</article>

<article>
<h1 id="intro.defs.signature"><a href="#intro.defs.signature">シグネチャー（signature）</a></h1>

<p>
シグネチャーとは、ある関数に対する、その関数の名前、引数のリストの型、戻り値の型、テンプレート仮引数のことである。また、メンバー関数の場合は、そのクラスや、CV修飾、リファレンス修飾も含まれる。また、その関数の属する名前空間も含まれる。シグネチャーは、その関数を特定するために用いられる。
</p>
</article>

<article>
<h1 id="intro.defs.ill.well"><a href="#intro.defs.ill.well">ill-formedプログラムと、well-formedプログラム</a></h1>

<p>
well-formedプログラムとは、文法上正しいプログラムである。ill-formedプログラムとは、well-formedではないプログラム、すなわち、文法上、間違ったプログラムである。多くの実装では、ill-formedプログラムは、コンパイルエラーとなる。
</p>
</article>

<article>
<h1 id="intro.defs.conditionally"><a href="#intro.defs.conditionally">実装可能な機能（conditionally-supported）</a></h1>

<p>
実装可能な機能とは、規格上、実装してなくてもよい機能や動作のことである。
</p>
</article>

<article>
<h1 id="intro.defs.imple.defined"><a href="#intro.defs.imple.defined">実装定義の動作（implementation-defined behavior）</a></h1>

<p>
実装定義の動作とは、well-formedではあるが、その意味が、実装によって変わるということである。
</p>
</article>

<article>
<h1 id="intro.defs.undefined"><a href="#intro.defs.undefined">未定義の動作（undefined behavior）</a></h1>
<p>
未定義の動作とは、そのプログラムの意味が、規格上定義されていないということである。その動作は実装によって異なり、あるいはエラーとなるかもしれないし、あるいは問題なく結果が予測できる動作となるかもしれない。一般に、エラーとなる場合が多い。未定義の動作を含むプログラムを書く場合は、そのコードの意味が、目的の実行環境で、明確に定義されているかどうかを確認するべきである。
</p>
</article>

<article>
<h1 id="intro.defs.unspecified"><a href="#intro.defs.unspecified">未規定の動作（unspecified behavior）</a></h1>
<p>
未規定の動作も、具体的な意味が、実装によって異なると言う点で、未定義の動作と変わらない。ただし、未規定の動作は、規格上、推奨される動作が決められていることも多く、多くの実装で、エラーにならない、何らかの意味のあるコードになると言う点で、未定義の動作よりは、安全である。ただし、これも、目的の実行環境での意味がどうなるのかを、正しく把握しておく必要がある。
</p>
</article>

</article>

<article>
<h1 id="syntax"><a href="#syntax">文法記法（Syntax notation）</a></h1>
<p>
TODO:文法記法を用いるのはやめようかと考えている。分かりにくい。
</p>
<p>
本書では、言語の文法を記述するのに、規格に準じた文法記法を用いる。
</p>

<p>
個々の文法は、<i>文法カテゴリー</i>（syntactic category）として定義される。ある文法カテゴリーは、複数の文法カテゴリーや、具体的な文法を持つことができる。複数の文法カテゴリーは、改行で示される。
</p>

<pre>
<i>文法カテゴリー</i>:
    <i>サブ文法カテゴリー</i> category
    category

<i>サブ文法カテゴリー</i>:
    Syntactic
</pre>

<p>
この例では、以下の二つの文法が定義されることになる。
</p>

<pre>
Syntactic category
category
</pre>

<p>
また、省略可能な文法カテゴリーは、「文法カテゴリー<sub>opt</sub>」と表記される。
</p>

<pre>
{ <i>式</i><sub>opt</sub> }
</pre>

<p>
この場合、式は書いても書かなくてもよい。
</p>

<p>
本書では、分かりやすさを重視するため、規格ほどの厳密な文法記法を用いることはない。文法カテゴリーは、常に日本語で表記される。
</p>
</article>

<article>
<h1 id="intro.memory"><a href="#intro.memory">C++メモリーモデル（The C++ memory model）</a></h1>

<p>
C++では、メモリー領域のことを、ストレージ（storage）と呼ぶ。ストレージの最小単位は、バイトである。1バイトが何ビットであるかは定められていないが、少なくとも、8ビット以上であることが保証されている。最低8ビットである理由は、UTF-8の、ひとつのコード単位を格納できるようにするためである。メモリーは、連続したバイト列で表される。すべてのバイトは、ユニークなアドレスを持つ。
</p>
</article>

<article>
<h1 id="intro.object"><a href="#intro.object">C++オブジェクトモデル（The C++ object model）</a></h1>

<p>
オブジェクトは、メモリー上に構築される。intやfloatといった基本型や、ユーザーが定義したクラスも、すべてオブジェクトとして構築される。ただし、関数は、オブジェクトではない。オブジェクトは、変数の定義や、newによって生成される。
</p>

<pre>
// int型のオブジェクト
int x ;
int * pointer = new int ;

// Fooクラス型のオブジェクト
class Foo { } ;
Foo foo ;
Foo * foo_pointer = new Foo ;
</pre>



<p>
オブジェクトは、型や、<a href="#basic.stc">ストレージの有効期間</a>、<a href="#basic.life">生存期間</a>を持つ。
</p>
</article>

<article>
<h1><a href="#intro.execution">プログラムの実行（Program execution）</a></h1>

<p>
TODO:
</p>
</article>

</article>

<article class="toplevel">
<h1 id="lex"><a href="#lex">字句規約（Lexical conventions）</a></h1>
<p>
ここでは、C++のソースコードを表現する文字について解説する。
</p>

<article>
<h1 id="lex.separate"><a href="#lex.separate">翻訳単位（Separate translation）</a></h1>


<p>
プログラムは、ソースファイルという単位に分割される。ソースファイルとは、プリプロセッサが実行された後のソースコードである。
</p>
</article>

<article>
<h1 id="lex.phases"><a href="#lex.phases">ソースファイルの変換（Phase of translation）</a></h1>
<p>
ソースファイルは、コンパイルにかけられる前に、変換される。この変換の詳しい定義は略すが、特に知っておくべき変換が、いくつかある。
</p>

<p>
基本ソース文字セットではない文字は、UCNに変換される。
</p>

<p>
変換前
</p>
<pre>
あ
</pre>

<p>
変換後
</p>
<pre>
\u3042
</pre>

<p>
TODO:行末バックスラッシュを説明するのはやめようかと思う。
</p>
<p>
行末の\（バックスラッシュ）と、それに続く改行は、取り除かれる。
</p>

<p>
変換前
</p>
<pre>
int \
value \
= 0 ;
</pre>

<p>
変換後
</p>

<pre>
int value = 0 ;
</pre>

<p>
この改行の除去のルールは、注意を要する。例えば、
</p>

<p>
変換前
</p>
<pre>
/\
/\
これはコメント
int va\
lue = 0 ;
</pre>

<p>
変換後
</p>

<pre>
//これはコメント
int value = 0 ;
</pre>

<p>
連続する文字列リテラルのトークンは、連結される。
</p>

<p>
変換前
</p>
<pre>
"aaa"
"bbb" ;
</pre>

<p>
変換後
</p>
<pre>
"aaabbb" ;
</pre>
</article>

<article>
<h1 id="lex.charset"><a href="#lex.charset">文字セット（Character sets）</a></h1>

<p>
C++は、ソースファイルの文字コードを定めていない。ソースファイル内の文字は、環境依存の文字コードで表現される。
</p>

<article>
<h1 id="basic-source-character-set"><a href="#basic-source-character-set">基本ソース文字セット</a></h1>
<p>
基本ソース文字セット（basic source character set）とは、ソースファイルで使うことができる文字のことである。印字可能な文字は、以下の通り。
</p>

<pre>
a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
0 1 2 3 4 5 6 7 8 9
_ { } [ ] # ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; | ! = , \ &quot; '
</pre>

<p>
上記に加えて、スペース、水平タブ、垂直タブ、フォームフィード、改行も使うことができる。
</p>

<p>
たとえば、ASCIIでいえば、@（アットマーク）や`（グレイヴ・アクセント）のような文字は、使われていない。
</p>
</article>

<article>
<h1 id="universal-character-name"><a href="#universal-character-name">ユニバーサル文字名</a></h1>

<p>
ユニバーサル文字名（UCN：universal character name）とは、ISO/IEC 10646で定義されている文字コードのことである。この文字コードは、ユニバーサル文字セットと呼ばれている。また、厳密には同じではないが、俗に、Unicodeと呼ばれることもある。UnicodeはUnicodeで、別の規格があるのだが、実用上、どちらもコードポイントやエンコード方式に、差がないため、よく混同される。本書では、ユニバーサル文字セットや、UTFエンコードに関する解説は行わない。
</p>

<p>
Nを16進数の一文字とすると、\uNNNNは、UCSにおけるコードポイント、0000NNNNで表される文字という意味になり、\UNNNNNNNNは、NNNNNNNNで表される文字と同じ意味になる。
</p>

<p>
例：
</p>
<pre>
\u3042      あ
\u3043      い
\U00003044  う
</pre>

<p>
このユニバーサル文字名は、リテラルやエスケープシーケンスではなく、もっと根本的に、文字と同等に扱われる。つまり、対応するユニバーサル文字として認識される。ユニバーサル文字名は、ソースコードのあらゆる場所で使うことができる。ソースコードのある場所に、ユニバーサル文字名を記述した場合、その場所に、対応するユニバーサル文字を記述したのと、全く同じ扱いがなされる。
</p>

<p>
ただし、生文字列リテラルの中では、ユニバーサル文字名は使えない。サロゲートの範囲のコードポイント(0xD800–0xDFFF)を指定することはできない。文字列リテラルの中では、ユニバーサル文字は実装により自動的にエンコードされるので、サロゲートコードポイントを明示的に使う必要はない。もし文字としてサロゲートコードポイントを使う必要があるならば、エスケープシーケンス\xが使える。文字リテラルや文字列リテラルの中以外では、コントロール文字の範囲のコードポイント(0x00–0x1F と 0x7F–0x9F)と、基本ソース文字セットに該当するコードポイントを指定することはできない。
</p>

<pre>
R"(\u3042)" ; // ユニバーサル文字名ではなく、文字通りに解釈されることに注意
u8"\u00E3\u0081\u0082" ; // OK、u8"あ"と同じ

u"\ud842\udfb7" ; // エラー、サロゲートコードポイントを明示的に使うことはできない
u"\u00020bb7" ; // OK、u"𠮷"と同じ

int \u0041 = 0 ; // エラー、ここで基本ソース文字セットは使えない
int \u3042 = 0 ; // OK
</pre>

<p>

</p>

</article>
</article>

<article>
<h1 id="lex.token"><a href="#lex.token">トークン（Tokens）</a></h1>
<p>
TODO:これは本当に必要な項目だろうか。この項目で定義されている、ホワイトスペースは、どこかで言及しておかなければならないが。むしろ、この項目を、空白とすべきか。
</p>
</article>

<article>
<h1 id="lex.comment"><a href="#lex.comment">コメント（Comments）</a></h1>
<p>
コメントには、二種類ある。/* */で囲まれた、複数行にわたるコメントと、//から始まり行末までの、一行コメントである。
</p>

<pre>
/* ここからコメント開始
これはコメント
これもコメント
ここでコメント終わり*/

// これは一行コメント。改行までがコメントとなる。
</pre>

<p>
コメントは、/*、で始まり、*/で終わる。この形式のコメントは、ネストできない。
</p>

<pre>
/* これはコメント*/

/*ここから



ここまでコメント*/

/* /* これはエラー。ネストしている。*/ */
</pre>

<p>
//で始まるコメントは、行末までが、コメントとなる。これは、/**/形式のコメントの中にも、書くことができる。
</p>

<pre>
// これは一行コメント。行末までがコメントとなる。


/*
// これは正しいコード。
*/
</pre>
</article>


<article>
<h1 id="lex.name"><a href="#lex.name">識別子（Identifiers）</a></h1>

<p>
識別子には、大文字小文字のアルファベット、_（アンダースコア）、数字、ユニバーサル文字名、その他の実装依存の文字が使える。大文字と小文字は区別される。
</p>

<pre>
int aaa ;
int AAA ;// aaaとは別の識別子、大文字と小文字は、区別される。
int bbb ;
int this_is_an_identifier ;
int n1234567890 ;
int \u3042 ;// ユニバーサル文字名
int 変数 ;
</pre>

<p>
ただし、識別子の先頭は、数字から始まってはならない。
</p>

<pre>
// エラー
int 0aaa ;
</pre>

<p>
また、キーワードや予約語は、識別子として使うことができない。
</p>

<pre>
// エラー、templateはキーワードである。
int template ;
// エラー、andは代替表現である。
int and ;
</pre>

<p>
以下の識別子は、特定の文法上の場所で現れた場合に、特別な意味を持つ。これは俗に、文脈依存キーワードとも呼ばれている。
</p>

<pre>
final override
</pre>

<p>
特定の文法は、識別子が現れることがない場所なので、この文脈依存キーワードは、通常通り何の問題もなく識別子として使うことができる。
</p>

<pre>
int final ; // OK
int override ; // OK
</pre>

<p>
以下のような記述も合法だ。
</p>

<pre>
// OK、クラス名finalをfinalに指定
class final final { } ;

struct base
{
    virtual void override() { }
}

struct derived : base
{
    // OK、virtual関数名overrideにoverrideを指定
    virtual void override() override { }
} ;
</pre>



<article>
<h1 id="reserved-name"><a href="#reserved-name">予約語</a></h1>

<p>
予約語とは、C++の実装や標準ライブラリの実装のために予約されていて、使ってはならない名前のことである。ユーザーコードで予約語を使った場合、プログラムの動作は保証されない。
</p>

<p>
以下のいずれかの条件に当てはまる名前は、あらゆる利用を予約されている。
</p>
<ul>
<li>ひとつのアンダースコアに大文字から始まる名前</li>
<li>アンダースコアが二つ連続している、いわゆるダブルアンダースコアを含む名前</li>
</ul>

<p>
以下のコードは、すべて予約名を使っているので、エラーである。
</p>

<pre>
int _A ;    // アンダースコアに大文字から始まる名前は、予約されている。
int __a ;   // ダブルアンダースコアを含む名前は、予約されている。
int ___a ;  // 三つの連続したアンダースコアも、ダブルアンダースコアを含むので、使えない。
int a__b ;  // 先頭以外でも、どこかにダブルアンダースコアが含まれている場合、使えない。
int a__ ; // ダブルアンダースコアを含む
int __ ; // ダブルアンダースコアを含む
</pre>

<p>
ひとつのアンダースコアから始まる名前は、グローバル名前空間で、利用を予約されている。ただし、グローバル名前空間との名前の衝突が、時として、意外な結果をもたらすこともあるので、言語のルールの詳細を把握していない限り、利用はおすすめできない。
</p>

<pre>
// エラー、グローバル名前空間
int _a ;

// OK
namespace NS { int _a ; }

int main()
{
    int _a ;// OK
}
</pre>

<p>
ひとつのアンダースコアだけの名前は、予約語ではない。
</p>

<pre>
int _ ; // OK
int __ ; // エラー、ダブルアンダースコア
</pre>

<p>
簡単にまとめると、アンダースコアから始まる名前は、使うべきではない。ダブルアンダースコアを含む名前は、あらゆる使用を禁止されている。
</p>

<p>
名前の衝突を防ぐため、しばしばC++の理解の浅い者によってアンダースコアが用いられるが、予約語と衝突した場合、コード自体の動作が保証されなくなってしまうので、名前の衝突を防ぐ目的でアンダースコアを使ってはならない。名前の衝突を防ぐためには、名前空間という言語機能がある。
</p>
</article>
</article>

<article>
<h1 id="lex.key"><a href="#lex.key">キーワード（Keywords）</a></h1>
<p>
C++では、以下のキーワードが使われている。これらのキーワードは、プログラム中で特別な意味を持つので、識別子に使うことはできない。
</p>

<pre>
alignof decltype goto reinterpret_cast try
asm default if return typedef
auto delete inline short typeid
bool do int signed typename
break double long sizeof union
case dynamic_cast mutable static unsigned
catch else namespace static_assert using
char enum new static_cast virtual
char16_t explicit noexcept struct void
char32_t export nullptr switch volatile
class extern operator template wchar_t
const false private this while
constexpr float protected thread_local
const_cast for public throw
continue friend register true
</pre>

<p>
以下は、キーワードではないが、記号と同じ意味を持つので、識別子に使うことはできない。これは、代替表現（alternative representation）と呼ばれている。
</p>

<pre>
and and_eq bitand bitor compl not
not_eq or or_eq xor xor_eq
</pre>
</article>


<article>
<h1 id="lex.literal"><a href="#lex.literal">リテラル（Literals）</a></h1>
<p>
ここでは、リテラルについて解説している。型については、<a href="#basic.types">型（Types）</a>を参照。
</p>

<article>
<h1 id="lex.icon"><a href="#lex.icon">整数リテラル（Integer literals）</a></h1>
<p>
整数リテラルには、10進数リテラル、8進数リテラル、16進数リテラルがある。C++には、2進数リテラルは存在しない。
</p>

<p>
十進数リテラルには、0123456789の文字を使うことができる。
</p>

<p>
8進数リテラルには、01234567の文字を使うことができる。プレフィクス、0から始まる整数リテラルは、8進数リテラルである。
</p>

<p>
16進数リテラルには、0123456789, abcdef, ABCDEFの文字を使うことができる。大文字と小文字は、区別されない。プレフィクス、0xから始まる整数リテラルは、16進数リテラルである。
</p>

<pre>
//10進数リテラル
1234 ;

// 8進数リテラル
01234 ;// 10進数では、668

// 16進数リテラル
0x1234 ;// 10進数では、4660
</pre>

<p>
0xというプレフィクスが、16進数リテラルを表すのは、他のプログラミング言語でも、よくあることだ。しかし、C++では、8進数リテラルのプレフィクスが変わっている。これは、注意を要する。
</p>

<pre>
// if ( x == 8 ) と同じ。
if ( x == 010 )
</pre>

<p>
C++の8進数リテラルは、10進数と区別しにくいので、気をつける必要がある。
</p>

<p>
整数リテラルには、後ろにサフィックスをつけることができる。このサフィックスは、大文字小文字が区別されない。
</p>

<p>
サフィックス、u、Uは、整数リテラルの型が、unsignedであることを示す
</p>

<pre>
// signed int
auto type1 = 0 ;

// unsigned int
auto type2 = 0u ;
auto type3 = 0U ;
</pre>

<p>
サフィックス、l、Lは、型がlong intであることを示す。サフィックス、ll、LLは、型がlong long intであることを示す。
</p>

<pre>
// long int
auto type1 = 0l ;
auto type2 = 0L ;
// long long int
auto type3 = 0ll ;
auto type4 = 0LL ;
</pre>

<p>
unsignedであることを示すサフィックスと、long int、またはlong long intであることを示すサフィックスは、組み合わせることができる。順番は、どちらでもいい。
</p>

<pre>
// unsigned long int
auto type1 = 0ul ;
auto type2 = 0lu ;
</pre>

<p>
整数リテラルの型の決定は、複雑である。もし、10進数の整数リテラルの値が、intの範囲で表現できない場合は、long intが使われる。long intでも表現できない場合は、long long intが使われる。8進数と16進数の整数リテラルの場合は、unsigned int, unsigned long int, unsigned long long intも、考慮に入れられる。
</p>

<p>
ただし、l, Lというサフィックスが指定されている場合は、long int以降が使われる。u, Uが指定されている場合は、unsignedな整数型に限られる。
</p>

<p>
いずれの型でも、整数リテラルの値を表現できない場合は、ill-formedである。
</p>
</article>

<article>
<h1 id="lex.fcon"><a href="#lex.fcon">浮動小数点数リテラル（Floating literals）</a></h1>
<p>
浮動小数点数のリテラルは、10進数で記述する。
</p>

<pre>
1.0 ;
123456789.0 ;
3.14 ;
0.00000001 ;
</pre>

<p>
浮動小数点数リテラルには、e, Eに続けて、指数（exponent）を指定することができる。指数を指定すると、小数に、10の指数乗をかけた値になる。
</p>

<pre>
// 1 × 10<sup>1</sup> = 1 × 10 = 10
1e1 ;
1E1 ;// Eでも同じ意味
1e+1 ;// 指数には符号を指定できる。

// 0.12345 × 10<sup>2</sup> = 0.12345 × 100 = 12.345
0.12345e2 ;

// 1 × 10<sup>-2</sup> = 12345 × 0.01 = 123.45
12345e-2

// 123 × 10<sup>0</sup> = 123 × 1 = 123
123e0 ;
</pre>

<p>
浮動小数点数リテラルの型は、非常に簡単である。サフィックス、f, Fが指定されているリテラルの型は、float、サフィックスが指定されていない型は、double、サフィックス、l, Lが指定されている型は、long doubleである。このサフィックスは、大文字小文字が区別されない。
</p>

<pre>
// float
auto f1 = 1.0f ;
auto f2 = 1.0F ;

// double
auto d1 = 1.0 ;
auto d2 = 1.0 ;

// long double
auto l1 = 1.0l ;
auto l2 = 1.0L ;
</pre>

<p>
もし、リテラルの値を、リテラルの型で、完全に表現できない場合は、最も近い値に丸められる。値をどのようにして丸めるかは、実装依存である。もし、リテラルの値を、リテラルの型で表現できない場合は、エラーとなる。
</p>
</article>

<article>
<h1 id="lex.ccon"><a href="#lex.ccon">文字リテラル（Character literals）</a></h1>
<p>
文字リテラルとは、ある一文字を表すリテラルのことである。文字リテラルは、以下のように記述する。
</p>

<pre>
’x’     通常の文字リテラル（ordinary character literal）
u’x’    char16_t型の文字リテラル
U’x’    char32_t型の文字リテラル
L’x’    wchar_t型の文字リテラル。
</pre>

<p>
プレフィクスのついていない、'x'は、通常の文字リテラル（ordinary character literal）である。型は、charである。このリテラル内に書かれている一文字の値が、そのまま、リテラルの値になる。通常の文字リテラルの具体的な値については、実装依存である。
</p>

<p>
プレフィクス、Lのついている文字リテラル、L'X'は、ワイド文字リテラルである。型は、wchar_tである。このリテラル内に書かれている一文字の値が、そのまま、リテラルの値になる。ワイド文字リテラルの具体的な値については、実装依存である。
</p>

<p>
プレフィクス、uのついている文字リテラル、u'x'は、char16_t型の文字リテラルである。これは、一文字のユニバーサル文字セット内の、16bitで表現できるコードポイントに当たる文字を使うことができる。このエンコード方式は、UTF-16と呼ばれている。文字リテラルは、16bitで表せる一文字しか使えないので、サロゲートペアは使えない。もちろん、文字列リテラルでは、サロゲートペアもサポートされている。
</p>

<p>
プレフィクス、Uのついている文字リテラル、U'x'は、char32_t型の文字リテラルである。これは、一文字の任意のユニバーサル文字セット内の文字を使うことができる。このエンコード方式は、UTF-32と呼ばれている。
</p>

<pre>
// 型はchar、値は実装依存。
auto ordinary_c = 'x' ;
// 型はwchar_t、値は実装依存。
auto wide_c = 'x' ;
// 型は、char16_t、値は、0x3042。
auto u16_c = u'あ' ;
// 型は、char32_t、値は、0x00003042。
auto u32_c = U'あ' ;
</pre>

<article>
<h1 id="escape.seaquence"><a href="#escape.seaquence">エスケープシーケンス</a></h1>

<p>
文字リテラルの中では、バックスラッシュは、特別なエスケケープシーケンスとして扱われる。そのため、バックスラッシュを直接使うことはできない。
</p>

<p>
エスケープシーケンスは、以下の通り。
</p>

<pre>
改行 new-line NL(LF) \n
水平タブ horizontal tab HT \t
垂直タブ vertical tab VT \v
バックスペース backspace BS \b
キャリッジリターン carriage return CR \r
フォームフィード form feed FF \f
アラート文字、ベル文字 alert BEL \a
バックスラッシュ backslash \ \\
疑問符 question mark ? \?
単一引用符 single quote ’ \’
二重引用符 double quote " \"
</pre>

<p>
文字リテラルの中では、二重引用符と、疑問符は、そのまま使うことも出来る。
</p>

<pre>
'\n' ;  // 改行
'\\' ; // バックスラッシュ

// 二重引用符と疑問符は、そのまま使える。
'"' ;   '\"' ;
'\?' ;  '?' ;


// エラー、バックスラッシュはエスケープシーケンスの始まりとみなされるため、使えない。
'\' ;
</pre>
</article>
</article>

<article>
<h1 id="lex.string"><a href="#lex.string">文字列リテラル（String literals）</a></h1>

<p>
文字列リテラル（String Literal）には、通常の文字列リテラル、UTF-8文字列リテラル、char16_t文字列リテラル、char32_t文字列リテラルが存在する。また、それぞれの文字列リテラルに対して、生文字列リテラル（Raw String Literal）という書き方ができる。
</p>

<p>
文字列リテラルの文法は、以下の通りである。
</p>

<pre>
<i>エンコーディングプレフィクス<sub>opt</sub></i> " <i>文字列</i> "
</pre>

<p>
文字列リテラルは、<i>文字列</i>の内容で初期化される。ただし、文字列の一番最後には、null文字が付加される。
</p>

<pre>
// 以下の二行のコードは同じ意味である。
char s[4] = { 'a', 'b', 'c', '\0' } ;
char s[] = "abc" ;
</pre>

<p>
文字列リテラルでは、文字リテラルと同じ、エスケープシーケンスが使える。ただし文字リテラルと違い、二重引用符は、そのまま使うことができないので、エスケープシーケンス、\"で表さなければならない。単一引用符、'は、そのまま使うことができる。それ以外は、文字リテラルのエスケープシーケンスと、違いはない。
</p>

<p>
文字列リテラルの型は、要素数nの、constな文字型の配列である。要素数は、文字列リテラル内の文字型の数 + 1である。+ 1は、null文字が付加されるためである。エスケープシーケンスや、ユニバーサル文字名は、一文字として認識される。文字型の数と、文字数とは、同じではない。なぜならば、エンコード方式によっては、ひとつの文字を、複数の文字型で表現するからである。これについては、後述する。
</p>

<article>
<h1 id="encoding-scheme"><a href="#encoding-scheme">エンコード方式</a></h1>
<p>
エンコード方式には、実装依存のエンコード、UTF-8、UTF-16、UTF-32がある。
</p>

<p>
"..."のように、エンコーディングプレフィクス（Encoding Prefix）の指定されていない文字列は、通常の文字列リテラル（ordinary string literal）である。これは、実装依存のエンコード方式が使われる。
</p>

<pre>
"abcdefg" ;
"hello" ;
</pre>

<p>
u8"..."のように、u8というプレフィクスの指定されている文字列リテラルは、UTF-8文字列リテラルである。これは、UTF-8というエンコードが使われる
</p>

<p>
通常の文字列リテラルと、UTF-8文字列リテラルの型は、要素数nの、const charの配列である。
</p>

<pre>
// const char [4]
"abc" ;
u8"abc" ;
// const char [1]
"" ;
u8"" ;
</pre>

<p>
u"..."のように、小文字のuというプレフィクスの指定されている文字列リテラルは、UTF-16文字列リテラルである。これは、UTF-16というエンコードが使われる。
</p>

<p>
UTF-16文字列リテラルの型は、要素数nの、const char16_tの配列である。
</p>

<pre>
// const char16_t [4]
u"abc" ;
// const char16_t [1]
u"" ;
</pre>

<p>
U"..."のように、大文字のUというプレフィクスの指定されている文字列リテラルは、UTF-32文字列リテラルである。これは、UTF-32というエンコードが使われる。
</p>

<p>
UTF-32文字列リテラルの型は、要素数nの、const char32_tの配列である。
</p>

<pre>
// const char32_t [4]
U"abc" ;
// const char32_t [1]
U"" ;
</pre>

<p>
L"..."のように、Lというプレフィクスの指定されている文字列リテラルは、ワイド文字列リテラルである。これは、実装依存のエンコードが使われる。
</p>

<p>
ワイド文字列リテラルの型は、要素数nの、const wchar_tの配列である。
</p>

<pre>
// const wchar_t [4]
L"abc" ;
// const wchar_t [1]
L"" ;
</pre>
</article>

<p>
文字列リテラルの型は、配列であるので、標準変換の、<a href="#conv.array">配列からポインターへの型変換</a>で、ポインターへ、暗黙のうちに変換できる。しかし、C++11では、以前のC++にあった、互換性のための機能が、削られているので、注意を要する。
</p>

<pre>
// エラー
char * ptr = "abc" ;
// OK
char const * ptr = "abc" '
</pre>

<p>
なぜか。文字列リテラルの型は、constな文字型の配列である。constは、暗黙のうちに消しさることはできない。たとえば、int型の場合、これは、従来のC++でも、エラーである。
</p>

<pre>
int const a[4] = {0} ;
// エラー
int * ptr = a ;
</pre>

<p>
今までは、互換性のためだけの理由で、文字型の配列に限り、constを暗黙のうちに消しさることが、特別に許されていた。しかし、そもそも、文字列リテラルへの変更は、未定義である。
</p>

<pre>
// エラー、未定義動作
"abc"[0] = 'd' ;
</pre>

<p>
このため、C++では、文字列リテラルは、constな文字型の配列であることが、1993年に決定された。本来、この時点で、constではない文字型へのポインターへの変換は、廃止されるべきであった。しかし、char *に文字列リテラルを代入している既存のコードが、あまりにも多いため、仕方なく、特別なルールを付け加えた。それが、この、文字型の配列に限り、constを消すことができるというルールである。
</p>

<p>
constを暗黙のうちに消し去ることができると、C++の型システムに穴があいてしまう。いままでは、互換性の問題から、仕方なくこのルールがあったが、C++11では、とうとう、この忌々しい穴は塞がれた。もし、どうしても、既存のコードを利用したい場合は、いくつか方法がある。
</p>

<pre>
// 既存の汚いコードの関数
void f( char * ) ;

// 配列を確保して、渡す。
char temp[] = "abc" ;
f( temp ) ;

// const_castを使用する（非推奨）
f( const_cast&lt;char *&gt;(&quot;abc&quot;) ) ;
</pre>

<p>
そもそも、constではないポインターということは、そのポインターの参照先が、変更されるかもしれないということを意味している。つまり、この関数f()は、ポインターの参照先を書き換えるかもしれない。しかし、文字列リテラルの変更は、そもそも未定義である。したがって、f()には、書き換えられる配列を確保して、そのポインターを渡すのが、正しい。const_castは、f()が、既存のコードであり、今更修正できず、なおかつ、ポインターの参照先を変更しないと保証できる場合に限り、const_castを使うべきである。
</p>

<p>
これから書くコードは、もちろん、constをつけるべきである。本来、変更できないオブジェクトを、非constなポインターで参照できるということが、そもそも間違っている。C++11では、このような暗黙の型変換は存在しない。
</p>

<article>
<h1 id="size.of.string-literal"><a href="#size.of.string-literal">文字列リテラルの型の要素数</a></h1>
<p>
文字列リテラルの型の要素数については、注意が必要である。エスケープシーケンスや、ユニバーサル文字名は、一文字として認識される。さらに、文字数＝要素数ではない。UTF-8によるエンコードは、一文字が、1～４バイトで表される。
</p>

<p>
たとえば、"abc"という文字列リテラルは、UTF-8では、以下のようにエンコードされる。二行のコードは、全く同じ意味である。
</p>
<pre>
char abc[] = u8"abc" ;
char abc[4] = { 0x61, 0x62, 0x63, 0x00 } ;
</pre>

<p>
末尾にnull文字が付加されることを除けば、このコードは、それほど難しくもない。いずれも、一文字がひとつの文字型で表現できる。では、"あ"という文字リテラルを、UTF-8で表現するとどうなるか。
</p>

<pre>
char str[] = u8"あ" ;
char str[4] = { 0xe3, 0x81, 0x82, 0x00 } ;
</pre>

<p>
UTF-8というエンコード方式では、"あ"（U+3042）を表現するのに、三つの要素が必要である。文字数＝要素数ではないということは、よく覚えて置かなければならない。
</p>

<p>
では、UTF-16はどうか。「あ」という文字に関しては、UTF-16は、ひとつの要素で表現できる。
</p>

<pre>
char16_t str[] = u"あ" ;
char16_t str[2] = { 0x3042, 0x0000 } ;
</pre>

<p>
しかし、UTF-16にも、サロゲートペアが存在する。例えば、「𠮷」(U+020bb7)という古い漢字は、以下のようにエンコードされる。
</p>

<pre>
char utf8[] = u8"𠮷" ;
char utf8[5] = { 0xf0, 0xa0, 0xae, 0xb7, 0x00 } ;

char16_t utf16[] = u"𠮷" ;
char16_t utf16[3] = { 0xd842, 0xdfb7, 0x0000 } ;
</pre>

<p>
このように、UTF-16でも、サロゲートペアが必要なコードポイントについては、二つの要素が必要である。またこの字の場合、UTF-8にいたっては、四つもの要素が必要になる。
</p>

<p>
UTF-32には、このような問題はない。
</p>

<pre>
char32_t utf32[] = u"𠮷" ;
char32_t utf32[2] = { 0x00020bb7, 0x00000000 } ;
</pre>

<p>
ユニバーサル文字セットや、UTFのエンコード方式の詳細は、本書の範疇を超えるので、これ以上深くは解説しない。
</p>

<p>
また、charとwchar_tのエンコード方式については、実装依存である。
</p>
</article>

<article>
<h1 id="raw.string.literal"><a href="#raw.string.literal">生文字列リテラル（Raw String Literal）</a></h1>

<p>
文字列リテラルには、直接記述することができない文字が存在する。エスケープシーケンスや、ユニバーサル文字セットだ。その他、改行コードなども、直接記述することはできない。たとえば、以下の文字列を、文字列リテラルを使って書く場合、
</p>

<pre>
aaa
bbb
ccc
\\\
"""
</pre>

<p>
通常の文字列リテラルでは、以下のように書かなければならない。
</p>

<pre>
"aaa\nbbb\nccc\n\\\\\\\n\"\"\""
</pre>

<p>
これは、非常に分かりにくい。そこで、C++には、生文字列リテラル（Raw String Literal）というものがある。これは、文字列を、そのままの形で書くことができる文字列リテラルである。文法は、以下のようになる。
</p>

<pre>
<i>エンコーディングプレフィクス<sub>opt</sub></i> R " デリミター<sub>opt</sub> ( <i>文字列</i> ) デリミター<sub>opt</sub> "
</pre>

<p>
実際の例は、以下の通り。
</p>

<pre>
// ""と同じ
R"()" ;

// "aaa\nbbb\nccc\n\\\\\\\n\"\"\""と同じ
R"(aaa
bbb
ccc
\\\
""")" ;
</pre>

<p>
生文字列リテラルの文字列には、バックスラッシュを含めて、あらゆる文字を書くことができる。二重引用符ですら書ける。
</p>

<p>
問題は、文法の都合上、「)"」という文字列が使えないことだ。これは、デリミターを指定すれば、使えるようになる。
</p>

<pre>
R"delimiter( )" )delimiter" ;
</pre>

<p>
ただし、この場合、「)delimiter"」という文字列は、使うことができない。このデリミターは、16文字以内の、基本ソース文字セット内の文字からなる文字列でなければならない。
</p>

<pre>
// エラー、@という字は、基本ソース文字セットには存在しない。
R"@()@" ;

// エラー、17文字以上書くことはできない。
R"12345678901234567()12345678901234567" ;
</pre>

<p>
基本的に、デリミターは、どのような16文字以内の基本ソース文字セット内の文字列ならば、どのような組み合わせでもよいが、左右のデリミターが一致していなければならない。しかし、大抵の場合は、デリミターをわざわざ使う必要はない。
</p>

<p>
生文字列リテラルは、エンコーディングプレフィクスとともに使うことが出来る。
</p>

<pre>
u8R"" ;
uR"" ;
UR"" ;
LR"" ;
</pre>

<p>
生文字列リテラルと、文字列リテラルは、エンコードが同じである場合、連結できる。文字列リテラルのトークンの連結については、<a href="#lex.phases">ソースファイルの変換</a>を参照のこと。
</p>

<pre>
// "1\n2\n3456"
R"(1
2
3)"
"456" ;
</pre>
</article>
</article>

<article>
<h1 id="lex.bool"><a href="#lex.bool">boolリテラル（Boolean literals）</a></h1>

<p>
boolリテラルは、bool型の真偽を表現するリテラルである。trueとfalseという、二つの値がある。
</p>

<pre>
bool t = true ;
bool f = false ;
</pre>
</article>

<article>
<h1 id="lex.nullptr"><a href="#lex.nullptr">ポインターリテラル（Pointer Literals）</a></h1>

<p>
C++には、nullポインターを表すリテラルが存在する。nullptrである。これは、あらゆるポインター型の、nullポインターを表す。
</p>

<pre>
void * pointer_to_void = nullptr ;
int * pointer_to_int = nullptr ;
</pre>

<p>
従来のC++では、NULLというマクロを使ったり、0を使ったりしてきた。しかし、マクロは問題が多いし、0にも、問題がある。nullポインターは、その内部表現の、すべてのビットが0であることを意味するのではない。ポインターが、何も参照していないということを表す、概念上のものである。そこで、nullptrという、nullポインターを表すポインターリテラルが存在する。従来のNULLや、単なる0のかわりに、nullptrを使うべきである。
</p>
</article>

<article>
<h1 id="lex.ext"><a href="#lex.ext" >ユーザー定義リテラル（User-defined literals）</a></h1>

<p>
ユーザー定義リテラル（User-defined literal）とは、リテラルを、関数として定義できるようにする機能のことである。整数、浮動小数、文字、文字列に対するユーザー定義リテラルが存在する。
</p>

<pre>
// ユーザー定義整数リテラル
123_x ;
// ユーザー定義浮動小数リテラル
1.23_x ;
// ユーザー定義文字リテラル
'a'_x ;
// ユーザー定義文字列リテラル
"abc"_x ;
</pre>

<p>
ユーザー定義リテラルは、演算子のオーバーロードとして、定義する。詳しくは、<a href="#over.literal">ユーザー定義リテラル（User-defined literals）</a>を参照のこと。
</p>
</article>

</article>

</article> <!-- toplevel -->

<article class="toplevel">
<h1 id="basic"><a href="#basic">基本事項（Basic concepts）</a></h1>
<p>
この章では、C++の根本的なルールを解説する。この章の内容は、言語の深い詳細について解説しているので、すべてを理解する必要はない。必要に応じて参照すればよい。
</p>

<article>
<h1 id="basic.def"><a href="#basic.def">宣言と定義（Declarations and definitions）</a></h1>

<p>
C++には、名前という概念が存在する。変数や関数、クラス等には、名前をつけられる。名前を使うには、必ず、あらかじめ、その名前が宣言されていなければならない。
</p>

<article>
<h1 id="difference.def"><a href="#difference.def">宣言（Declaration）と定義（Definition）の違い</a></h1>
<p>
宣言とは、ある名前が、その翻訳単位で、何を意味するのかということを、明示するためにある。
</p>

<p>
定義とは、名前の指し示すものを、具体的に記述することである。宣言と定義は、多くの場合、同時に行われることが多いので、あまり意識しづらい。
</p>


<pre>
// これは関数の宣言
void f( ) ;

// これは関数の宣言と定義
void f( ) { }
</pre>

<p>
以下の例は、関数を宣言だけして、具体的な定義をせずに、使っている。
</p>

<pre>
// 関数の宣言
int f( int ) ;

int main()
{
    int x = f( 0 ) ;
}
</pre>

<p>
これは、問題がない。なぜならば、関数を使うには、引数や戻り値の型などが決まってさえいればよいからだ。この場合、その関数を指し示す名前として、fが使われている。この関数 int f( int )の、具体的な実装、つまり、「定義」は、同じ翻訳単位になくても構わない。つまり、int f( int )は、別のソースコードで定義されているかもしれない。
</p>
</article>

<article>
<h1 id="not_defitinion"><a href="#not_defitinion">定義ではない宣言</a></h1>

<p class="editorial-note">
TODO: FDIS後に変更される。
</p>

<p>
すべての定義は、宣言である。宣言は、定義ではない場合もある。定義ではない宣言は、以下の通りである。
</p>

<section>
<h1>
関数宣言で、関数の本体がない場合。
</h1>

<pre>
// 宣言
void f( int ) ;

// 宣言と定義
void f ( int )  { } 
</pre>
</section>

<section>
<h1>
extern指定子を使っていて、初期化子も、関数の本体も記述されていない宣言。
</h1>

<pre>
// 宣言
extern int x ;

// 宣言と定義
int x ;
</pre>
</section>

<section>
<h1>
リンケージ指定されていて、初期化子も、関数の本体も記述されていない宣言。ただし、{}の中の宣言には、影響しない。
</h1>

<pre>
// 宣言
extern "C" void f() ;


extern "C"
{
// これは、宣言と定義
    void f() { }
    int x ;

// 宣言
    void g() ;
    extern int y ;
}
</pre>
</section>

<section>
<h1>
クラス名の宣言。
</h1>

<pre>
// クラス名の宣言
class C ;

// クラスの宣言と定義
class C { } ;
</pre>
</section>

<section>
<h1>
クラス定義の中の、staticなデータメンバーの宣言。
</h1>

<pre>
class C
{
// 宣言
    static int x ;
} ;

// 定義
int C::x ;
</pre>
</section>

<section>
<h1>
enum名の宣言
</h1>

<pre>
// 宣言
enum E ;

// 宣言と定義
enum E { up, down } ;
</pre>
</section>

<section>
<h1>
typedef宣言
</h1>

<pre>
// 宣言
typedef int type ;
</pre>
</section>

<section>
<h1>
using宣言と、usingディレクティブ
</h1>

<pre>
namespace NS { void f(){} } 

// 宣言
using NS::f ;
using namespace NS ;
</pre>
</section>

<p>
また、static_assert宣言、アトリビュート宣言、空宣言は、定義ではない。
</p>

<pre>
static_assert( true, "" ) ; // 宣言
[[ ]] ; // 宣言
 ; // 宣言
</pre>
</article>

</article>

<article>
<h1 id="basic.def.odr"><a href="#basic.def.odr">ODR（One definition rule）</a></h1>

<p>
ODR（One definition rule）とは、定義は原則として、ひとつしか書けないというルールである。
</p>
<p>
多くの場合、同じ宣言は、いくつでも書ける。ただし、変数、関数、クラス型、enum型、テンプレートの、同じ定義は、ひとつしか書くことができない。
</p>

<pre>
// 同じ宣言はいくつでも書ける。
void f() ; void f() ; void f() ; void f() ;

// 定義はひとつしか書けない。
void f() { }

// エラー、定義が重複している
void f() { }
</pre>

<p>
定義は、プログラムのすべての翻訳単位で、一つでなければならない。なぜ定義はひとつしか書けないのか。定義が複数あると、問題があるからだ。
</p>

<pre>
// 定義が二つある。
int x ;
int x ;
// どっちのx？
x = 0 ;

// 定義が二つある
void f() { }
void f() { }

// どっちのf()？
f() ;
</pre>

<p>
このような問題を防ぐために、定義は、原則として一つでなければならないとされている。
</p>

<p>
原則としてというのは、例外があるのだ。もし、本当に、定義を一箇所でしか書けないと、困ることがある。たとえば、クラスだ。
</p>

<pre>
// 翻訳単位1 A.cpp
// 定義
struct C
{
    int x ;
} ;

C c ; // OK
</pre>

<pre>
// 翻訳単位2 B.cpp
// 宣言
struct C ;

C c ; // エラー
</pre>

<p>
翻訳単位2で、クラスCの変数を定義するためには、クラスCは、定義されていなければならない。しかし、すでに、別の翻訳単位で、定義は書かれている。B.cppにも定義を書いてしまうと、ODRに違反する。これは一体、どうすればいいのか。
</p>

<p>
このため、C++では、クラス型、enum型、外部リンケージを持つインライン関数、クラステンプレート、外部リンケージを持つ関数テンプレート、クラステンプレートのstaticデータメンバー、クラステンプレートのメンバー関数、具体的な型を完全に指定していないテンプレートの特殊化に限り、ある条件を満たせば、別の翻訳単位での、定義の重複を認めている。ある条件とは何か。これには、大きく分けて、二つある。
</p>

<section>
<h1>
同じ定義のソースコードは、全く同じトークン列であること。
</h1>

<pre>
// 翻訳単位1 A.cpp
struct C
{
    int x ;
} ;
</pre>

<pre>
// 翻訳単位2 B.cpp
struct C
{
public :// エラー。
    int x ;
} ;
</pre>

<p>
ここで、翻訳単位2に、public :があろうとなかろうと、意味は変わらない。しかし、全く同じトークン列ではないので、このプログラムはエラーである。
</p>

<p>
全く同じ複数の定義を管理するのは、極めて困難である。そのため、このように翻訳単位ごとに定義しなければならないクラスやテンプレートは、通常、ヘッダーファイルに記述して、必要な翻訳単位ごとに、#includeされる。
</p>

<pre>
// ヘッダーファイル C.h
struct C
{
    int x ;
} ;
</pre>

<pre>
// 翻訳単位1 A.cpp
#include "C.h"

C c ;
</pre>

<pre>
// 翻訳単位2 B.cpp
#include "C.h"

C c ;
</pre>
</section>

<section>
<h1>
定義の意味が、プログラム中のすべての翻訳単位で、同じであること。
</h1>

<p>
定義のソースコードが、全く同じトークン列であるからといって、意味も同じであるとは限らない。
</p>

<pre>
// ヘッダーファイル C.h
class C
{
    void member()
    {
        f() ;// fという名前の、何らかの関数を呼び出す。
    }
} ;
</pre>

<p>
このクラス、Cは、member()というメンバー関数で、f()という関数を呼び出している。では、このクラスを使うコードが、以下のようであれば、どうなるか。
</p>

<pre>
// 翻訳単位1 A.cpp

namespace A
{ void f() {} }

// f()はA::f()を呼び出す
using A::f ;

#include "C.h"
</pre>

<pre>
// 翻訳単位2 B.cpp

namespace B
{ void f() {} }

// f()はB::f()を呼び出す
using B::f ;

#include "C.h"
</pre>

<p>
ヘッダーファイルによって、クラスCのソースコードのトークン列は、全く同じなのに、この例では、呼び出す関数が翻訳単位ごとに変わってしまう。このようなコードはエラーである。プログラム中の同じ定義は、必ず同じ意味でなければならない。
</p>
</section>

</article>

<article>
<h1 id="basic.scope"><a href="#basic.scope">スコープ（Scope）</a></h1>

<article>
<h1 id="basic.scope.declarative"><a href="#basic.scope.declarative">宣言領域とスコープ（Declarative regions and scopes）</a></h1>
<p>
宣言された名前には、その名前が有効に使える範囲が存在する。これを、宣言範囲（declarative region）、スコープ（scope）という。
</p>

<pre>
int x ;

void f()
{
    int y ;

    {
        int z ;
    }
// ここではもう、zは使えない。
}
// ここではもう、yは使えない。

// xは、ここでも使える。
</pre>

<p>
ある名前は、スコープの中ならば、必ず同じ意味であるとは限らない。名前は上書きされる場合がある。
</p>

<pre>
void f()
{// ブロック1
    int x ; // #1
    {// ブロック2
        int x ; //#2
        x = 0 ; // #2が使われる。
    }
    x = 0 ; // #1が使われる。
}
</pre>

<p>
この例では、ブロック1で宣言されたxは、ブロック2では、別の変数を指し示すxに、隠されている。
</p>

<p>
このように、スコープがネストする場合、外側のスコープの名前が、内側のスコープの名前に隠されてしまうことがある。
</p>
</article>

<article>
<h1 id="basic.scope.pdecl"><a href="#basic.scope.pdecl">宣言場所（Point of declaration）</a></h1>
<p>
スコープには、いくつもの種類がある。これを詳しく説明する前に、まず、宣言された名前は、どこから有効なのかということを、明らかにしておかなければならない。この、名前が有効になる始まりの場所を、宣言場所（Point of declaration）という。名前は、宣言のすぐ直後から有効になる。
</p>

<pre>
int x ;// 宣言場所
// ここから、xが使える。
</pre>

<p>
宣言場所は、初期化子よりも、前である。
</p>
<pre>

int x /*ここから名前xは有効*/ = x  ;
</pre>

<p>
この例では、xという変数を宣言して、その変数の値で初期化している。このコードに実用的な意味はない。初期化子の中から、宣言された名前は使えるということを示すためだけの例である。
</p>

<pre>
// エラー
int x[x/*ここでは、まだxは未定義*/] ;
</pre>

<p>
この例は、エラーである。なぜなら、配列の要素数を指定する場所では、xは、まだ定義されていないからだ。これらの例は、通常は気にすることはない、些細な詳細である。一般に、宣言文のすぐ後から使えると考えておけばいい。
</p>
</article>

<article>
<h1 id="basic.scope.local"><a href="#basic.scope.local">ブロックスコープ（Block scope）</a></h1>

<p>
<a href="#stmt.block">ブロック</a>のスコープは、そのブロックの中である。これを、ブロックスコープと呼ぶ。よく、ローカル変数と呼んでいるものは、ブロックスコープの中で宣言された変数のことである。
</p>

<pre>
void f()
{// ブロック1
int x ;
    {// ブロック2
    int y ;
        {// ブロック3
        int z ;
        // x, y, zが使える
        }
    // x, yが使える。
    }
// xが使える。
}

// ここで使える変数名はない。
</pre>

<p>
ブロックはネストできるので、ネストされたブロックの中で、外側のスコープと同じ名前の変数を使いたい場合は、注意が必要である。
</p>

<pre>
void f()
{
    int x ;
    {
        int x ;　// 外側のスコープのxは隠される。
    }
}
</pre>

<p>
関数の仮引数名は、関数本体の一番上のブロックスコープの終わりまで、有効である。
</p>

<pre>
void f( int x )
{

//xはここまで有効
}
// これ以降、xは使えない。
</pre>
</article>

<article>
<h1 id="basic.scope.prot"><a href="#basic.scope.prot">関数プロトタイプのスコープ（Function prototype scope）</a></h1>

<p>
関数のプロトタイプ宣言にも、スコープがある。関数のプロトタイプ宣言のスコープは、その宣言の終わりまでである。
</p>

<pre>
auto f( int x ) -> decltype(x) ;
</pre>

<p>
この例では、仮引数の名前が、decltypeに使われている。
</p>
</article>

<article>
<h1 id="basic.funscope"><a href="#basic.funscope">関数のスコープ（Function scope）</a></h1>

<p>
ブロックスコープではなく、関数自体にも、関数のスコープが存在する。これは、ある関数全体のスコープである。ただし、この関数のスコープが適用されるのは、ラベル名だけである。
</p>

<pre>
void f()
{
    {
        label : ;
    }

    goto label ;// labelは、ここでも有効
}
</pre>

<p>
このように、ラベル名には、関数のスコープが適用される。
</p>
</article>

<article>
<h1 id="basic.scope.namespace"><a href="#basic.scope.namespace">名前空間のスコープ（Namespace scope）</a></h1>

<p>
名前空間のスコープというのは、少しややこしい。まず、名前空間の本体は、もちろんスコープである。
</p>

<pre>
namespace NS
{
    int x ;
// xが使える。
}
// ここでは、xは使えない。
</pre>

<p>
この、名前空間の中の名前（上の例では、x）を、名前空間のメンバー名という。メンバー名のスコープは、名前空間の終わりまでである。
</p>

<p>
ところが、名前空間の本体の定義は、複数書くことができる。
</p>

<pre>
namespace NS
{
    int x ;
// xが使える。
}
// ここでは、xは使えない。


namespace NS
{
    // ここでも、xが使える。
    int y = x ;
}
</pre>

<p>
メンバー名は、その宣言された場所から、後続するすべての同名の名前空間の中で使うことができる。この例の場合、二つめの名前空間NSの定義の中でも、一つめの名前空間NSの定義で宣言されたメンバー名である、xを使うことができる。
</p>

<p>
名前空間のメンバーは、スコープ解決演算子、::を使って、参照することもできる。
</p>

<pre>
namespace NS
{
    using type = int ;
}

// 名前空間NSの、typeという名前を参照している。
NS::type x ;
</pre>

<article>
<h1 id="global.namespace"><a href="#global.namespace">グローバル名前空間（Global namespace）</a></h1>

<p>
翻訳単位の、一番上の、namespaceで囲まれていない場所も、一種の名前空間として扱われる。これは、グローバル名前空間と呼ばれている。グローバル名前空間で定義された名前は、グローバル名前空間のスコープに入る。これは、グローバルスコープとも呼ばれている。グローバル名前空間のスコープは、翻訳単位の終わりまでである。
</p>

<pre>
// グローバル名前空間
int x ;

namespace NS
{// 名前空間、NS

}

// ここは、グローバル名前空間

namespace 
{// 無名名前空間

}

// ここも、グローバル名前空間

// xの範囲は、翻訳単位の終わりまで続く。
</pre>
</article>

</article>

<article>
<h1 id="basic.scope.class"><a href="#basic.scope.class">クラスのスコープ（Class scope）</a></h1>

<p class="editorial-note">
TODO: rewrite.
</p>
<p>
クラスのスコープは、少し変わっている。ブロックスコープなどは、名前の有効な範囲は、名前を宣言した場所から、スコープの終わりまでである。
</p>

<pre>
void f()
{
// ここでは、xは使えない。

int x ;// xを宣言

// ここでは、xを使える。
}
</pre>

<p>
クラスでは、これが変わっている。
</p>

<p>
先に、名前が宣言されていなくても、クラス内の関数からは、その名前を使うことができる。
</p>

<pre>
class C
{
    void f()
    {// 関数の中で、名前を使うことができる。
        type x ;
        value = 0 ;
    }

    type y ;    // エラー。typeは宣言されていない。

    using type = int ;  // typeの宣言場所

    type z ; // OK

    int value ;         // valueの宣言場所
} ;
</pre>

<p>
また、クラスのメンバー関数を、クラスの外部で定義する場合でも、その関数の中から、クラス内で宣言された名前を使うことができる。
</p>

<pre>
class C
{
    void f() ;
    int x ;
} ;

void C::f()
{// クラス外部で定義されたメンバー関数の中で、クラス内で宣言された名前を使える。
    x = 0 ;
}
</pre>

<p>
その他にも、クラス内の名前を、クラス外で使うことができる場合が存在する。
</p>

<pre>
class C
{
public :
    int x ;
    using type = int ;
} ;

int main()
{
    C c ;
    C * p = &amp;c ;
    // クラスのメンバーアクセス演算子の後に続けて、名前を使える。
    c.x = 0 ;
    p->x = 0 ;

    // スコープ解決演算子の後に続けて、名前を使える。
    C::type value ;
}
</pre>

<p>
このように、クラススコープの名前は、宣言した場所から、ある区間まで有効というルールではない。このため、クラスのスコープには特別なルールがある。
</p>

<ul>
<li>クラスのメンバーの宣言が全てわかったあとに、クラス宣言を再評価して、プログラムの意味が変わるとエラー</li>
<li>クラス内のメンバーの宣言の順番を変えた際に、プログラムの意味が変わると、エラー</li>
</ul>

<p>
これは、例をあげて説明したほうが分かりやすい。今仮に、このルールがないものとする。とすると、以下のようなコードが書けてしまう。
</p>

<pre>
// コード1
using type = int ;// #1

class C
{
    type x ;// このtypeは、#1の::type
    using type = float ;// #2
} ;
</pre>

<p>
クラスCの宣言の順番を変えると、以下のコードになる。
</p>

<pre>
// コード2
using type = int ;// #1

class C
{
    using type = float ;// #2
    type x ;// このtypeは、#2の、C::type
} ;
</pre>

<p>
このように、メンバーの宣言の順番を変えることによって、プログラムの意味が変わってしまうと、意図せぬバグを生む原因となる。そのため、このようなコードは、エラーである。
</p>

<p>
ちなみに、コード2も、メンバーの宣言の順番を変えると、コード1と同じコードになる。しかし、コード2は、エラーではない。コード1は、クラス宣言を再評価しようとするとエラーになるので、宣言の順番を変えるとエラーという条件には、あてはまらない。
</p>
</article>

<article>
<h1 id="basic.scope.enum"><a href="#basic.scope.enum">enumのスコープ（Enumeration scope）</a></h1>
<p>
scoped enumは、enumスコープ（enumeration scope）を持つ。このスコープの範囲は、enumの宣言内だけである。
</p>

<pre>
enum class E { x, y, z } ;
//ここで、x, y, zは使えない。
x ; // エラー
E::x ;// OK 
</pre>

<p>
この理由は、scoped enumは、強い型付けを持つenumだからだ。詳しくは、<a href="#dcl.enum">enum</a>を参照のこと。
</p>
</article>

<article>
<h1 id="basic.scope.temp"><a href="#basic.scope.temp">テンプレート仮引数のスコープ（Template Parameter Scope）</a></h1>
<p>
テンプレート仮引数にも、スコープがある。テンプレート仮引数のスコープは、それほど意識する必要はない。
</p>

<pre>
template &lt;
typename T, // これ以降、Tを使える。
typename U = T &gt;
class C { } ;// テンプレート仮引数のスコープ、ここまで
</pre>

<p>
ただし、テンプレート仮引数名は、基本的に、隠すことができない。
</p>

<pre>
template &lt; typename T &gt;
class C
{
    using T = int ; // エラー

    // エラー
    template &lt; typename T &gt;
    void f() ;

} ;
</pre>

<p>
「基本的に」というのは、隠すことができる場合も存在するからだ。
</p>

<pre>
struct Base{ using T = type ; } ;

template &lt; typename T &gt;
struct Derived : Base
{
    T x ;// Base::Tが使われる。テンプレート仮引数ではない。
} ;
</pre>

<p>
といっても、これはよほど特殊な例であり、通常は、テンプレート仮引数名は、隠せないと考えても、問題はない。
</p>
</article>

<article>
<h1 id="basic.scope.hiding"><a href="#basic.scope.hiding">名前隠し（Name hiding）</a></h1>

<p>
ネストされたスコープの内側で、同じ名前が宣言されると、外側の名前は、隠される。
</p>

<pre>
void f()
{// 外側のスコープ
    int x ;
    {// 内側のスコープ
        int x ;// 外側のスコープのxを隠す。
        x = 0 ; // 内側のx
    }
    x = 0 ; // 外側のx
}
</pre>

<p>
派生クラスでは、基本クラスの名前は隠される。
</p>

<pre>
struct Base { using type = char ; } ;

struct Derived
{
    using type = int ;

    type x ; // int
} ;
</pre>

<p>
クラスやenumの名前は、変数やデータメンバーの名前によって、隠される。
</p>

<pre>
class ClassName {} ;

void f()
{
    ClassName ClassName ; // OK、ClassName型の変数、ClassName

    ClassName x ; // エラー、ClassNameは、ここでは変数名を指す。

    class ClassName x ; // OK、明示的にクラス名であると指定している。
}
</pre>

<p>
このように、クラス名と変数名を同じにするのは、非常に分かりにくい問題を引き起こすので、あまりおすすめできない。
</p>
</article>

</article>

<article>
<h1 id="basic.lookup"><a href="#basic.lookup">名前探索（Name lookup）</a></h1>

<p>
あるスコープにおいて、ある名前が使われているとき、その名前が何を意味するのかということを決定するのを、名前探索（Name lookup）と呼ぶ。これは一見簡単そうに思える。しかし、この名前を決定するというルールは、非常に難しい。
</p>

<p>
Name lookupには、大きく分けて、三種類ある。Qualified name lookup、Unqualified name lookup、Argument-dependent name lookupだ。
</p>

<article>
<h1 id="basic.lookup.qual"><a href="#basic.lookup.qual">Qualified 名前探索（Qualified name lookup）</a></h1>
<p>
Qualified nameとは、qualified（修飾）という名前通り、スコープ解決演算子（::）を使った名前のことである。
</p>

<pre>
int g ;

namespace NS { int x ; }

struct C { static int x ;} ;
int C::x ;

enum struct E { e } ;

int main()
{
    // これらはQualified name lookup
    NS::x ; // NSという名前空間のx
    C::x ;  // Cというクラスのx
    E::e ; // Eというenumのメンバー、e
    ::g ;   // グローバル名前空間のg
    
}
</pre>

<p>
このような名前に対する名前探索を、Qualified name lookupという。
</p>

<p>
スコープ解決演算子（::）の左側には、クラス名か、名前空間名か、enum名を書くことができる。左側に何も書かない場合、グローバル名前空間が使われる。Qualified name lookupでは、名前は、スコープ解決演算子で指定された、クラスや名前空間、enum内の名前から、探索される。
</p>


<p>
スコープ解決演算子は、ネストできる。
</p>

<pre>
namespace N1 { namespace N2 {
    int x ;
} }

N1::N2::x ;
</pre>
</article>

<article>
<h1 id="basic.lookup.unqual"><a href="#basic.lookup.unqual">Unqualified 名前探索（Unqualified name lookup）</a></h1>

<p>
Unqualified（非修飾） name lookupは、Qualified name lookup以外を指す。これはつまり、スコープ解決演算子を使わない名前に対する、名前探索である。
</p>

<pre>
int g ;

namespace NS { int x ; }

int main()
{
    g ;// グローバル変数のg

    int g ;
    g ;// ローカル変数のg

    {
        using namespace NS ;
        x ; // NS::xと同じ
    }

    {
        using NS::x ;
        x ; // NS::xと同じ
    }
}
</pre>

<p>
Unqualified nameに対する名前探索を、Unqualified name lookupという。Unqualified name lookupでは、その名前が使われている場所で、明示的に修飾しなくても、見つかる名前が探される。これは、例えばグローバル名前空間内の名前であったり、クラス内であれば、クラスのメンバーであったりする。また、using directiveや、using declarationの影響をうける。
</p>
</article>

<article>
<h1 id="basic.lookup.argdep"><a href="#basic.lookup.argdep">ADL（Argument-dependent name lookup）</a></h1>

<p>
Unqualified nameに対して、関数呼び出しをする場合、特別なルールがある。このルールを、ADL(Argument-dependent name lookup)という。
</p>

<pre>
namespace NS
{
    class C {} ;
    void f( C ) {}
}

int main()
{
    NS::C c ;
    f(c) ;// NS::fを呼ぶ
}
</pre>

<p>
このコードでは、通常は見つからないはずの、NSという名前空間内の関数であるfが、Unqualified nameなのにもかかわらず、見つかる。これを、実引数に依存する名前探索（Argument-dependent name lookup）と呼ぶ。しばしば、ADLと略される。また、Andrew Koenigさんが、名前空間の導入によって、特に演算子のオーバーロードで、ADLのような必要性を意見したため、koenig lookupとも呼ばれることがある。Andrew Koenigさんが、ADLの具体的な仕組みを考案したわけではない。誰がADLの原案を考えだしたのかは、歴史に埋もれて忘れ去られているが、そのような歴史的な経緯と誤解により、Koening lookupと呼ばれている。
</p>

<p>
このADLというルールは、一見すると、非常に奇妙なルールである。このような仕組みは、非常に厄介な問題を引き起こすのではないか。事実、ADLは時として、問題になることがある。それでもADLが存在するのは、利点があるからだ。
</p>

<p>
整数を表現するクラス、Integerを考える。名前の衝突を防ぐため、このクラスは、libという名前空間の中に入れたい。また、整数として分かりやすく使うために、演算子をオーバーロードしたい。Integerクラスは、以下のように使えるものとする。
</p>

<pre>
int main()
{
    lib::Integer x ;
    // 演算子のオーバーロードによる、分かりやすい加算のコード。
    x + x ;
}
</pre>

<p>
さっそく、このIntegerを実装してみよう。
</p>

<pre>
namespace lib
{
    // クラス
    class Integer {/*実装*/} ;
    // 演算子のオーバーロード
    Integer operator + ( Integer const &amp;, Integer const &amp;)
    {
        // 実装
        return Integer() ;
    }
}
</pre>

<p>
もしここで、ADLがない場合、operator +()の呼び出しが、困ったことになる。なぜなら、Unqualified lookupでは、lib名前空間の中の名前を探してはくれない。つまり、operator +は、見つからないのである。
</p>

<pre>
lib::Integer x ;
// エラー、operator + が見つからない。
x + x ;
</pre>

<p>
ではどうするか。これは、Qualified lookupを使うしかない。
</p>

<pre>
lib::operator +( x, x ) ;
</pre>

<p>
このコードは動く。確かに動くが、これでは、せっかく演算子をオーバーロードした意味がない。そもそも、演算子をオーバーロードする理由とは、x + x という、分かりやすい使い慣れたコードを書くためだからだ。
</p>

<p>
このため、Unqualified nameに対する、関数呼び出しには、Unqualified name lookupに加えて、ADLという仕組みで、名前が探索されるようになっている。
</p>

<article>
<h1 id="associated_class_and_namespace"><a href="#associated_class_and_namespace">関連クラスと関連名前空間</a></h1>

<p>
ADLは、その名前が示すとおり、「実引数に依存する名前解決」である。どの名前空間から、名前を探すかということは、実引数の型から決定される。また、ADLは、必ず行われるわけではない。ADLが適用される条件というものが存在する。
</p>

<p>
ADLはどのように行われるか。まず、関数に対する、関連クラス（Associated class）と、関連名前空間（Associated namespace）というものが決定される。ADLは、この関連名前空間の中から、名前を探索する。
</p>

<p>
関連クラスとは、関数に実引数として渡される型である。関連名前空間とは、関連クラスがメンバーとなっている名前空間である。
</p>

<pre>
namespace NS
{
    class A {} ; class B {} ; class C {} ; class D {} ;
    void f( A, B, C, D ) {}
}

int main()
{
    NS::A a ; NS::B b ; NS::C c ; NS::D d ;
    f( a, b, c, d ) ;
}
</pre>

<p>
この場合、fの関数呼び出しに対する関連クラスは、A、B、C、Dで、関連名前空間は、NSとなる。
</p>

<pre>
namespace A { class C {} ; }
namespace B
{
    class C {} ;
    void f( A::C, B::C ) {}
}

int main()
{
    A::C ac ; B::C bc ;
    f( ac, bc ) ;
}
</pre>

<p>
この場合、fの関数呼び出しに対する関連クラスは、A::C、B::Cで、関連名前空間は、A、Bとなる。
</p>

<p>
実引数の型のクラスの、基本クラスも、関連クラスになる。
</p>

<pre>
namespace NS
{
    class A {} ;
    class B : A {} ;
    class C : B {} ;

    void f( C ) {}
}

int main()
{
    NS::C c ;
    f( c ) ;
}
</pre>

<p>
この場合、関数NS::fに対する関連クラスは、A、B、Cで、関連名前空間は、NSとなる。
</p>

<p>
実引数がクラステンプレートであった場合、そのクラスのテンプレート実引数も、関連クラスになる。
</p>

<pre>
namespace NS
{
    template &lt; typename T &gt; class C {} ;
}

namespace lib
{
    class type {} ;

    template &lt; typename T &gt;
    void f( NS::C&lt;T&gt; ) {}
}

int main()
{
    NS::C&lt; lib::type &gt; c ;

    // 関連クラスは、NS::C&lt; lib::type &gt;と、lib::type。
    // 関連名前空間は、NSと、lib。
    f(c) ; // lib::fを呼び出す。
}
</pre>

<p>
テンプレート実引数も関連クラスになるというルールは、この例のような、非常に分かりにくいコードのコンパイルを通してしまう。
</p>

<p>
実引数がクラス以外の場合も、ADLは適用される。
</p>

<p>
実引数がenumの場合、そのenumが定義されている名前空間が、関連名前空間になる。
</p>

<pre>
namespace NS
{
    enum struct E { value } ;
    void f( E ) {}
}

int main()
{
    f( NS::E::value ) ; // NS::fを呼び出す。
}
</pre>

<p>
この場合、関数、NS::fの関連名前空間は、NSとなる。
</p>
</article>

<article>
<h1 id="ADL_condition"><a href="#ADL_condition">ADLが適用される条件</a></h1>

<p>
ADLが適用されるには、条件を満たさなければならない。まず、ADLは、Unqualified nameへの関数呼び出しにしか、適用されない。変数としての使用には、ADLは使われない。
</p>

<pre>
namespace NS
{
    class C {} ;

    void f( C ) {}
    void g( C ) {}
}

void g( NS::C ) {}

int main()
{
    NS::C c ;
    

    f(c) ;      // ADLで、NS::fを呼ぶ
    NS::f(c) ;  // Qualified name lookupが行われる

    ::g(c) ;    // Qualified name lookupが行われる
    NS::g(c) ;  // Qualified name lookupが行われる
    
    
    g(c) ;      // エラー。::g、NS::gのどちらの名前か、曖昧。
}
</pre>

<p>
最後の例は、Unqualified name lookupで、::gが発見され、ADLで、NS::gが発見されるので、どちらの名前を使うのか、曖昧で、エラーになる。
</p>

<p>
もし、Unqualified name lookupで、関数名以外の名前が見つかった場合、ADLは行われない。
</p>

<pre>
namespace NS
{
    class C {} ;
    void f( C ) {}
}

int f ;

struct Caller
{
    void f( NS::C ) {}

    void g()
    {
        NS::C c ;
        f(c) ;// Caller::fが呼ばれる。ADLは行われない。
    }
} ;

int main()
{
    NS::C c ;

    f(c) ; // エラー。fはint型の変数
}
</pre>

<p>
ブロックスコープ関数宣言の名前が見つかった場合、ADLは行われない。ただし、using宣言や、usingディレクティブは、影響しない。
</p>

<pre>
namespace NS
{
class C {} ;

void f( C ) {}
}

namespace lib { void f( NS::C ) {} }

int main()
{
    NS::C c ;

    {
        void f( NS::C ) ;// ブロックスコープの関数宣言
        f(c) ;// ::fを呼び出す。ブロックスコープの宣言が見つかったので、ADLは行われない。
    }

    {
        using namespace lib ;
        f(c) ; // エラー、ADLも行われるので、曖昧になる。
    }

    {
        using lib::f ;
        f(c) ; // エラー、ADLも行われるので、曖昧になる。
    }
}

// ブロックスコープの関数宣言で参照される、グローバル名前空間のf
void f( NS::C ) {}
</pre>

<p>
ブロックスコープ内で関数宣言をするということは、言語上は認められているが、現実的には、あまり用いられていない。
</p>

<p>
using宣言や、usingディレクティブが、ADLの適用を妨げないということは、注意を要する。これにより、不思議なコンパイルエラーになることがある。例えば、上の例の場合、NS名前空間のコードは、他人が書いたものであり、ユーザーはよく知らないとしよう。lib名前空間のコードは、ユーザーが書いたものである。ユーザーは、lib::fを使いたい。main関数内で多用するので、using宣言を使って、簡単に呼び出せるようにした。ところが、NS名前空間の中にも、同名の関数があるので、曖昧エラーになってしまう。
</p>

<p>
ADLが意図せず適用された際のエラーは、非常に分かりにくい。そのため、ADLを防ぐための方法が用意されている。名前を括弧で囲めば、ADLの適用が阻害される。
</p>

<pre>
namespace NS
{
class C {} ;
void f( C ) {}
}

void f( NS::C ) {}

int main()
{
    NS::C c ;

    f(c) ; // エラー。曖昧

    (f)(c) ; // OK、ADLは適用されない。::fを呼び出す。
}
</pre>

<p>
unqualified nameへの関数呼び出しは、通常のunqualified name lookupと、ADLとで見つかった名前の、両方が用いられる。
</p>
</article>
</article>
</article>

<article>
<h1 id="basic.link"><a href="#basic.link">プログラムとリンケージ（Program and linkage）</a></h1>
<p>
TODO: これはそれほど詳しく説明する必要はないかも。
</p>
</article>

<article>
<h1 id="basic.start"><a href="#basic.start">プログラムの開始と終了（Start and termination）</a></h1>

<article>
<h1 id="basic.start.main"><a href="#basic.start.main">main関数（Main function）</a></h1>
</article>

<article>
<h1 id="basic.start.init"><a href="#basic.start.init">非ローカル変数の初期化（Initialization of non-local objects）</a></h1>
</article>

<article>
<h1 id="basic.start.term"><a href="#basic.start.term">終了（Termination）</a></h1>
</article>

</article>







<p class="editorial-note">
TODO:これ以前、未執筆。
</p>

</article>

<article class="toplevel">
<h1 id="conv"><a href="#conv">標準型変換（Standard conversions）</a></h1>
<p>
標準型変換（Standard conversion）は、暗黙の型変換とも呼ばれている。C++には、多くの組み込み型があるが、異なる型なのにもかかわらず、キャストを使わず、暗黙的に型を変換できる場合がある。この機能のことを、標準型変換いう。
</p>

<pre>
short a = 0 ;
int b = a ;// shortからintへ
long c = b ;// intからlongへ
</pre>

<p>
この例では、shortからintへ、intからlongへと、型を変換している。すべての標準型変換が、このように分かりやすくて安全だとは限らない。
</p>

<pre>
int a = 123456789 ;
float b = a ;// intからfloatへ
b = 0.12345 ;
a = b ; // floatからintへ
</pre>

<p>
float型が、int型で表現できる整数の桁をすべて表現できるとは限らない。int型は、整数を表す型であるので、小数点数を正しく表現することはできない。もし、整数と浮動小数点数間で、値を完全に表現できない場合、実装依存の方法で、近い値が使われる。
</p>

<p>
標準型変換は、人間にとって、できるだけ自然になるように、設計されている。しかし、この標準型変換は、Cから受け継いだ、歴史のある汚い機能なので、どうしても、安全ではない。ここでは、どのような標準型変換があるかを、詳しく説明する。
</p>

<p>
本書では、普段、「暗黙の型変換」と簡単に呼んでいる標準型変換に、どのようなものがあるのかということを取りあげる。
</p>

<article>
<h1 id="conv.lval"><a href="#conv.lval">lvalueからrvalueへの型変換（Lvalue-to-rvalue conversion）</a></h1>

<p>
本書では、煩雑を避けるために省略しているが、多くの標準型変換は、ある型のprvalueの値を、別の型のprvalueの値に変換するようになっている。そのため、標準型変換の際には、必要な場合、glvalueが、自動的にprvalueに変換される。これを、lvalueからrvalueへの型変換という。変換できるglvalueは、関数と配列以外である。
</p>

<p>
この変換は、通常、まず意識することがない。
</p>
</article>

<article>
<h1 id="conv.array"><a href="#conv.array">配列からポインターへの型変換（Array-to-pointer conversion）</a></h1>

<p>
配列とポインターは、よく混同される。その理由の一つに、配列名が、あたかもポインターのように振舞うということがある。
</p>

<pre>
int a[10] ;
// pは、aの先頭要素を指す。
int * p = a ;

// どちらも、配列aの先頭要素に0を代入する
*a = 0 ;
*p = 0 ;
</pre>

<p>
これは、配列からポインターへの型変換によるものである。配列名は、配列の先頭要素へのポインターとして扱われる。
</p>

<pre>
int a[10] ;


int * p1 = a ; // &amp;a[0]と同じ
int (* p2 )[10] = &amp;a ; // int [10]へのポインター
</pre>

<p>
ここで、変数aの型は、int [10]であって、int *ではない。ただし、int *に暗黙のうちに型変換されるので、あたかもポインターのように振舞う
</p>

<p>
多くの人は、これを暗黙の型変換としては意識していない。配列からポインターへの型変換は、非常によく使われる変換であって、多くの式では、配列名は、自動的に、配列の先頭要素へのポインターに型変換される。
</p>

<h1 id="conv.func"><a href="#conv.func">関数からポインターへの型変換（Function-to-pointer conversion）</a></h1>

<p>
関数の名前は、その関数へのポインターに型変換される。
</p>

<pre>
void f( void ) {}

int main()
{
    // typeは関数ポインターの型
    using type = void (*) (void) ;

    // 同じ意味。
    type p1 = f ;
    type p2 = &amp;f ;
}
</pre>

<p>
fの型は、関数であって、関数ポインターではない。関数ポインターとは、&amp;fである。しかし、関数は、暗黙のうちに、関数ポインターに型変換されるので、関数名fは、関数ポインターとしても使うことができる
</p>

<p>
この型変換も、非常によく使われる。多くの場合は、自動的に、関数は関数ポインターに変換される。
</p>

<p>
ただし、この型変換は、非staticなメンバー関数には適用されない。ただし、staticなメンバー関数は、この標準変換が適用される。
</p>

<pre>
struct C
{

    void f(void) {}
    static void g(void) {}
} ;

// エラー
void ( C:: * error )(void) = C::f ;
// OK
void ( C::* ok )(void) = &amp;C::f ;

// staticなメンバー関数は、普通の関数と同じように、変換できる
void (*ptr)(void) = C::g ;
void (*ptr2)(void) = &amp;C::g ; // ただし、こちらの方が分かりやすい
</pre>

<p>
このような暗黙の型変換があるとはいえ、通常、関数ポインターを扱う際には、明示的に<a href="#expr.unary.op">単項演算子</a>である&amp;演算子を使ったほうが、分かりやすい。
</p>
</article>

<article>
<h1 id="conv.qual"><a href="#conv.qual">CV修飾子の型変換（Qualification conversions）</a></h1>

<p>
ある型Tへのポインターは、あるconstまたはvolatile付きの型Tへのポインターに変換できる。
</p>

<pre>
int * p ;
int const * cp = p ;
int volatile * vp = p ;
int const volatile * cvp = p ;

cvp = cp ;
cvp = vp ;
</pre>

<p>
これは、より少ないCV修飾子へのポインターから、より多いCV修飾子へのポインターに、暗黙のうちに型変換できるということである。
</p>

<p>
ただし、ポインターのポインターの場合は、注意を要する。
</p>

<pre>
int ** p ;

// エラー
int const ** cp = p ;

// これはOK
int const * const * cp = p ;
</pre>

<p>
なぜか。実は、この型変換を認めてしまうと、const性に穴が空いてしまうのだ。
</p>

<pre>
int main()
{
    int const x = 0 ;
    int * p ;

    // これはエラー。
    p = &amp;x ;

    // もしこれが認められていたとする。
    // 実際はエラー。
    int const ** cpp = &amp;p ;

    // cppを経由して、pを書き換えることができてしまう。
    *cpp = &amp;x ;

    // pは、xを参照できてしまう。
    *p = 0 ;
}
</pre>

<p>
このため、ある型をTとした場合、T **から、T const **への型変換は、認められていない。T **から、T const * const *への変換はできる。
</p>

<pre>
int * p = nullptr ; 
int const * const * p2 = &amp;p ; // OK
</pre>
</article>

<article>
<h1 id="conv.rank"><a href="#conv.rank">整数の変換順位（Integer conversion rank）</a></h1>
<p>
整数型には、変換順位というものが存在する。これは、標準型変換や、リスト初期化で考慮される、整数型の優先順位である。これは、それほど複雑な順位ではない。基本的には、型のサイズの大小によって決定される。もっとも、多くの場合、型のサイズというのは、実装依存なのだが。
</p>

<p>
基本的な変換順位は、以下のようになる。
</p>

<pre>
signed char &lt; short int &lt; int &lt; long int &lt; long long int
</pre>

<p>
unsignedな整数型の順位は、対応するsingedな型と同じである。
</p>

<p>
この他にも、いくつか細かいルールがある。
</p>

<p>
charとsigned charと、unsigned charは、同じ順位である。
</p>

<p>
boolは、最も低い順位となる。
</p>

<p>
char16_t、char32_t、wchar_tの順位は、実装が割り当てる内部的な型に依存する。従って、これらの変換順位は、実装依存である。
</p>

<p>
拡張整数型、つまり、実装が独自に定義する整数型は、実装依存の順位になる。
</p>
</article>

<article>
<h1 id="conv.prom"><a href="#conv.prom">整数のプロモーション（Integral promotions）</a></h1>

<p>
整数のプロモーションとは、変換順位の低い型から、高い型へ、型変換することである。ただし、単に順位が低い型から高い型への型変換なら、何でもいいというわけではない。
</p>

<p>
bool, char16_t, char32_t、wchar_t以外の整数型で、intより変換順位の低い整数型、つまり、char、short、その他の実装独自の拡張整数型は、もし、int型が、その値をすべて表現できる場合、intに変換できる。
</p>

<pre>
short s = 0 ;
int i = s ; // 整数のプロモーション
long l = s ; // これは、整数の型変換
</pre>

<p>
intより低い順位の整数型から、int型への変換ということに注意しなければならない。longやlong longへの変換、または、charからshortへの変換などは、プロモーションではなく、<a href="#conv.integral">整数の型変換</a>に分類される。
</p>

<p>
char16_t、char32_t、wchar_tは、実装の都合による内部的な整数型に変換できる。内部的な整数型というのは、int、unsigned int、long int、unsigned long int、long long int、unsigned long long intのいずれかである。もし、これらのどの型でも、すべての値を表現できないならば、実装依存の整数型に変換することができる。
</p>

<p>
今、int型で、char16_tとchar32_tの取りうるすべての値が表現できるものとすると、
</p>

<pre>
char16_t c16 = u'あ' ;
char32_t c32 = U'あ' ;
wchar_t wc = L'あ' ;

int x = 0 ;
x = c16 ; // xの値は0x3042
x = c32 ; // xの値は0x3042
x = wc ; // xの値は実装依存
</pre>

<p>
int型のサイズは、実装により異なるので、このコードは、実際のC++の実装では、動く保証はない。
</p>

<p>
基底型が指定されていないunscoped enum型は、int、unsigned int、long int、unsigned long int、long long int、unsigned long long intのうち、enum型のすべての値を表現できる最初の型に変換できる。もし、どの標準整数型でもすべての値を表現できない場合、すべての値を表現できる実装依存の拡張整数型のうち、もっとも変換順位の低い型が選ばれる。もし、順位の同じ整数型が二つある場合。つまり、signedとunsignedとが違う場合、signedな整数型の方が選ばれる。
</p>

<p>
基底型が指定されてるunscoped enum型は、指定された基底型に変換できる。その場合で、さらに整数のプロモーションが適用できる場合も、プロモーションとみなされる。例えば、
</p>

<pre>
enum E : short { value } ;

short s = value ;// これは整数のプロモーション
int i = value ; // これも整数のプロモーション
</pre>

<p>
このように、enumの場合は、int型以外への変換でも、プロモーションになる。
</p>

<p>
int型への代入では、enum型が、基底型であるshortに変換された後、さらにintに変換されている。これは、どちらもプロモーションである。
</p>

<p>
<a href="#class.bit">ビットフィールド</a>は、すべての値を表現できる場合、intに変換できる。
</p>

<pre>
struct A
{
    int x:8 ;
} ;

int main()
{
    A a = {0} ;
    int x = a.x ;// 整数のプロモーション
}
</pre>

<p>
もし、ビットフィールドの値が、intより大きいが、unsigned int型で表現できる場合は、unsigned intに変換できる。値がunsigned intより大きい場合は、整数のプロモーションは行われない。整数の型変換が行われる。
</p>

<p>
bool型の値は、int型に変換できる。falseは0となり、trueは1となる。
</p>

<pre>
int a = true ; // aは1
int b = false ; // bは0
</pre>

<p>
以上が、整数のプロモーションである。これに当てはまらない整数型同士の型変換は、すべて、次に述べる<a href="#conv.integral">整数の型変換</a>である。
</p>
</article>

<article>
<h1 id="conv.integral"><a href="#conv.integral">整数の型変換（Integral conversions）</a></h1>

<p>
整数型は、他の整数型に型変換できる。ほんの一例を示すと、
</p>

<pre>
short s = 0 ;
int i = s ;// shortからintへの変換
s = i ; // intからshortへの変換

unsigned int ui = i ; // intからunsigned intへの変換
i = ui ; // unsigned intからintへの変換

long l = s ; // shortからlongへの変換
long long ll = l ; // longからlong longへの変換。
</pre>

<p>
<a href="#conv.prom">整数のプロモーション</a>以外の整数の型変換は、すべて、整数の型変換になる。この違いは、オーバーロード解決などに影響するので、重要である。
</p>

<p>
整数の型変換は、危険である。変換先の型が、変換元の値を表現できない場合がある。
</p>

<p>
例えば、今、signed charは8ビットで、intは16ビットだと仮定する。
</p>

<pre>
#include &lt;limits&gt;

int main()
{
    int i = std::numeric_limits&lt;signed char&gt;::max() + 1 ;
    signed char c = i ;// どうなる？
}
</pre>

<p>
signed charは、intの取りうる値をすべて表現できるわけではない。この場合、どうなってしまうのか。
</p>

<p>
変換先の整数型がunsignedの場合、結果の値は、変換元の対応する下位桁の値である。
</p>

<p>
具体的な例を示して説明する。
</p>

<pre>
// unsigned charが8ビット、unsigned intが16ビットとする

int main()
{
    unsigned int ui = 1234 ;
    unsigned char uc = ui ; // 210
}
</pre>

<p>
この場合、unsigned int型は、16ビット、uiの値は、2進数で0000010011010010である。unsigned char型は8ビット。つまり、この場合の対応する下位桁の値は、2進数で11010010（uiの下位8ビット）である。よって、ucは、10進数で210となる。
</p>

<p>
unsignedの場合、変換先の型が、変換元の値を表現できないとしても、その値がどうなるかだけは、保証されている。もっとも、値を完全に保持できないので、危険なことには変わりないのだが。
</p>

<p>
変換先の整数型がsignedの場合は、非常に危険である。変換先の整数型が、変換元の値を表現できる場合、値は変わらない。表現できない場合、その値は実装依存である。
</p>

<p>
今仮に、int型は、signed char型の取りうる値をすべて表現できるが、signed char型は、int型の取りうる値をすべて表現することはできないとする。また、signed charは8ビット、intは16ビットとする。signed charの最小値は-127、最大値は127。intの最小値は-32767、最大値は32767とする。
</p>

<pre>
int main()
{
    signed char c = 100 ;
    int i = c ; // iの値は100

    signed char value = 1000 ; // 値は実装依存

}
</pre>

<p>
iの値は、100である。なぜなら、今仮定した環境では、int型は100を表現できるからである。valueの値は、実装依存であり、分からない。なぜならば、signed char型は、1000を表現できないからだ。その場合、変換先のsignedな整数型の値は、実装依存である。
</p>
</article>

<article>
<h1 id="conv.fpprom"><a href="#conv.fpprom">浮動小数点数のプロモーション（Floating point promotion）</a></h1>

<p>
float型の値は、double型の値に変換できる。このとき、値は変わらない。つまり、floatからdoubleへの変換は、まったく同じ値が表現できることを意味している。
</p>

<pre>
float f = 3.14 ;
double d = f ; // dの値は3.14
</pre>

<p>
この変換を、浮動小数点数のプロモーションという。
</p>
</article>

<article>
<h1 id="conv.double"><a href="#conv.double">浮動小数点数の型変換（Floating point conversions）</a></h1>
<p>
浮動小数点数のプロモーション以外の、浮動小数点数同士の型変換を、浮動小数点数の型変換という。
</p>

<pre>
double d = 0.0 ;
float f = 0.0 ;
long double ld = 0.0 ;

f = d ; // doubleからfloatへの型変換
ld = f ; // floatからlong doubleへの型変換
ld = d ; // doubleからlong doubleへの型変換
</pre>

<p>
もし、変換先の型が、変換元の型の値を、すべて表現できるのならば、値は変わらない。値を正確に表現できない場合は、最も近い値が選ばれる。この近似値がどのように選ばれるかは、実装依存である。近似値すら表現できない場合の挙動は、未定義である。
</p>
</article>

<article>
<h1 id="conv.fpint"><a href="#conv.fpint">浮動小数点数と整数の間の型変換（Floating-integral conversions）</a></h1>

<p>
浮動小数点数型は、整数型に変換できる。このとき、小数部分は切り捨てられる。小数部分を切り捨てた後の値が、変換先の整数型で表現できない場合、挙動は未定義である。
</p>

<pre>
int x = 1.9 ;// xの値は、1
int y = 1.9999 ; // yの値は、1
int z = 0.9999 ; // zの値は、0
</pre>

<p>
整数型、あるいはunscoped enum型は、浮動小数点数型に変換できる。結果は、可能であれば、まったく同じ値になる。近似値で表現できる場合、実装依存の方法によって、近似値が選ばれる。値を表現できない場合の挙動は、未定義である。
</p>

<pre>
float f = 1 ;// fの値は、1.0f
</pre>
</article>

<article>
<h1 id="conv.ptr"><a href="#conv.ptr">ポインターの型変換（Pointer conversions）</a></h1>

<p>
nullポインター定数とは、整数型定数で、0であるものか、std::nullptr_t型である。
</p>

<pre>
0 ; // nullポインター定数
1 ; // これはnullポインター定数ではない
nullptr ; // nullポインター定数。型はstd::nullptr_t
</pre>

<p>
0がnullポインター定数として扱われるのは、歴史的な理由である。
</p>


<p>
nullポインター定数は、どんなポインター型にでも変換できる。この値を、nullポインター値（null pointer value）という。nullポインター定数同士を比較すると、等しいと評価される。
</p>

<pre>
int * a = nullptr ;
char * c = nullptr ;
int ** pp = nullptr ;

bool b = (nullptr == nullptr) ; // true
</pre>

<p>
nullポインター定数を、CV修飾付きの型へのポインターに変換する場合、このポインターの型変換のみが行われる。CV修飾子の型変換ではない。
</p>

<pre>
// ポインターの型変換のみが行われる。
// CV修飾子の型変換は行われない。
int const * p = nullptr ;
</pre>

<p>
整数型定数のnullポインター定数は、std::nullptr_t型に変換できる。結果の値は、nullポインターである。
</p>

<pre>
std::nullptr_t null = 0 ;
</pre>

<p>
あるオブジェクトへのポインター型は、voidへのポインターに変換できる。
</p>

<pre>
int x = 0 ;
int * int_pointer = &amp;x ;
void * void_pointer = int_pointer ;// int *からvoid *に変換できる
</pre>

<p>
この時、CV修飾子が付いていた場合、消すことはできない。
</p>

<pre>
int x = 0 ;
int const * int_pointer = &amp;x ;

void * error = int_pointer ; // エラー
void const * ok = int_pointer ; // OK
</pre>

<p>
void *に変換した場合、ポインターの値は、変換元のオブジェクトのストレージの、先頭を指し示す。値がnullポインターの場合は、変換先の型のnullポインターになる。
</p>

<p>
派生クラスのポインターから、基本クラスのポインターに変換することができる。
</p>

<pre>
struct Base { } ;
struct Derived : Base { } ;

D * p = nullptr ;
Base * bp = p ; // OK。Derived *からBase *への変換
</pre>

<p>
もし、基本クラスにアクセス出来ない場合や、曖昧な場合は、エラーとなる。
</p>

<pre>
// 基本クラスにアクセス出来ない場合
struct Base { } ;
struct Derived : private Base { } ;

Derived * d = nullptr ;
Base * b = d ;// エラー。Baseにはアクセス出来ないので、変換できない
</pre>

<pre>
// 曖昧な場合
struct Base { } ;
struct Wrap1 : Base { } ;
struct Wrap2 : Base { } ;

// Derivedは、基本クラスとしてふたつのBaseを持っている。
struct Derived : Wrap1, Wrap2 { } ;

Derived * ptr = nullptr ;

// エラー
// Wrap1::Baseと、Wrap2::Baseのどちらなのかが曖昧
Base * ambiguous_base = ptr ;

// OK
// Wrap1::Base
Base * Wrap1_base = static_cast&lt;Wrap1 *&gt;(ptr) ;
</pre>

<p>
派生クラスのポインターから基本クラスポインターへの変換の結果は、派生クラスの中の、基本クラス部分を指す。これは、変換の結果、ポインターの値が変わる可能性がある。実装に依存するので、あまり具体的な例を挙げたくはないが、例えば、以下のようなコードは、多くの実装で、ポインターの値が変わる。
</p>

<pre>
#include &lt;cstdio&gt;

struct Base1 { int x ; } ;
struct Base2 { int x ; } ;
struct Derived : Base1, Base2 { } ;



int main()
{
    Derived d ;

    // dへのポインター
    Derived * d_ptr = &amp;d ;
    std::printf("d_ptr : %p\n", d_ptr) ;

    // 基本クラスのポインターへ型変換
    Base1 * b1_ptr = d_ptr ;
    Base2 * b2_ptr = d_ptr ;

    // 多くの実装では、
    // b1_ptrとb2_ptrのどちらかが、d_ptrと同じ値ではない。
    std::printf("b1_ptr : %p\n", b1_ptr) ;
    std::printf("b2_ptr : %p\n", b2_ptr) ;

    // 派生クラスへキャスト（標準型変換の逆変換）
    Derived * d_ptr_from_b1 = static_cast&lt;Derived *&gt;(b1_ptr) ;
    Derived * d_ptr_from_b2 = static_cast&lt;Derived *&gt;(b2_ptr) ;

    // 多くの実装では、
    // d_ptrと同じ値になる。
    std::printf("d_ptr_from_b1 : %p\n", d_ptr_from_b1) ;
    std::printf("d_ptr_from_b2 : %p\n", d_ptr_from_b1) ;
}
</pre>

<p>
このように、基本クラスと派生クラスの間のポインターのキャストは、ポインターの値の変わる可能性がある。このような型変換には、単に値をそのまま使う、<a href="#expr.reinterpret.cast">reinterpret_cast</a>は使えない。
</p>

<p>
変換元のポインターの値がnullポインターの場合は、変換先の型のnullポインターになる。
</p>
</article>

<article>
<h1 id="conv.mem"><a href="#conv.mem">メンバーへのポインターの型変換（Pointer to member conversions）</a></h1>

<p>
nullポインター定数は、メンバーへのポインターにも変換できる。変換された結果の値を、nullメンバーポインター値（null member pointer value）という。
</p>

<pre>
struct C { int data ; } ;

int C::* ptr = nullptr ;
</pre>

<p>
nullメンバーポインター値は、他のメンバーへのポインターの値と比較できる。
</p>

<pre>
struct C { int data ; } ;

int C::* ptr1 = nullptr ;
int C::* ptr2 = &amp;C::data ;

bool b = ( ptr1 == ptr2 ) ; // false
</pre>
</article>

<article>
<h1 id="conv.bool"><a href="#conv.bool">boolの型変換（Boolean conversions）</a></h1>

<p>
整数、浮動小数点数、unscoped enum、ポインター、メンバーへのポインターは、boolに変換できる。ゼロ値、nullポインター値、nullメンバーポインター値は、falseに変換される。それ以外の値はすべて、trueに変換される。
</p>

<pre>
bool b1 = 0 ; // false
bool b2 = 1 ; // true
bool b3 = -1 ; // true

bool b4 = nullptr ; // false

int x = 0 ; 
bool b5 = &amp;x ; // true
</pre>
</article>


</article>

<article class="toplevel">
<h1 id="expr"><a href="#expr">式（Expressions）</a></h1>

<p class="editorial-note">
TODO: FDIS後のcore issue 1054. Lvalue-to-rvalue conversions in expression statementsに対応
</p>

<p>
式（expression）とは、演算子（operator）とオペランド（operand）を組み合わせたものである。オペランドとは、言わば、演算子を適用する引数である。式は、何らかの挙動をし、結果を返す。式の結果は、lvalueかxvalueかprvalueになる。
</p>

<pre>
// 演算子は+
// オペランドは1と2
1 + 2 ;
</pre>

<p>
組み込み型以外の型に対しては、演算子はオーバーロードされている可能性がある。その場合の挙動に付いては、オーバーロード関数次第である。
</p>

<p>
式を評価した際、結果が数学的に定義されていない場合や、型の表現できる範囲を超えた場合の挙動は、未定義である。数学的に定義されていない場合というのは、例えばゼロ除算がある。
</p>

<p>
多くの二項演算子は、数値型やenumをオペランドに取る。この時、二つのオペランドの型が、それぞれ違う場合、型変換が行われる。この型変換のルールは、以下のようになる。
</p>

<p>
オペランドにscoped enum型がある場合、変換は行われない。もう片方のオペランドが、同じ型でない場合は、エラーになるからだ。
</p>

<p>
片方のオペランドが浮動小数点数型の場合、もう片方のオペランドは、その浮動小数点数型に変換される。浮動小数点数型の間の優先順位は、long double &gt; double &gt; floatである。
</p>

<pre>
// オペランドは、long doubleとdouble
// long doubleに変換される
1.0l + 1.0 ;
1.0 + 1.0l ;

// オペランドは、doubleとint
// doubleに変換される
1.0 + 1 ;
1 + 1.0 ;
</pre>

<p>
オペランドが浮動小数点数型ではない場合。つまり、整数型か、unscoped enum型の場合、まず、両方のオペランドに対して、整数のプロモーションが適用される。つまり、int型より変換順位の低い型は、int型に変換される。オペランドがunsignedな整数型の場合は、unsigned intに変換される。その後、両方のオペランドのうち、変換順位が高い方の型に合わせられる。
</p>


<pre>
short s = 0 ;
auto type = s + s ;
</pre>

<p>
この場合、オペランドであるsは、両方とも、int型に変換される。その結果、両方のオペランドは同じ型になるので、結果の型はintになる。
</p>

<pre>
short s = 0 ;
long l = 0 ;
auto type2 = l + s ;
</pre>

<p>
この場合、sはまずint型に変換される。longとintでは、longの方が、変換順位が高いので、結果の型はlongになる。
</p>

<p>
この時、符号の違う整数型がオペランドになると、非常に複雑な変換が行われるが、本書では解説しない。
</p>

<article>
<h1 id="operator_priority"><a href="#operator_priority">優先順位と評価順序</a></h1>

<p>
TODO: 式の優先順位の評価順序の表は必要か。詳しく分かったところで何か実用上の意味はあるのか。
</p>

<p>
式には、優先順位と評価順序がある。
</p>

<p>
優先順位とは、ある式の中で、異なる式が複数使われた場合、どちらが先に評価されるのかという順位である。この優先順位は、人間にとって自然になるように設計されているので、通常、式の優先順位を気にする必要はない。
</p>

<pre>
// 1 + (2 * 3)
// operator *が優先される
1 + 2 * 3 ;

int x ;
// operator +が優先される
x = 1 + 1 ;
</pre>



<p>
評価順序とは、ある式の中で、優先順位の同じ式が複数使われた場合、どちらを先に評価するかという順序である。これは、式ごとに、「左から右（Left-To-Right）」、あるいは「右から左（Right-To-Left）」のどちらかになる。
</p>

<p>
たとえば、operator +は、「左から右」である。
</p>

<pre>
// (1 + 1) + 1 と同じ
1 + 1 + 1 ;
</pre>

<p>
一方、operator = は、「右から左」である。
</p>

<pre>
int x ; int y ;
// x = (y = 0) と同じ
x = y = 0 ;
</pre>

<p>
これも、人間にとって自然になるように設計されている。通常、気にする必要はない。
</p>
</article>

<article>
<h1 id="unevaluated_operand"><a href="#unevaluated_operand">未評価オペランド（unevaluated_operand）</a></h1>

<p>
<a href="#expr.typeid">typeid演算子</a>、<a href="#expr.sizeof">sizeof演算子</a>、<a href="#expr.unary.noexcept">noexcept演算子</a>、<a href="#dcl.type.simple">decltype型指定子</a>では、あるいは未評価オペランド（unevaluated_operand）というものが使われる。このオペランドは文字通り、評価されない式である。
</p>

<p>
オペランドの式は評価されないが、式を評価した結果の型は、通常の評価される式と何ら変わりない。
</p>

<pre>
int f()
{
    return 0 ;
}

int main()
{
    // int x ; と同等
    // 関数fは呼ばれない
    decltype( f() ) x ;
}
</pre>

<p>
この例では、オペランドの式の結果の型を、変数xとして宣言、定義している。関数呼び出しの結果の型は、関数の戻り値の型になるので、型はintである。ただし、式自体は評価されないので、実行時に関数が呼ばれることはない。つまり、標準出力にhelloと出力されることはない。
</p>

<p>
この未評価式は、評価されないということを除けば、通常の式と全く同じように扱われる。例えば、オーバーロード解決やテンプレートのインスタンス化なども、通常の式と同じように働く。
</p>

<pre>
// 関数の宣言だけでいい。定義は必要ない
double f(int) ;
int f(double) ;

int main()
{
    // double x ; と同等
    decltype( f(0) ) x ;
    // int y ; と同等
    decltype( f(0.0) ) y ;
}
</pre>

<p>
この例では、関数fは、宣言だけされていて、定義がない。しかし、これは全く問題がない。なぜならば、未評価式は評価されないので、関数fが呼ばれることはない。呼ばれることがなければ、定義も必要はない。
</p>
</article>


<article>
<h1 id="expr.prim"><a href="#expr.prim">一次式（Primary expressions）</a></h1>

<p>
一次式には、多くの細かな種類がある。例えば、リテラルや名前も一次式である。ここでは、一次式の中でも、特に重要なものを説明する。
</p>

<article>
<h1 id="member_access_operator"><a href="#member_access_operator">:: 演算子</a></h1>
<p>
:: 演算子は、ある名前のスコープを指定する演算子である。このため、非公式に「スコープ解決演算子」とも呼ばれている。しかし、公式の名前は、:: 演算子(operator ::)である。::に続く名前のスコープは、::の前に指定されたスコープになる。
</p>

<pre>
// スコープはグローバル
int x = 0;

// スコープはNS名前空間
namespace NS { int x = 0; }

// スコープはCクラス
struct C { static int x ; } ;
int C::x = 0 ;


int main()
{// スコープはmain()関数のブロック
    int x = 0 ;

    x ; // ブロック

    ::x ; // グローバル
    NS::x ; // NS名前空間
    C::x ; // クラス
}
</pre>

<p>
このように、::に続く名前のスコープを指定することができる。スコープが省略された場合は、グローバルスコープになる。
</p>

<p>
式の結果は、::に続く名前が、関数か変数の場合はlvalueに、それ以外はprvalueになる。
</p>
</article>

<article>
<h1 id="parenthesized_expression"><a href="#parenthesized_expression">括弧式（parenthesized expression）</a></h1>
<p>
括弧式とは、括弧である。これは、式を囲むことができる。括弧式の結果は、括弧の中の式とまったく同じになる。これは主に、ひとつの式の中で、評価する順序を指定するような場合に用いられる。あるいは、単にコードを分かりやすく、強調するために使っても構わない。
</p>

<pre>
(0) ; // 括弧式

// 1 + (2 * 3) = 1 + 6 = 7
1 + 2 * 3 ;
// 3 * 3 = 9
(1 + 2 ) * 3
</pre>

<p>
ほとんどの場合、括弧式の有無は、括弧の中の式の結果に影響を与えない。ただし、括弧式の有無によって意味が変わる場合もある。例えば、decltype指定子だ。
</p>
</article>

</article>

<article>
<h1 id="expr.prim.lambda"><a href="#expr.prim.lambda">ラムダ式（Lambda expressions）</a></h1>

<p>
ラムダ式（lambda expression）は、関数オブジェクトを簡単に記述するための式である。以下のような文法になる
</p>

<pre>
[ ラムダキャプチャー<sub>opt</sub> ] ( 仮引数 ) mutable<sub>opt</sub> 例外指定<sub>opt</sub> -&gt; 戻り値の型<sub>opt</sub>
</pre>

<article>
<h1 id="lambda_basics"><a href="#lambda_basics">ラムダ式の基本的な使い方</a></h1>

<p>
ラムダ式を、通常の関数のように使う方法を説明する。まず、lambda式の構造は、以下のようになっている。
</p>

<pre>
[/*ラムダキャプチャー*/] // lambda導入子
(/*仮引数リスト*/) // 省略可能
-&gt; void // 戻り値の型、省略可能
{} // 複合文
</pre>

<p>
これを、通常の関数定義と比較してみる。
</p>

<pre>
auto // 関数宣言
func // 関数名
() // 引数リスト
-&gt; void // 戻り値の型
{} // 関数の定義
</pre>

<p>
lambda式は、関数オブジェクトである。通常の関数のように、引数もあれば、戻り値もある。もちろん、通常の関数のように、何も引数に取らないこともできるし、戻り値を返さないこともできる。
</p>

<pre>
// 通常の関数
auto f() -&gt; void {}
// ラムダ式
[]() -&gt; void {} ;
</pre>

<p>
lambda式を評価した結果は、prvalueの一時オブジェクトになる。この一時オブジェクトを、クロージャーオブジェクト（closure object）と呼ぶ。クロージャーオブジェクトの型は、クロージャー型（closure type）である。クロージャー型はユニークで、名前がない。これは実装依存の型であり、ユーザーは具体的な型を知ることができない。このクロージャーオブジェクトは、関数オブジェクトと同じように振舞う。
</p>

<pre>
auto f = []() -&gt;void {} ;
</pre>

<p>
ラムダ式は関数オブジェクトなので、通常の関数と同じように、operator ()を適用することで呼び出すことができる。
</p>

<pre>
// 通常の関数
auto f() -&gt; void {}

int main()
{
    f() ; // 関数の呼び出し

    // ラムダ式
    auto g = []() -&gt; void {} ;
    g() ; // lambda式の呼び出し

    // ラムダ式を直接呼び出す
    []() -&gt; void {}() ;
}
</pre>

<p>
仮引数リストと、戻り値の型は、省略できる。従って、最小のlambda式は、以下の通りになる。
</p>

<pre>
[]{}
</pre>

<p>
仮引数リストを省略した場合は、引数を取らないということを意味する。戻り値の型を省略した場合は、lambda式の複合文の内容によって、戻り値の型が推測される。複合文が以下の形になっている場合、
</p>

<pre>
{ return 式 ; }
</pre>

<p>
戻り値の型は、式に lvalueからrvalueへの型変換、 配列からポインターへの型変換、関数からポインターへの型変換を適用した結果の型になる。
</p>

<p>
それ以外の場合は、void型になる。
</p>

<p>
注意しなければならないことは、戻り値の型を推測させるためには、複合文は必ず、{ return 式 ; }の形でなければならない。つまり、return文ひとつでなければならないということだ。return文以外に、複数の文がある場合、戻り値の型はvoidである。
</p>

<pre>
// エラー、戻り値の型はvoidだが、値を返している
[]
{
    int x = 0 ;
    return x ;
}() ;


// OK、戻り値の型を、明示的に指定している。
[] -&gt; int
{
    int x = 0 ;
    return x ;
}() ;
</pre>

<p>
いくつか例を挙げる。
</p>

<pre>
// 戻り値の型はint
auto type1 = []{ return 0 ; }() ;

// 戻り値の型はdouble
auto type2 = []{ return 0.0 ; }() ;

// 戻り値の型はvoid
[]{ }() ;
[]
{
    int x = 0 ;
    x = 1 ;
}() ;
</pre>

<p>
lambda式の引数は、通常の関数と同じように記述できる。
</p>

<pre>
int main()
{
    auto f = []( int a, float b ) { return a ; }
    f( 123, 3.14f ) ;
}
</pre>

<p>
複合文は、通常の関数の本体と同じように扱われる。
</p>

<pre>
int main()
{
    // 通常の関数と同じように文を書ける
    auto f =
        [] { 
            int x = 0 ;
            ++x ;
        }
    f() ;

    auto g = []
    {// もちろん、複数の文を書ける
        int x = 0 ;
        ++x ; ++x ; ++x ;
    } ;

    g() ;
}
</pre>

<p>
クロージャーオブジェクトは、変数として保持できる。
</p>

<pre>
#include &lt;functional&gt;

int main()
{
    // auto指定子を使う方法 
    auto f = []{} ;
    f() ;

    // std::functionを使う方法
    std::function&lt; void (void) &gt; g = []{} ;
    g() ;
}
</pre>

<p>
ラムダ式は、テンプレート引数にも渡せる。
</p>

<pre>
template &lt; typename Func &gt;
void f( Func func )
{
    func() ;// 関数オブジェクトを呼び出す
}

int main()
{
    f( []{ std::cout &lt;&lt; "hello" &lt;&lt; std::endl ; } ) ;
}
</pre>

<p>
ラムダ式の使い方の例を示す。例えば、std::vectorの全要素を、標準出力に出力したいとする。
</p>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Print
{
    void operator () ( int value ) const
    { std::cout &lt;&lt; value &lt;&lt; std::endl ; }
} ;

int main()
{
    std::vector&lt;int&gt; v = { 1, 2, 3, 4, 5 } ;
    std::for_each( v.begin(), v.end(), Print() ) ;  
}
</pre>

<p>
この例では、本質的にはたった一行のコードを書くのに、わざわざ関数オブジェクトを、どこか別の場所に定義しなければならない。ラムダ式を使えば、その場に書くことができる。
</p>

<pre>
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main()
{
    std::vector&lt;int&gt; v = { 1, 2, 3, 4, 5 } ;
    std::for_each( v.begin(), v.end(),
        [](int value){ std::cout &lt;&lt; value &lt;&lt; std::endl ; } ) ;  
}
</pre>

<article>
<h1 id="lambda_basics_capture"><a href="#lambda_basics_capture">変数のキャプチャー</a></h1>

<p>
関数内に関数を書くことができるのは、確かに手軽で便利だ。しかし、ラムダ式は、単にその場に関数を書くだけでは終わらない。ラムダ式は、関数のローカル変数をキャプチャーできる。
</p>

<pre>
#include &lt;iostream&gt;

template &lt; typename Func &gt;
void call ( Func func )
{
    func() ;// helloと表示する
}

int main()
{
    std::string str = "hello" ;
    // main関数のローカル変数xを、ラムダ式の中で使う
    auto f = [=]{ std::cout &lt;&lt; str &lt;&lt; std::endl ; } ;
    f() ;
    // もちろん、他の関数に渡せる。
    call( f ) ;
}
</pre>

<p>
このように、ラムダ式が定義されている関数のブロックスコープの中のローカル変数を、使うことができる。この機能を、変数のキャプチャーという。
</p>

<p>
この、ラムダ式で、定義されている場所のローカル変数を使えるというのは、一見、奇妙に思えるかもしれない。しかし実のところ、これは単なるシンタックスシュガーにすぎない。同じことは、従来の関数オブジェクトでも行える。詳しくは後述する。
</p>

<p>
もちろん、クロージャーオブジェクトがどのように実装されるかは、実装により異なる。しかし基本的に、ラムダ式は、このような関数オブジェクトへの、シンタックスシュガーに過ぎない。
</p>

<p>
[]の中身を、lambdaキャプチャーという。lambdaキャプチャーの中には、キャプチャーリストを記述できる。変数のキャプチャーをするには、キャプチャーリストに、どのようにキャプチャーをするかを指定しなければならない。変数のキャプチャーには、二種類ある。コピーでキャプチャーするか、リファレンスでキャプチャーするかの違いである。
</p>

<pre>
int main()
{
    int x = 0 ;

    // コピーキャプチャー
    [=] { x ; }
    // リファレンスキャプチャー
    [&amp;] { x ; }
}
</pre>

<p>
キャプチャーリストに=を記述すると、コピーキャプチャーになる。&amp;を記述すると、リファレンスキャプチャーになる。
</p>

<p>
コピーキャプチャーの場合、変数はクロージャーオブジェクトのデータメンバーとして、コピーされる。リファレンスキャプチャーの場合は、クロージャーオブジェクトに、変数への参照が保持される。
</p>

<p>
コピーキャプチャーの場合は、ラムダ式から、その変数を書き換えることができない。
</p>

<pre>
int main()
{
    int x = 0 ;

    [=]
    {// コピーキャプチャー
        int y = x ; // OK、読むことはできる
        x = 0 ; // エラー、書き換えることはできない
    } ;

    [&amp;]
    {// リファレンスキャプチャー
        int y = x ; // OK
        x = 0 ; // OK
    } ;
}
</pre>

<p>
これは、クロージャーオブジェクトのoperator()が、const指定されているためである。ラムダ式にmutableが指定されていた場合、operator()は、const指定されないので、書き換えることができる。
</p>

<pre>
int main()
{
    int x = 0 ;

    [=]() mutable
    {
        int y = x ; // OK
        x = 0 ; // OK
    } ;
}
</pre>

<p>
リファレンスキャプチャーの場合は、変数の寿命に気をつけなければならない。
</p>

<pre>
#include &lt;functional&gt;

int main()
{
    std::function&lt; void ( void ) &gt; f ;
    std::function&lt; void ( void ) &gt; g ;


    {
        int x = 0 ;
        f = [&amp;]{ x ; } ; // リファレンスキャプチャー
        g = [=]{ x ; } ; // コピーキャプチャー
    }

    f() ;// エラー、xの寿命は、すでに尽きている。

    g() ; // OK
}
</pre>

<p>
ローカル変数の寿命は、そのブロックスコープ内である。この例で、fを呼び出すときには、すでに、xの寿命は尽きているので、エラーになる。
</p>

<p>
ラムダ式がキャプチャーできるのは、ラムダ式が記述されている関数の、最も外側のブロックスコープ内である。
</p>

<pre>
int main()
{// 関数の最も外側のブロックスコープ
    int x ;
    {
        int y ;

        // xもyもキャプチャーできる。
        [=]{ x ; y ; } ;
    }
}
</pre>

<p>
関数の最も外側のブロックスコープ以外のスコープ、例えばグローバル変数などは、キャプチャーせずにアクセス出来る。
</p>

<pre>
// グローバルスコープの変数
int x = 0 ;

int main()
{
    // キャプチャーする必要はない
    []{ x ; } ;
}
</pre>


<p>
変数ごとに、キャプチャー方法を指定できる。
</p>

<pre>
int main()
{
    int a = 0 ;
    int b = 0 ;

    [ a, &amp;b ]{} ;
}
</pre>

<p>
変数のキャプチャー方法を、それぞれ指定する場合、キャプチャーリストの中に、変数名を記述する。その時、単に変数名だけを記述した場合、コピーキャプチャーになり、変数名の前に&amp;をつけた場合、リファレンスキャプチャーになる。
</p>

<p>
キャプチャーしたい変数がたくさんある場合、いちいち名前をすべて記述するのは面倒であるので、デフォルトのキャプチャー方法を指定できる。これをデフォルトキャプチャー（default capture）という。この時、デフォルトキャプチャーに続けて、個々の変数名のキャプチャー方法を指定できる。
</p>

<pre>
int main()
{
    int a = 0 ; int b = 0 ; int c = 0 ; int d = 0 ; 

    // デフォルトはコピーキャプチャー
    [=]{ a ; b ; c ; d ; } ;
    // デフォルトはリファレンスキャプチャー
    [&amp;]{ a ; b ; c ; d ; } ;

    // aのみリファレンスキャプチャー
    [=, &amp;a]{} ;

    // aのみコピーキャプチャー
    [&amp;, a]{} ;

    // a, bのみリファレンスキャプチャー
    [=, &amp;a, &amp;b]{} ;

    // デフォルトキャプチャーを使わない
    [a]{} ;
}
</pre>

<p>
このとき、デフォルトキャプチャーと同じキャプチャー方法を、個々のキャプチャーで指定することはできない。
</p>

<pre>
int main()
{
    int a = 0 ; int b = 0 ;

    // エラー、デフォルトキャプチャーと同じ
    [=, a]{} ;
    // OK
    [=, &amp;a]{} ;

    // エラー、デフォルトキャプチャーと同じ
    [&amp;, &amp;a]{} ;
    // OK
    [&amp;, a]{} ;
}
</pre>

<p>
キャプチャーリスト内で、同じ名前を複数書くことはできない。
</p>

<pre>
int main()
{
    int x = 0 ;
    // エラー
    [x, x]{} ;
}
</pre>

<p>
たとえ、キャプチャー方法が同じであったとしても、エラーになる。
</p>

<p>
デフォルトキャプチャーが指定されているラムダ式の関数の本体で、キャプチャーできる変数を使った場合、その変数は、暗黙的にキャプチャーされる。
</p>

<p>
変数のキャプチャーの具体的な使用例を示す。今、vectorの各要素の合計を求めるプログラムを書くとする。関数オブジェクトで実装をすると、以下のようになる。
</p>

<pre>
struct Sum
{
    int sum ;
    Sum() : sum(0) { }
    void operator ()( int value )
    { sum += value ; std::cout &lt;&lt; sum &lt;&lt; std::endl ; }
} ;

int main()
{
    std::vector&lt;int&gt; v = {1,2,3,4,5} ;
    Sum sum = std::for_each( v.begin(), v.end(), Sum() ) ;

    std::cout &lt;&lt; sum.sum &lt;&lt; std::endl ;
}
</pre>

<p>
これは、明らかに分かりにくい。sum += valueという短いコードのために、関数オブジェクトを定義しなければならないし、その取扱も面倒である。このため、多くのプログラマは、STLのアルゴリズムを使うより、自前のループを書きたがる。
</p>

<pre>
int main()
{
    std::vector&lt;int&gt; v = {1,2,3,4,5} ;
    int sum = 0 ;
    for ( auto iter = v.begin() ; iter != v.end() ; ++iter )
    {
        sum += *iter ;
    }

    std::cout &lt;&lt; sum &lt;&lt; std::endl ;
}
</pre>

<p>
しかし、ループを手書きするのは分かりにくいし、間違いの元である。ラムダ式のキャプチャーは、この問題を解決してくれる。
</p>

<pre>
int main()
{
    std::vector&lt;int&gt; v = {1,2,3,4,5} ;
    int sum = 0 ;
    std::for_each( v.begin(), v.end(),
        [&amp;]( int value ){ sum += value ; }
    ) ;

    std::cout &lt;&lt; sum &lt;&lt; std::endl ;
}
</pre>

<p>
これで、コードは分かりやすくなる。また、ループを手書きしないので、間違いも減る。
</p>
</article>
</article>

<article>
<h1 id="lambda_details"><a href="#lambda_details">ラムダ式の詳細</a></h1>

<article>
<h1 id="lambda_details_closure_object"><a href="#lambda_details_closure_object">クロージャーオブジェクト（closure object）</a></h1>
<p>
ラムダ式が評価された結果は、クロージャーオブジェクト（closure object）になる。これは、一種の関数オブジェクトで、その型は、ユニークで無名な実装依存のクラスであるとされている。この型は、非常に限定的にしか使えない。例えば、ラムダ式は、未評価式の中で使うことが出来ない。これは、decltypeやsizeofの中で使うことが出来ないということを意味する。
</p>

<pre>
using type = decltype([]{}) ; // エラー
sizeof([]{}) ; // エラー

// OK
auto f = []{} ;
</pre>

<p>
クロージャーオブジェクトがどのように実装されるかは、実装依存である。しかし、今、説明のために、実装の一例を示す。
</p>

<pre>
int main()
{
    int a = 0 ; int b = 0 ;
    auto f = [a, &amp;b](){ a ; b ; } ;
    f() ;
}
</pre>

<p>
例えば、このようなコードがあったとすると、例えば、以下のように実装できる。
</p>

<pre>
class Closure // 本来、ユーザー側から使える名前は存在しない
{
private :
    // aは値キャプチャ、bはリファレンスキャプチャー
    int a ; int &amp; b ;
public :    
    Closure(int &amp; a, int &amp; b )
        : a(a), b(b) { }

    // コピーコンストラクターが暗黙的に定義される
    Closure( Cllosure &amp; ) = default ;
    // ムーブコンストラクターが暗黙的に定義される可能性がある
    Closure( Cllosure &amp;&amp; ) = default ;

    // デフォルトコンストラクターはdelete定義される
    Closure() = delete ;
    // コピー代入演算子はdelete定義される
    Closure &amp; operator = ( Closure &amp; ) = delete ;
    
    

    inline void operator () ( void ) const
    { a ; b ; }
} ;

int main()
{
    int a = 0 ; int b = 0 ;
    auto f = Closure(a, b) ;
    f() ;
}
</pre>

<p>
クロージャーオブジェクトは、メンバー関数として、operator ()を持つ。これにより、関数呼び出しの演算子で、関数のように呼び出すことができる。キャプチャーした変数は、データメンバーとして持つ。このoperator ()は、inlineである。また、mutable指定されていない場合、const指定されている。これにより、値キャプチャーした変数は、書き換えることができない。mutableが指定されている場合、constではなくなるので、書き換えることができる。
</p>

<pre>
int main()
{
    int x = 0 ;
    // エラー
    [x]() { x = 0 ; } ;
    // OK
    [x]() mutable { x = 0 ;} ;
}
</pre>
</article>

<p>
ラムダ式の仮引数リストには、デフォルト引数を指定できない。
</p>

<pre>
// エラー
[](int x = 0){} ;
</pre>

<p>
ラムダ式は、例外指定できる。
</p>

<pre>
[]() noexcept {} ;
</pre>

<p>
ラムダ式に例外指定をすると、クロージャーオブジェクトのoperator ()に、同じ例外指定がなされたものと解釈される。
</p>

<p>
クロージャーオブジェクトには、コピーコンストラクターが暗黙的に定義される。ムーブコンストラクターは、可能な場合、暗黙的に定義される。デフォルトコンストラクターと、コピー代入演算子は、delete定義される。これはつまり、初期化はできるが、コピー代入はできないということを意味する。
</p>

<pre>
// 初期化はできる。
auto f = []{} ;

// OK fはラムダ式ではないので可能
using closure_type decltype(f) ;
// OK 初期化はできる
closure_type g = f ;

// エラー、デフォルトコンストラクターは存在しない
closure_type h ;
// エラー、コピー代入演算子は存在しない。
h = f ;
</pre>

<h1>関数ポインターへの変換</h1>
<p>
ラムダキャプチャーを使わないラムダ式のクロージャーオブジェクトは、同一の引数と戻り値の関数ポインターへの変換関数を持つ。
</p>

<pre>
void (*ptr1)(void) = []{} ;
auto (*ptr2)(int, int, int) -&gt; int = [](int a, int b, int c) -&gt; int { return a + b + c ; }

// 呼び出す。
ptr1() ; ptr2() ;
</pre>

<p>
ラムダキャプチャーを使っているクロージャーオブジェクトは、関数ポインターに変換できない。
</p>

<pre>
int main()
{
    int x = 0 ; 
    // エラー、変換できない
    auto (*ptr1)(void) -&gt; int = [=] -&gt; int{ return x ; } ;
    auto (*ptr2)(void) -&gt; int = [&amp;] -&gt; int{ return x ; } ;
}
</pre>

<p>
変数をキャプチャーしないラムダ式というのは、関数オブジェクトではなく、単なる関数に置き換えることができるので、このような機能が提供されている。この機能は、まだテンプレートを使っていない既存のコードやライブラリとの相互利用のために用意されている。
</p>

<h1>ラムダ式のネスト</h1>

<p>
ラムダ式はネストできる。
</p>

<pre>
[]{// 外側のラムダ式
    []{} ;// 内側のラムダ式
} ;
</pre>

<p>
この時、問題になるのは、変数のキャプチャーだ。内側のラムダ式は、外側のラムダ式のブロックスコープから見える変数しか、キャプチャーすることはできない。
</p>

<pre>
int main()
{
    int a = 0 ; int b = 0 ;
    [b]{// 外側のラムダ式
        int c = 0 ;
        [=]{// 内側のラムダ式
            a ; // エラー、aはキャプチャーできない。
            b ; // OK
            c ; // OK
        } ;
    } ;
}
</pre>

<p>
外側のラムダ式が、デフォルトキャプチャーによって、暗黙的に変数をキャプチャーしている場合は、内側のラムダも、その変数をキャプチャーできる。
</p>

<pre>
int main()
{
    int a = 0 ;
    [=]{// 外側のラムダ式
        [=]{// 内側のラムダ式
            a ; // OK
        } ;
    } ;
}
</pre>
</article>

<article>
<h1 id="capture_this"><a href="#capture_this">thisのキャプチャー</a></h1>
<p>
基本的にラムダ式は、そのラムダ式が使われているブロックスコープのローカル変数しかキャプチャーできない。しかし、実は、データメンバーを使うことができる。
</p>

<pre>
struct C
{
    int x ;
    void f()
    {
        [=]{ x ; } ;// OK、ただし、これはキャプチャーではないことに注意
    }
} ;
</pre>

<p>
このように、非staticなメンバー関数のラムダ式では、データメンバーを使うことができる。しかし、これは、データメンバーをキャプチャーしているわけではない。その証拠に、データメンバーを直接キャプチャーしようとすると、エラーになる。
</p>

<pre>
struct C
{
    int x ;
    void f()
    {
        [x]{} ; // エラー、データメンバーはキャプチャーできない
    }
} ;
</pre>

<p>
では、どうしてデータメンバーが使えるのか。一体何をキャプチャーしているのか。実は、これはthisをキャプチャーしているのである。ラムダ式は、thisをキャプチャーできる。
</p>

<pre>
struct C
{
    int x ;
    void f()
    {
        [this]{ this-&gt;x ; } ;
    }
} ;
</pre>

<p>
ラムダ式の関数の本体では、thisは、クロージャーオブジェクトへのポインターではなく、ラムダ式が使われている非staticなメンバー関数のthisをキャプチャーしたものと解釈される。thisは、必ずコピーキャプチャーされる。というのも、そもそもthisはポインターなので、リファレンスキャプチャーしても、あまり意味はない。
</p>

<pre>
struct C
{
    int x ;
    void f()
    {
        [this]{} ; // OK
        [&amp;this]{} ; // エラー、thisはリファレンスキャプチャーできない
    }
} ;
</pre>

<p>
ラムダ式にデフォルトキャプチャーが指定されていて、データメンバーが使われている場合、thisは暗黙的にキャプチャーされる。デフォルトキャプチャーがコピーでもリファレンスでも、thisは必ずコピーキャプチャーされる。
</p>

<pre>
struct C
{
    int x ;
    void f()
    {
        [=]{ x ; } ; // thisをコピーキャプチャーする
        [&amp;]{ x ; } ; // thisをコピーキャプチャーする
    }
} ;
</pre>

<p>
thisのキャプチャーは、注意を要する。すでに述べたように、データメンバーは、キャプチャーできない。ラムダ式でデータメンバーを使うということは、thisをキャプチャーするということである。データメンバーは、thisを通して使われる。これは、データメンバーは参照で使われるということを意味する。ということは、もし、クロージャーオブジェクトのoperator ()が呼ばれた際に、thisを指し示すオブジェクトが無効になっていた場合、エラーとなってしまう。
</p>

<pre>
struct C
{
    int x ;
    std::function&lt; int (void) &gt; f()
    {
        return [this]{ return x ; } ;
    }
} ;

int main()
{
    std::function&lt; int (void) &gt; f ;
    {
        C c ;
        f = c.f() ;
    }// cの寿命はすでに終わっている

    f() ;// エラー
}
</pre>

<p>
データメンバーをコピーキャプチャーする方法はない。そもそも、何度も述べているように、データメンバーはキャプチャーできない。では、上の例で、どうしてもデータメンバーの値を使いたい場合はどうすればいいのか。この場合、一度ローカル変数にコピーするという方法がある。
</p>

<pre>
struct C
{
    int x ;
    std::function&lt; int (void) &gt; f()
    {
        int x = this-&gt;x ;
        return [x]{ return x ; } ;// xはローカル変数のコピー
    }
} ;
</pre>

<p>
もちろん、同じ名前にするのが紛らわしければ、名前を変えてもいい。
</p>

<p>
ラムダ式でデータメンバーを使う際には、キャプチャーしているのは、実はthisなのだということに注意しなければならない。
</p>
</article>

<article>
<h1 id="capture_parameter_pack"><a href="#capture_parameter_pack">パラメーターパックのキャプチャー</a></h1>

<p>
可変引数テンプレートの関数パラメーターパックも、キャプチャーリストに書くことができる。その場合、通常と同じように、パック展開になる。
</p>

<pre>
template &lt; typename ... Types &gt; void g( Types ... args ) ;

template &lt; typename ... Types &gt;
void f( Types ... args )
{
    // 明示的なキャプチャー
    [args...]{ g( args... ) ; } ;
    [&amp;args...]{ g( args... ) ; } ;

    // 暗黙的なキャプチャー
    [=]{ g( args... ) ; } ;
    [&amp;]{ g( args... ) ; } ;   
}
</pre>
</article>
</article>

<article>
<h1 id="expr.post"><a href="#expr.post">後置式（Postfix expressions）</a></h1>

<p>
後置式は、主にオペランドの後ろに演算子を書くことから、そう呼ばれている。後置式の評価順序はすべて、「左から右」である。
</p>

<article>
<h1 id="expr.sub"><a href="#expr.sub">添字（Subscripting）</a></h1>

<pre>
式 [ 式 ]
式 [ 初期化リスト ]
</pre>
<p>
operator []は、添字と呼ばれる式である。これは、配列の要素にアクセスするために用いられる。どちらか片方の式は、Tへのポインター型でなければならず、もう片方は、unscoped enumか、整数型でなければならない。式の結果は、lvalueのTとなる。式、E1[E2] は、*((E1)+(E2)) と書くのに等しい
</p>

<pre>
int x[3] ;
// *(x + 1)と同じ
x[1] ;
</pre>

<p>
この場合、xには、<a href="#conv.array">配列からポインターへの型変換</a>が適用されている。
</p>

<p>
「どちらか片方の式」というのは、文字通り、どちらか片方である。たとえば、x[1]とすべきところを、1[x]としても、同じ意味になる。
</p>

<pre>
int x[3] ;
// どちらも同じ意味。
x[1] ;
1[x] ;
</pre>

<p>
もっとも、通常は、一つめの式をポインター型にして、二つ目の式を整数型にする。ユーザー定義のoperator []では、このようなことはできない。
</p>

<p>
ユーザー定義のoperator []の場合、[]の中の式に、初期化リストを渡すことができる。これは、どのように使ってもいいいが、例えば以下のように使える。
</p>

<pre>
struct C
{
    int data[10][10][10] ;
    int &amp; operator []( std::initializer_list&lt;std::size_t&gt; list )
    {
        if ( list.size() != 3 ){/* エラー処理 */}

        auto iter = list.begin() ;
        std::size_t const i = *iter ; ++iter ;
        std::size_t const j = *iter ; ++iter ;
        std::size_t const k = *iter ;
        
        return data[i][j][k] ;
    }
} ;

int main()
{
    C c ;
    c[{1, 2, 3}] = 0 ;
}
</pre>

<p>
初期化リストを使えば、オーバーロードされたoperator []に、複数の引数を渡すことができる。
</p>
</article>

<article>
<h1 id="expr.call"><a href="#expr.call">関数呼び出し（Function call）</a></h1>

<p>
関数呼び出し（function call）の文法は、以下の通り。
</p>

<pre>
式 ( 引数のリスト )
</pre>

<p>
関数呼び出しには、通常の関数呼び出しと、メンバー関数呼び出しがある。
</p>

<p>
通常の関数を呼び出す場合、式には、関数へのlvalueか、関数へのポインターが使える。
</p>

<pre>
void f( void ) { } 
void g( int ) { } 
void h( int, int, int ) { } 

int main()
{
    // 「関数へのlvalue」への関数呼び出し
    f( ) ;
    g( 0 ) ;
    h( 0, 0, 0 ) ;

    // 関数への参照
    void (&amp;ref)(void) = f ;

    // 「関数へのlvalue」への関数呼び出し
    ref() ;

    // 関数ポインター
    void (*ptr)(void) = &amp;f ;

    // 関数ポインターへの関数呼び出し
    ptr() ;
}
</pre>

<p>
staticなメンバー関数は、通常の関数呼び出しになる。
</p>

<pre>
struct C { static void f(void) {} } ;

int main()
{
    void (*ptr)(void) = &amp;C::f ;
    ptr() ; // 通常の関数呼び出し
}
</pre>

<p>
メンバー関数を呼び出す場合、式には、関数のメンバーの名前か、メンバー関数へのポインター式が使える。
</p>

<pre>
struct C
{
    void f(void) {}

    void g(void)
    {
        // メンバー関数の呼び出し
        f() ;
        this-&gt;f() ; 
        (*this).f() ;

        // メンバー関数へのポインター
        void (C::* ptr)(void) = &amp;C::f ;
        // 関数呼び出し
        (this-&gt;*ptr)() ;
    }
} ;
</pre>

<p>
関数呼び出し式の結果の型は、式で呼び出した関数の戻り値の型になる。
</p>

<pre>
void f() ;
int g() ;

// 式の結果の型はvoid
f() ;
// 式の結果の型はint
g() ;
</pre>

<p>
関数呼び出しの結果の型は、戻り値の型になる。これはtypeidやsizeofやdecltypeのオペランドの中でも、同様である。
</p>

<pre>
// 関数fの戻り値の型はint
// すなわち、fを関数呼び出しした結果の型はint
int f() { return 0 ; }

int main()
{
    // sizeof(int)と同じ
    sizeof( f() ) ;
    // typeid(int)と同じ
    typeid( f() ) ;
    // int型の変数xの宣言と定義。
    decltype( f() ) x ;
}
</pre>

<p>
関数が呼ばれた際、仮引数は対応する実引数で初期化される。非staticメンバー関数の場合、this仮引数もメンバー関数を呼び出した際のオブジェクトへのポインターで初期化される。
</p>

<p>
仮引数に対して、具体的な一時オブジェクトが生成されるかどうかは、実装依存である。たとえば、実装は最適化のために、一時オブジェクトの生成を省略するかもしれない。
</p>

<p>
仮引数が参照の場合をのぞいて、呼ばれた関数の中で仮引数を変更しても、実引数は変更されない。ただし、型がポインターの場合、参照を通して参照先のオブジェクトが変更される可能性がある。
</p>

<pre>
void f( int x, int &amp; ref, int * ptr )
{
    x = 1 ; // 実引数は変更されない
    ref = 1 ; // 実引数が変更される
    *ptr = 1 ; // 実引数は、ポインターの参照を通して変更される
    ptr = nullptr ; // 実引数のポインターは変更されない
}

int main()
{
    int x = 0 ;// 実引数
    int * ptr = &amp;x ;
    f( x, x, ptr ) ;
}
</pre>

<p>
実引数の式が、どのような順番で評価されるかは決められていない。ただし、呼び出された関数の本体に入る際には、式はすべて評価されている。
</p>

<pre>
#include &lt;iostream&gt;
 
int f1(){ std::cout &lt;&lt; "f1" &lt;&lt; std::endl ; return 0 ; }
int f2(){ std::cout &lt;&lt; "f2" &lt;&lt; std::endl ; return 0 ; }
int f3(){ std::cout &lt;&lt; "f3" &lt;&lt; std::endl ; return 0 ; }

void g( int, int, int ){ }

int main( )
{
    g( f1(), f2(), f3() ) ;// f1, f2, f3関数呼び出しの順番は分からない
}
</pre>

<p>
この例では、関数f1, f2, f3がどの順番で呼ばれるのかが分からない。したがって、標準出力にどのような順番で文字列が出力されるかも分からない。ただし、関数gの本体に入る際には、f1, f2, f3は、すべて呼び出されている。
</p>

<p>
関数は、自分自身を呼び出すことができる。これを再帰呼び出しという。
</p>

<pre>
void f()
{
    f() ; // 自分自身を呼び出す、無限ループ
}
</pre>

<p>
ただし、main関数だけは特別で、再帰呼び出しをすることができない。
</p>

<pre>
int main()
{
    main() ; // エラー
}
</pre>
</article>

<article>
<h1 id="expr.type.conv"><a href="#expr.type.conv">関数形式の明示的型変換（Explicit type conversion (functional notation)）</a></h1>

<pre>
型名 ( 式リスト )
型名 初期化リスト
</pre>

<p>
関数形式の明示的型変換（Explicit type conversion (functional notation)）とは、関数呼び出しのような文法による、一種のキャストである。
</p>

<pre>
struct S
{
    S( int ) { }
    S( int, int ) { }
} ;

int main()
{
    int() ;
    int{} ;

    S( 0 ) ;
    S( 1, 2 ) ;
}
</pre>

<p>
型名として使えるのは、<a href="#dcl.type.simple">Simple型指定子</a>か、typename指定子である。Simple型指定子でなければならないということには、注意しなければならない。たとえば、ポインターやリファレンス、配列などを直接書くことはできない。ただし、typedef名は使える。
</p>

<pre>
int x = 0 ;
// これらはエラー
int *(&amp;x) ;
int &amp;(x) ;

// typedef名は使える
using type = int * ;
type(&amp;x) ;
</pre>

<p>
Simple型指定子の中でも、autoとdecltypeは、注意が必要である。まず、autoは使えない。
</p>

<pre>
auto(0) ; // エラー
</pre>

<p>
decltypeは使える。ただし、非常に使いづらいので、使うべきではない。
</p>

<pre>
// int型をint型にキャスト
// int(0) と同じ
decltype(0)(0) ;
</pre>

<p>
たとえば、以下のコードはエラーである。
</p>

<pre>
int x ;
decltype(x)(x) ;// エラー
</pre>

<p>
これは、文法が曖昧だからだ。詳しくは、<a href="#stmt.ambig">曖昧解決</a>を参照。何が起こっているかというと、decltype(x)(x)は、キャストではなく、変数の宣言だとみなされている。decltype(x)は、intという型である。
</p>

<pre>
// decltype(x)(x) と同じ
// decltype(x)(x) → int (x) → int x
int x ;
</pre>

<p>
このため、decltypeを関数形式のキャストで使うのは、問題が多い。使うならば、typedef名をつけてから使うか、static_castを使うべきである。
</p>

<pre>
int x ;
using type = decltype(x) ;
type(x) ;

static_cast&lt; decltype(x) &gt;(x) ;
</pre>

<p>
typename指定子も使うことができる。
</p>

<pre>
teplate &lt; typename T &gt;
void f()
{
    typename T::type() ; // OK
}
</pre>

<p>
式リストが、たったひとつの式である場合、<a href="#expr.cast">キャスト</a>と同じ意味になる。
</p>

<pre>
// int型からshort型へのキャスト
short(0) ;
// int型からdouble型へのキャスト
double(0) ;

struct C { C(int) {} } ;
// 変換関数による、int型からC型へのキャスト
C(0) ; 
</pre>

<p>
型名がクラス名である場合、T(x1, x2, x3)という形の式は、T t(x1, x2, x3)という形と同じ意味を持つ一時オブジェクトを生成し、その一時オブジェクトを、prvalueの結果として返す。型名がクラス名でも、式リストがひとつしかない場合は、キャストである。もっとも、その場合も、ユーザー定義のコンストラクターが、変換関数として呼び出されることになるので、意味はあまり変わらない。
</p>

<pre>
struct C
{
    C(int) {}
    C(int, int) {}
    C(int, int, int) {}
} ;

int main()
{
    C(0) ; // これはキャスト、意味としては、あまり違いはない
    C(1, 2) ; 
    C(1, 2, 3) ;
}
</pre>

<p>
式リストが空の場合、つまり、T()という形の式の場合。まず、Tは配列型であってはならない。Tは完全な型か、void（でなければならない。式の結果は、値初期化された型のprvalueの値になる。値初期化については、<a href="#dcl.init">初期化子</a>を参照。
</p>

<pre>
int() ; // int型の0で初期化された値
double() : // double型の0で初期化された値

struct C {} ;
C() ;// デフォルトコンストラクターが呼ばれたCの値
</pre>

<p>
void型の場合、値初期化はされない。式の結果の型はvoidである。
</p>

<pre>
void() ; // 結果はvoid
</pre>

<p>
括弧で囲まれた式リストではなく、初期化リストの場合、式の結果は、指定された型の、初期化リストによって直接リスト初期化されたprvalueの一時オブジェクトになる。
</p>

<pre>
#include &lt;initializer_list&gt;

struct C
{
    C( std::initializer_list&lt;int&gt; ) { }
} ;

int main()
{
    C{1,2,3} ;
}
</pre>
</article>

<article>
<h1 id="expr.pseudo"><a href="#expr.pseudo">疑似デストラクター呼び出し（Pseudo destructor call）</a></h1>

<p>
擬似デストラクター呼び出しとは、デストラクターを明示的に呼び出すことができる式である。使い方は、operator .、operator -&gt;に続けて、疑似デストラクター名を書き、さらに関数呼び出しのoperator ()を書く。式の結果はvoidになる。
</p>

<pre>
// このコードは、疑似デストラクター呼び出しの文法を示すためだけの例である
struct C {} ;

int main()
{
    C c ;
    c.~C() ; // 擬似デストラクター呼び出し
    C * ptr = &amp;c
    ptr->~C() ;// 擬似デストラクター呼び出し
}
</pre>

<p>
注意すべきことは、デストラクターを明示的に呼び出したとしても、暗黙的に呼び出されるデストラクターは、依然として呼び出されるということである。
</p>

<pre>
#include &lt;iostream&gt;

struct C
{
    ~C() { std::cout &lt;&lt; "destructed." &lt;&lt; std::endl ; }
} ;

int main()
{
    {
        C c ;
        c.~C() ;// デストラクターを呼び出す
    }// ブロックスコープの終りでも、デストラクターは暗黙的に呼ばれる

    C * ptr = new C ;
    ptr-&gt;~C() ;// デストラクターを呼び出す

    delete ptr ;// デストラクターが暗黙的に呼ばれる。
}
</pre>

<p>
このように、通常は、デストラクターの呼び出しが重複してしまう。二重にデストラクターを呼び出すのは、大抵の場合、プログラム上のエラーである。では、疑似デストラクター呼び出しは何のためにあるのか。具体的な用途としては、placement newと組み合わせて使うということがある。
</p>

<pre>
struct C { } ;

int main()
{
    // placement new用のストレージを確保
    void * storage = operator new( sizeof(C) ) ;
    // placement new
    C * ptr =  new(storage) C ;
    // デストラクターを呼び出す
    ptr-&gt;~C() ;
    // placement new用のストレージを解放
    operator delete( storage ) ;
}
</pre>

<p>
この疑似デストラクターには、decltypeを使うことができる。
</p>

<pre>
struct C {} ;

int main()
{
    C c ;
    c.~decltype(c) ; 
    C * ptr = &amp;c
    ptr->~decltype(c) ;
}
</pre>

<p>
テンプレート引数の場合、型がスカラー型であっても、疑似デストラクター呼び出しができる
</p>

<pre>
template &lt; typename T &gt;
void f()
{
    T t ;
    t.~T() ;
}

int main()
{
    f&lt;int&gt;() ;
}
</pre>

<p>
これにより、ジェネリックなテンプレートコードが書きやすくなる。
</p>
</article>

<article>
<h1 id="expr.ref"><a href="#expr.ref">クラスメンバーアクセス（Class member access）</a></h1>

<p>
TODO: 詳細なvalue categoryを説明するかどうか。
</p>

<pre>
クラスのlvalue . メンバー名
クラスのポインター -&gt; メンバー名
</pre>

<p>
クラスメンバーアクセスは、名前の通り、クラスのオブジェクトか、クラスのオブジェクトへのポインターのメンバーにアクセスするための演算子である。
</p>

<p>
. 演算子の左側の式は、クラスのオブジェクトでなければならない。-&gt; 演算子の左側の式は、クラスのオブジェクトへのポインターでなければならない。演算子の右側は、そのクラスか、基本クラスのメンバー名でなければならない。-&gt; 演算子を使った式、E1-&gt;E2は、(*(E1)).E2という式とおなじになる。
</p>

<pre>
struct Object
{
    int x ;
    static int y ;
    void f() {}
} ;

int Object::y ;

int main()
{
    Object obj ;
    // . 演算子
    obj.x = 0 ;
    obj.y = 0 ;
    obj.f() ;

    Object * ptr = &amp;obj ;
    // -&gt; 演算子
    ptr-&gt;x = 0 ;
    ptr-&gt;y = 0 ;
    ptr-&gt;f() ;
}
</pre>

<p>
もし、クラスのオブジェクト、クラスのオブジェクトへのポインターを表す式が依存式であり、メンバー名がメンバーテンプレートであり、テンプレート引数を明示的に指定したい場合、メンバー名の前に、templateキーワードを使わなければならない。
</p>

<pre>
struct Object
{
    template &lt; typename T &gt;
    void f() {}
} ;

template &lt; typename T &gt;
void f()
{
    T obj ;
    obj.f&lt;int&gt;() ; // エラー
    obj.template f&lt;int&gt;() ; // OK
}

int main()
{
    f&lt;Object&gt;() ;
}
</pre>

<p>
これは、&lt;演算子や、&gt;演算子と、文法が曖昧になるためである。この問題については、<a href="#temp.names">テンプレート特殊化の名前</a>でも、解説している。
</p>

<p>
派生によって、クラスのメンバー名が曖昧な場合、エラーになる。
</p>

<pre>
struct Base1 { int x ; } ;
struct Base2 { int x ; } ;

struct Derived : Base1, Base2
{ } ;

int main()
{
    Derived d ;

    d.x ; // エラー    
    d.Base1::x ;// OK
    d.Base2::x ;// OK
}
</pre>

<p>
TODO: value categoryについて。むしろlvalue and rvalueのところで説明すべきか
</p>
</article>

<article>
<h1 id="expr.post.incr"><a href="#expr.post.incr">インクリメントとデクリメント（Increment and decrement）</a></h1>

<p>
ここでは、後置式のインクリメントとデクリメントについて解説する。前置式のインクリメントとデクリメントについては、<a href="#expr.pre.incr">単項式のインクリメントとデクリメント</a>を参照。
</p>

<pre>
式 ++
式 --
</pre>

<p>
後置式の++演算子の式の結果は、オペランドの式の値になる。オペランドは、変更可能なlvalueでなければならない。オペランドの型は、数値型か、ポインター型でなければならない。式が評価されると、オペランドに1を加算する。ただし、式の結果は、オペランドに1を加算する前の値である。
</p>

<pre>
int x = 0 ;
int result = x++ ;

// ここで、result == 0, x == 1
</pre>

<p>
式の結果の値は、オペランドの値と変わりがないが、オペランドには、1を加算されるということに注意しなければならない。
</p>

<p>
後置式の--演算子は、オペランドから1を減算する。それ以外は、++演算子と全く同じように動く。
</p>

<pre>
int x = 0 ;
int result = x-- ;

// ここで、result == 0, x == -1
</pre>
</article>

<article>
<h1 id="expr.dynamic.cast"><a href="#expr.dynamic.cast">Dynamic cast（Dynamic cast）</a></h1>

<pre>
dynamic_cast &lt; 型名 &gt; ( 式 )
</pre>

<p>
dynamic_cast&lt;T&gt;(v)という式は、vという式をTという型に変換する。便宜上、vwをdynamic_castのオペランド、Tをdynamic_castの変換先の型とする。変換先の型はクラスへのポインターかリファレンス、あるいは、voidへのポインター型でなければならない。オペランドは、変換先の型が、ポインターの場合はポインター、リファレンスの場合はリファレンスでなければならない。
</p>

<pre>
struct C {} ;

int main()
{
    C c ;

    // 変換先の型がポインターの場合は、オペランドもポインター
    // 変換先の型がリファレンスの場合は、オペランドもリファレンスでなければならない
    dynamic_cast&lt;C &amp;&gt;(c) ; // OK
    dynamic_cast&lt;C *&gt;(&amp;c) ; // OK

    // ポインターかリファレンスかが、一致していない
    dynamic_cast&lt;C *&gt;(c) ; // エラー
    dynamic_cast&lt;C &amp;&gt;(&amp;c) ; // エラー 
}
</pre>

<section>
<h1 id="dynamic_cast_feature"><a href="#dynamic_cast_feature">dynamic_castの機能</a></h1>

<p>
今、Derivedクラスが、Baseクラスから派生されていたとする。
</p>

<pre>
struct Base {} ;
struct Derived : Base {} ;
</pre>

<p>
この時、static_castを使えば、Baseへのポインターやリファレンスから、Derivedへのポインターやリファレンスに変換することができる。
</p>

<pre>
int main()
{
    Derived d ;

    Base &amp; base_ref = d ;
    Derived &amp; derived_ref = static_cast&lt;Derived &amp;&gt;(base_ref) ;

    Base * base_ptr = &amp;d ;
    Derived * derived_ptr = static_cast&lt;Derived *&gt;(base_ptr) ;
}
</pre>

<p>
この例では、ポインターやリファレンスが指す、本当のオブジェクトは、Derivedクラスのオブジェクトだということが分かりきっているので安全である。しかし、ポインターやリファレンスを使う場合、常にオブジェクトの本当のクラス型が分かるわけではない。
</p>

<pre>
void f( Base &amp; base )
{
    // baseがDerivedを参照しているかどうかは、分からない。
    Derived &amp; d = static_cast&lt;Derived &amp;&gt;(base) ;
}

int main()
{
    Derived derived ;
    f(derived) ; // ok

    Base base ;
    f(base) ; // エラー
}
</pre>

<p>
このように、ポインターやリファレンスの指し示すオブジェクトの本当のクラス型は、実行時にしか分からない。しかし、オブジェクトの型によって、特別な処理をしたいことも、よくある。
</p>

<pre>
void f( Base &amp; base )
{
    if ( /* baseの指すオブジェクトがDerivedクラスの場合*/ )
    {
        // 特別な処理
    }

    // 共通の処理
}
</pre>

<p>
本来、このような処理は、virtual関数で行うべきである。しかし、現実には、どうしても、このような泥臭くて汚いコードを書かなければならない場合もある。そのようなどうしようもない場合のために、C++には、基本クラスへのポインターやリファレンスが、実は派生クラスをオブジェクトを参照している場合に限り、キャストできるという機能が提供されている。それが、dynamic_castである。
</p>
</section>

<p>
動的な型チェックを使うためには、dynamic_castのオペランドのクラスは、ポリモーフィック型でなければならない。つまり、すくなくともひとつのvirtual関数を持っていなければならない。ポリモーフィック型の詳しい定義については、<a href="#class.virtual">virtual関数</a>を参照。
</p>

<p>
もし、オペランドの参照するオブジェクトが、変換先の型として指定されている派生クラスのオブジェクトであった場合、変換することができる。
</p>

<pre>
struct Base { virtual void f() {} } ;
struct Derived : Base {} ;

void f(Base &amp; base)
{// baseはDerivedを指しているとする
    Derived &amp; ref = dynamic_cast&lt;Derived &amp;&gt;(base) ;
    Derived * ptr = dynamic_csat&lt;Derived *&gt;(&amp;base) ;
}
</pre>

<p>
実引数に、変換先の型ではないオブジェクトを渡した場合、dynamic_castの変換は失敗する。変換が失敗した場合、変換先の型がリファレンスの場合、std::bad_castがthrowされる。変換先の型がポインターの場合、nullポインターが返される。
</p>

<pre>
struct Base { virtual void f() {} } ;
struct Derived : Base {} ;

int main()
{
    Base base ;

    // リファレンスの場合
    try {
        Derived &amp; ref = dynamic_cast&lt;Derived &amp;&gt;(base) ;
    } catch ( std::bad_cast )
    {
        // 変換失敗
        // リファレンスの場合、std::bad_castがthrowされる
    }

    // ポインターの場合
    Derived * ptr = dynamic_cast&lt;Derived *&gt;(&amp;base) ;

    if ( ptr == nullptr )
    {
        // 変換失敗
        // ポインターの場合、nullポインターが返される
    }
}
</pre>

<p>
基本クラスのポインターやリファレンスが、実際は何を指しているかは、実行時にしか分からない。そのため、常に変換に失敗する可能性がある。そのため、dynamic_castを使う場合は、常に変換が失敗するかもしれないという前提のもとに、コードを書かなければならない。
</p>

<p>
失敗せずに変換できる場合というのは、オペランドの指すオブジェクトの本当の型が、変換先の型のオブジェクトである場合で、しかもアクセスできる場合である。オブジェクトである（is a）場合というのは、例えば、
</p>

<pre>
struct A { virtual void f(){} } ;
struct B : A {} ;
struct C : B {} ;
struct D : C {} ;
</pre>

<p>
このようなクラスがあった場合、Dは、Cであり、Bであり、Aである。従って、Dのオブジェクトを、Aへのリファレンスで保持していた場合、D、C、Bのいずれにも変換できる。
</p>

<pre>
int main()
{
    D d ;
    A &amp; ref = d ;

    // OK
    // refの指しているオブジェクトは、Dなので、変換できる。
    dynamic_cast&lt;D &amp;&gt;(ref) ;
    dynamic_cast&lt;C &amp;&gt;(ref) ;
    dynamic_cast&lt;B &amp;&gt;(ref) ;    
}
</pre>

<p>
アクセスできる場合というのは、変換先の型から、publicで派生している場合である。
</p>

<pre>
struct Base1 { virtual void f(){} } ;
struct Base2 { virtual void g(){} } ;
struct Base3 { virtual void h(){} } ;

struct Derived
    : public Base1,
      public Base2,
      private Base3
{ } ;

int main()
{
    Derived d ;
    Base1 &amp; ref = d ;

    // OK、Base2はpublicなので、アクセス出来る
    dynamic_cast&lt;Base2 &amp;&gt;(ref) ;
    // 実行時エラー、Base3はprivateなので、アクセス出来ない
    // std::bad_castがthrowされる。
    dynamic_cast&lt;Base3 &amp;&gt;(ref) ;
}
</pre>

<p>
この例の場合、refが参照するオブジェクトは、Derived型であるので、Base3型のサブオブジェクトも持っているが、Base3からは、privateで派生されているために、アクセスすることはできない。そのため、変換することが出来ず、std::bad_castがthrowされる。
</p>

<p>
変換先の型は、void型へのポインターとすることもできる。その場合、オペランドの指す本当のオブジェクトの、もっとも派生されたクラスを指すポインターが、voidへのポインター型として、返される。
</p>

<pre>
struct Base { virtual void f(){} } ;
struct Derived1 : Base {} ;
struct Derived2 : Derived1 {} ;

int main()
{
    Derived1 d1 ;
    Base * d1_ptr = &amp;d1 ;

    // Derived1を指すポインターの値が、void *として返される
    void * void_ptr1 = dynamic_cast&lt;void *&gt;(d1_ptr) ;

    Derived1 d2 ;
    Base * d2_ptr = &amp;d2;

    // Derived2を指すポインターの値が、void *として返される
    void * void_ptr2 = dynamic_cast&lt;void *&gt;(d2_ptr) ;
}
</pre>

<p>
一般に、この機能はあまり使われることがないだろう。
</p>

<section>
<h1 id="dynamic_cast_other"><a href="#dynamic_cast_other">dynamic_castのその他の機能</a></h1>

<p>
dynamic_castは、その主目的の機能の他にも、クラスへのポインターやリファレンスに限って、キャストを行うことができる。この機能は、<a href="#conv.ptr">標準型変換のポインターの型変換</a>に、ほぼ似ている。このキャストは、static_castでも行える。以下の機能に関しては、実行時のコストは発生しない。
</p>

<p>
オペランドの型が、変換先の型と同じ場合、式の結果の型は、変換先の型になる。この時、constとvolatileを付け加えることはできるが、消し去ることは出来ない。
</p>

<pre>
// 型と式が同じ場合の例
struct C { } ;

int main()
{
    C v ;

    dynamic_cast&lt;C &amp;&gt;(v) ;
    dynamic_cast&lt;C const &amp;&gt;(v) ; // constを付け加える

    C const cv ;
    dynamic_cast&lt;C &amp;&gt;(cv) ;// エラー、constを消し去ることは出来ない

    // ポインターの場合 
    C * ptr = &amp;v ;
    dynamic_cast&lt;C *&gt;(ptr) ;   
    dynamic_cast&lt;C const *&gt;(ptr) ;
}
</pre>

<p>
変換先の型が基本クラスへのリファレンスで、オペランドの型が、派生クラスへのリファレンスの場合、dynamic_castの結果は、派生クラスのうちの基本クラスを指すリファレンスになる。ポインターの場合も、同様である。
</p>

<pre>
struct Base {} ; // 基本クラス
struct Derived : Base {} ; // 派生クラス

int main()
{
    Derived d ;

    Base &amp; base_ref = dynamic_cast&lt;Base &amp;&gt;(d) ;
    Base * base_ptr = dynamic_cast&lt;Base *&gt;(&amp;d) ;
}
</pre>
</section>

</article>

<article>
<h1 id="expr.typeid"><a href="#expr.typeid">型識別（Type identification）</a></h1>

<pre>
typeid ( 式 )
typeid ( 型名 )
</pre>

<p>
typeidとは、式や型名の、型情報を得るための式である。型情報は、const std::type_infoのリファレンスという形で返される。std::type_infoについての詳細は、<a href="#support.rtti">RTTI（Run Time Type Information）</a>を参照。typeidを使うには、必ず、&lt;typeinfo&gt;ヘッダーを#includeしなければならない。ただし、本書のサンプルコードは、紙面の都合上、必要なヘッダーのincludeを省略していることがある。
</p>

<p>
typeidのオペランドは、sizeofに似ていて、式と型名の両方を取ることができる。
</p>

<pre>
#include &lt;typeinfo&gt;

int main()
{
    // 型名の例
    typeid(int) ;
    typeid( int * ) ;

    // 式の例
    int x = 0 ;
    typeid(x) ; 
    typeid(&amp;x) ;
    typeid( x + x ) ;

}
</pre>

<p>
typeidのオペランドの式が、ポリモーフィッククラス型のglvalueであった場合、実行時チェックが働き、結果のstd::type_infoが表す型情報は、実行時に決定される。型情報は、オブジェクトの最も派生したクラスの型となる。
</p>

<pre>
struct Base { virtual void f() {} } ;
struct Derived : Base {} ;

int main()
{
    Derived d ;
    Base &amp; ref = d ;

    // オブジェクトの、実行時の本当の型を表すtype_infoが返される
    std::type_info const &amp; ti = typeid(d) ;

    // true
    ti == typeid(Derived) ;

    // Derivedを表す、人間の読める実装依存の文字列
    std::cout &lt;&lt; ti.name() &lt;&lt; std::endl ;
}
</pre>

<p>
オペランドの式の型がポリモーフィッククラス型のglvalueの場合で、nullポインターを参照した場合は、std::bad_typeidが投げられる。
</p>

<pre>
struct Base { virtual void f() {} } ;
struct Derived : Base {} ;

int main()
{
    // ptrの値はnullポインター
    Base * ptr = nullptr ;

    try {
        typeid( *ptr ) ;// 実行時エラー
    } catch( std::bad_typeid )
    {
        // 例外が投げられて、ここに処理が移る
    }
}
</pre>

<p>
オペランドの式の型が、ポリモーフィッククラス型でない場合は、std::type_infoが表す型情報は、コンパイル時に決定される。
</p>

<pre>
// int型を表すtype_info
typeid(0) ;
// double型を表すtype_info
typeid(0.0) ;

int f() {}
// int型を表すtype_info
typeid( f() ) ;
</pre>

<p>
この際、<a href="#conv.lval">lvalueからrvalueへの型変換</a>、<a href="#conv.array">配列からポインターへの型変換</a>、<a href="#conv.func">関数からポインターへの型変換</a>は行われない。
</p>

<p>
// 配列からポインターへの型変換は行われない
int a[10] ;

// 型情報は、int [10]
// int *ではない
typeid(a) ;

// 関数からポインターへの型変換は行われない
void f() {}

// 型情報は、void (void)
// void (*)(void)ではない。
typeid(f) ;
</p>

<p>
これらの標準型変換は、C++では、非常に多くの場所で、暗黙のうちに行われているので、あまり意識しない。たとえば、テンプレートの実引数を推定する上では、これらの変換が行われる。
</p>

<pre>
// 実引数の型を、表示してくれるはずの便利な関数
template &lt; typename T &gt;
void print_type_info(T)
{
    std::cout &lt;&lt; typeid(T).name() &lt;&lt; std::endl ;
}

void f() { }

int main()
{
    int a[10] ;
    // int [10]
    std::cout &lt;&lt; typeid(a).name() &lt;&lt; std::endl ;
    // int *
    print_type_info(a) ;

    // void (void)
    std::cout &lt;&lt; typeid(f).name() &lt;&lt; std::endl ;
    // void (*)(void)
    print_type_info(f) ;
}
</pre>

<p>
std::type_info::name()の返す文字列は実装依存だが、今、C++の文法と同じように型を表示すると仮定すると、このような出力になる。C++では、多くの場面で、暗黙のうちに、これら三つの型変換が行われるので、このような差異が生じる。
</p>

<p>
オペランドが、型名の場合は、std::type_infoは、その型を表す。ほんの一例をあげると。
</p>

<pre>
int main()
{
    typeid( int ) ;             // int型
    typeid( int * ) ;           // intへのポインター型
    typeid( int &amp; ) ;           // intへのlvalueリファレンス型
    typeid( int [2] ) ;         // 配列型
    typeid( int (*)[2] ) ;      // 配列へのポインター型
    typeid( int (int) ) ;       // 関数型
    typeid( int (*)(int) );     // 関数へのポインター型
}
</pre>

<p>
オペランドの式や型名の、トップレベル（top-level）のCV修飾子は、無視される。
</p>

<pre>
int main()
{
    // トップレベルのCV修飾子は無視される
    typeid(const int) ; // int
    // 当然、型情報は等しい
    typeid(const int) == typeid(int) ; // true

    // 型名も式も同じ
    int i = 0 ; const int ci = 0;
    typeid(ci) ; // int
    typeid(ci) == typeid(i) ; // true

    // これはトップレベルのCV修飾子
    typeid(int * const) ; // int *

    // 以下はトップレベルのCV修飾子ではない
    typeid(const int *) ; // int const *
    typeid(int const *) ; // int const *
}
</pre>
</article>

<article>
<h1 id="expr.static.cast"><a href="#expr.static.cast">Static cast（Static cast）</a></h1>

<pre>
static_cast&lt; 型名 &gt;( 式 )
</pre>

<p>
static_castは、実に多くの静的な変換ができる。その概要は、標準型変換とその逆変換、ユーザー定義の変換、リファレンスやポインターにおける変換など、比較的安全なキャストである。以下にstatic_castの行える変換を列挙するが、これらを丸暗記しておく必要はない。もし、どのキャストを使うか迷った場合は、static_castを使っておけば、まず間違いはない。static_castがコンパイルエラーとなるキャストは、大抵、実装依存で危険なキャストである。
</p>

<p>
static_castによるキャストがどのように行われるかは、おおむね、以下のような順序で判定される。条件に合う変換方法が見つかった時点で、それより先に行くことはない。これは、完全なstatic_castの定義ではない。分かりやすさのため省いた挙動もある。
</p>

<p>
static_cast&lt;T&gt;(v)の結果は、オペランドvを変換先の型Tに変換したものとなる。変換先の型がlvalueリファレンスならば結果はlvalue、rvalueリファレンスならば結果はxvalue、それ以外の結果はprvalueとなる。static_castは、constとvolatileを消し去ることはできない。
</p>



<p>
オペランドの型が基本クラスで、変換先の型が派生クラスへのリファレンスの場合。もし、標準型変換で、派生クラスのポインターから、基本クラスのポインターへと変換できる場合、キャストできる。
</p>

<pre>
struct Base {} ;
struct Derived : Base {} ;

void f(Base &amp; base)
{
    // Derived *からBase *に標準型変換で変換できるので、キャストできる
    Derived &amp; derived = static_cast&lt;Derived &amp;&gt;(base) ;
}
</pre>

<p>
ただし、これには実行時チェックがないので、baseが本当にDerivedのオブジェクトを参照していなかった場合、動作は未定義である。
</p>

<p>
glvalueのオペランドは、rvalueリファレンスに型変換できる。
</p>

<pre>
int main()
{
    int x = 0 ;
    static_cast&lt;int &amp;&amp;&gt;(x) ;
}
</pre>

<p>
もし、static_cast&lt;T&gt;(e) という式で、T t(e); という宣言ができる場合、オペランドの式eは、変換先の型Tに変換できる。その場合、一時オブジェクトを宣言して、それをそのまま使うのと、同じ意味になる。
</p>

<pre>
// short t(0) は可能なので変換できる
static_cast&lt;short&gt;(0) ;

// float t(0) は可能なので変換できる
static_cast&lt;float&gt;(0) ;
</pre>

<p>
<a href="#conv">標準型変換</a>の逆変換を行うことができる。ただし、いくつかの変換は、逆変換を行えない。これには、<a href="#conv.lval">lvalueからrvalueへの型変換</a>、<a href="#conv.array">配列からポインターへの型変換</a>、<a href="#conv.func">関数からポインターへの型変換（Function-to-pointer conversion）</a>、ポインターや関数ポインターからnullポインターへの変換、がある。
</p>

<p>
変換先の型に、voidを指定することができる。その場合、static_castの結果はvoidである。オペランドの式は評価される。
</p>

<pre>
int main()
{
    static_cast&lt;void&gt;( 0 ) ;
    static_cast&lt;void&gt;( 1 + 1 ) ;    
} 
</pre>

<p>
整数型とscoped enum型は、static_castを使うことで、明示的に変換することができる。その場合、変換先の型で、オペランドの値を表現できる場合は、値が保持される。値を表現できない場合の挙動は、規定されていない。
</p>

<pre>
int main()
{
    enum struct A { value = 1 } ;
    enum struct B { value = 1} ;

    int x = static_cast&lt;int&gt;( A::value ) ;
    A a = static_cast&lt;A&gt;(1) ;
    B b = static_cast&lt;B&gt;( A::value ) ;
} 
</pre>

<p>
派生クラスへのポインターから、基本クラスへのポインターにキャストできる。
</p>

<pre>
struct Base {} ;
struct Derived : Base {} ;

Derived d ;
Base * ptr = static_cast&lt;Base *&gt;(&amp;d) ;
</pre>

<p>
voidへのポインターは、他の型へのポインターに変換できる。ある型へのポインターから、voidへのポインターにキャストされ、そのまま、ある型へのポインターにキャストされなおされた場合、その値は保持される。
</p>

<pre>
int main()
{
    int x = 0 ;
    int * ptr = &amp;x ;

    // void *への変換は、標準型変換で行えるので、キャストはなくてもよい。
    void * void_ptr = static_cast&lt;void *&gt;(ptr) ;

    // キャストが必要
    ptr = static_cast&lt;int *&gt;(void_ptr) ;

    *ptr ; // ポインターの値は保持されるので、xを正しく参照する
} 
</pre>
</article>

<article>
<h1 id="expr.reinterpret.cast"><a href="#expr.reinterpret.cast">Reinterpret cast</a></h1>

<pre>
reinterpret_cast &lt; 型名 &gt; ( 式 )
</pre>

<p>
reinterpret_castは、式の値をそのまま、他の型に変換するキャストである。ポインターと整数の間の変換や、ある型へのポインターを全く別の型へのポインターに変換するといったことができる。reinterpret_castを使えば、値をそのままにして、型を変換することができる。変換した結果、その値が、変換先の型としてそのまま使えるかどうかなどといったことは、ほとんど規定されていない。元の値をそのまま保持できるかどうかも分からない。それ故、reinterpret_castは、危険なキャストである。
</p>

<p>
多くの実装では、reinterpret_castには、何らかの具体的で実用的な意味がある。現実のC++が必要とされる環境では、reinterpret_castを使わなければならないことも、多くある。しかし、reinterpret_castを使った時点で、そのコードは実装依存であり、具体的に意味が定義されたその環境でしか動かないということを、常に意識するべきである。
</p>

<p>
reinterpret_castでは、constやvolatileを消し去ることはできない。
</p>

<p>
reinterpret_castでできる変換を、以下に列挙する。
</p>

<section>
<h1>ポインター型と整数型の間の型変換</h1>

<p>
ある型へのポインター型から整数型へのキャスト、あるいはその逆に、整数型やenum型からポインター型へのキャストを行える。整数型は、ポインターの値をそのまま保持できるほど大きくなければならない。どの整数型ならば十分に大きいのか。もし整数型が十分に大きくなければどうなるのかなどということは、定義されていない。
</p>

<pre>
int main()
{
    int x = 0 ;
    int * ptr = &amp;x ;

    // ポインターから整数へのキャスト
    int value = reinterpret_cast&lt;int&gt;(ptr) ;

    // 整数からポインターへのキャスト
    ptr = reinterpret_cast&lt;int *&gt;(value) ;
} 
</pre>

<p>
これらのキャストについての挙動は、ほとんどが実装依存であり、あまり説明できることはない。
</p>

<p>
もし、変換先の整数型が、ポインターの値をすべて表現できるとするならば、再びポインター型にキャストし直した時、ポインターは同じ値を保持すると規定されている。しかし、int型がポインターの値をすべて表現できるという保証はない。unsigned intであろうと、long intであろうとlong long intであろうと、そのような保証はない。従って、上記のコードで、ptrが同じ値を保つかどうかは、実装依存である。
</p>
</section>

<section>
<h1>異なるポインター型の間の型変換</h1>
<p>
ある型へのポインターは、まったく別の型へのポインターに変換できる。たとえば、int *からshort *などといった変換ができる。
</p>

<pre>
int main()
{
    int x = 0 ;
    int * int_ptr = &amp;x ;

    // int * からshort *へのキャスト
    short * short_ptr = reinterpret_cast&lt;short *&gt;(int_ptr) ;
} 
</pre>

<p>
これについても、挙動は実装依存であり、特に説明できることはない。たとえば、上記のコードで、short_ptrを参照した場合どうなるのかということも、全く規定されていない。ある実装では、問題なく、int型のストレージを、あたかもshort型のストレージとして使うことができるかもしれない。ある実装では、参照した瞬間にプログラムがクラッシュするかもしれない。
</p>
</section>

<section>
<h1>異なるリファレンス型の間の型変換</h1>

<p>
異なるポインター型の間の型変換に似ているが、異なるリファレンス型の変換をすることができる。例えば、int &amp;からshort &amp;などといった変換ができる。
</p>

<pre>
int main()
{
    int x = 0 ;

    // int &amp; からshort &amp;へのキャスト
    short &amp; short_ref = reinterpret_cast&lt;short &amp;&gt;(x) ;
} 
</pre>

<p>
異なるポインター型の間の型変換と同じで、これについても、具体的な意味は実装依存である。
</p>
</section>

<section>
<h1>異なるメンバーポインターの間の型変換</h1>
<p>
異なるメンバーポインターへ変換することができる。
</p>

<pre>
struct A { int value ; } ;
struct B { int value ; } ;

int main()
{
    int B::* ptr = reinterpret_cast&lt;int B::*&gt;(&amp;A::value) ;
} 
</pre>

<p>
意味は、実装依存である。
</p>
</section>

<section>
<h1>異なる関数ポインター型の間の型変換</h1>

<p>
ある関数ポインターは、別の型の関数ポインターにキャストできるかもしれない。意味は実装依存である。「かもしれない」というのは実に曖昧な表現だが、たとえ完全に規格準拠な実装であっても、この機能をサポートする義務がないという意味である。
</p>

<pre>
void f(int) {}

int main()
{
    // void (short)な関数へのポインター型
    using type = void (*)(short) ;

    // 関数ポインターの型変換
    type ptr = reinterpret_cast&lt;type&gt;(&amp;f) ;
} 
</pre>

<p>
この変換がどういう意味を持つのか。例えば、変換した結果の関数ポインターは、関数呼び出しできるのか。できるとして、一体どういう意味になるのか、などということは一切規定されていない。
</p>
</section>

<section>
<h1>reinterpret_castには、できないこと</h1>

<p>
reinterpret_castが行えるキャストは、上記にすべて列挙した。それ以外の変換は、reinterpret_castでは行うことができない。これは、そもそもreinterpret_castの目的が、危険で実装依存なキャストのみを分離するという目的にあるので、それ以外の変換は、あえて行えないようになっている。
</p>

<pre>
int main()
{
    short value = 0 ;

    // OK、標準型変換による暗黙の型変換
    int a = value ;
    // OK、static_castによる明示的な型変換
    int b = static_cast&lt;int&gt;(value) ;

    // エラー
    // reinterpret_castでは、この型変換をサポートしていない
    int c = reinterpret_cast&lt;int&gt;(value) ;
} 
</pre>
</section>

</article>

<article>
<h1 id="expr.const.cast"><a href="#expr.const.cast">Const cast</a></h1>

<pre>
const_cast &lt; 型名 &gt; ( 式 )
</pre>

<p>
const_castは、constとvolatileが異なる型の間の型変換を行う。constやvolatileを取り除くことや、付け加えることができる。
</p>

<pre>
int main()
{
    int const x = 0 ;

    // エラー、constを取り除くことはできない。
    int * error1 = &amp;x ; 
    int * error2 = static_cast&lt;int *&gt;(&amp;x) ;

    // OK、ポインターの例
    int * ptr = const_cast&lt;int *&gt;(&amp;x) ;
    // OK、リファレンスの例
    int &amp; ref = const_cast&lt;int &amp;&gt;(x) ;

    // constを付け加えることもできる。
    int y = 0 ;
    int const * cptr = const_cast&lt;int const *&gt;(&amp;y) ;
} 
</pre>

<p>
ポインターへのポインターであっても、それぞれのconstを取り除くことができる。
</p>

<pre>
int main()
{
    int const * const * const * const c = nullptr ;
    int *** ptr = const_cast&lt;int ***&gt;(c) ;
} 
</pre>

<p>
const_castは、constやvolatileのみを取り除く、または付け加えるキャストのみを行える。それ以外の型変換を行うことはできない。
</p>

<pre>
int main()
{
    int const x = 0 ;
    // エラー、const以外の型変換を行っている。
    short * ptr = const_cast&lt;short *&gt;(&amp;x) ;
} 
</pre>

<p>
では、constを取り除くと同時に、他の型変換も行ないたい場合はどうするかというと、static_castや、reinterpret_castを併用する。
</p>

<pre>
int main()
{
    int const x = 0 ;

    short * ptr1 =
        static_cast&lt;short *&gt;(
            static_cast&lt;void *&gt;(
                const_cast&lt;int *&gt;(&amp;x)
            )
        ) ;
  
    short * ptr2 = reinterpret_cast&lt;short *&gt;(const_cast&lt;int *&gt;(&amp;x)) ;
} 
</pre>

<p>
const_castは、基本的に、ほとんどのconstをキャストすることができるが、キャストできないconstも存在する。たとえば、関数ポインターやメンバー関数ポインターに関するconstを取り除くことはできない。関数へのリファレンスも同様である。
</p>

<pre>
void f( int ) {}

int main()
{
    using type = void (*)(int) ;
    type const ptr = nullptr ;

    // エラー、関数ポインターはキャストできない
    type p = const_cast&lt;type&gt;(ptr) ;
} 
</pre>

<p>
もちろん、関数の仮引数に対するconstをキャストすることや、constなメンバー関数を非constなメンバー関数にキャストすることなどもできない。
</p>
</article>

</article>

<article>
<h1 id="expr.unary"><a href="#expr.unary">単項式（Unary expressions）</a></h1>

<p>
単項式は、オペランドをひとつしか取らないことより、そう呼ばれている。単項式の評価順序はすべて、「右から左」である。
</p>

<article>
<h1 id="expr.unary.op"><a href="#expr.unary.op">単項演算子（Unary operators）</a></h1>

<p>
単項演算子というカテゴリーには、五つの異なる演算子がまとめられている。*、&amp;、+、-、!、~である。
</p>

<article>
<h1 id="expr.unary.op.pointer"><a href="#expr.unary.op.pointer">* 演算子と&amp; 演算子</a></h1>

<p>
* 単項演算子は、参照（indirection）である。オペランドは、オブジェクトへのポインターでなければならない。オペランドの型が、「Tへのポインター」であるとすると、式の結果は、lvalueのTである。
</p>

<p>
&amp; 演算子は、オペランドのポインターを得る。オペランドの型がTであるとすると、結果は、prvalueのTへのポインターである。&amp; 演算子は、オブジェクトだけではなく、関数にも適用できる。
</p>

<pre>
int main()
{
    int x = 0 ;

    // &amp; 演算子
    // 変数xのオブジェクトへのポインターを得る。
    int * ptr = &amp;x ;

    // * 演算子
    // ポインターを参照する
    *ptr ;
}
</pre>
</article>

<article>
<h1 id="expr.unary.op.plus.minus"><a href="#expr.unary.op.plus.minus">単項演算子の+と-</a></h1>

<p>
単項演算子の+と-は、オペランドの符号を指定する演算子である。
</p>

<p>
+ 単項演算子は、オペランドの値を、そのまま返す。オペランドの型には、数値型、非scoped enum型、ポインター型が使える。結果はprvalueである。
</p>

<pre>
int main()
{
    int x = +0 ; // xは0
    +x ; // 結果は0

    int * ptr = nullptr ;
    +ptr ; // 結果はptrの値
} 
</pre>

<p>
ただし、オペランドには、整数のプロモーションが適用されるので、オペランドの型がcharやshort等の場合、int型になる。
</p>

<pre>
short x = 0 ;
+x ; // int型の0
</pre>

<p>
- 単項演算子は、オペランドの値を、負数にして返す。オペランドの型には、数値型と非scoped enum型が使える。+ 単項演算子と同じく、オペランドには整数のプロモーションが適用される。
</p>

<pre>
-0 ; // 0
-1 ; // -1
- -1 ; // +1
</pre>

<p>
- 単項演算子が、unsignedな整数型に使われた場合の挙動は、明確に定義されている。オペランドのunsignedな整数型のビット数をnとする。式の結果は、2<sup>n</sup>から、オペランドの値を引いた結果の値になる。
</p>

<p>
具体的な例を挙げるために、今、unsigned int型を16ビットだと仮定する。
</p>

<pre>
// unsigned int型は16bitであるとする。
unsigned int x = 1 ;
// result = 2<sup>16</sup> - 1 = 65536 - 1 = 65535
unsinged int result = -x ;

x = 100 ;
// result = 2<sup>16</sup> - 100 = 65536 - 100 = 65436
result = -x ;
</pre>
</article>

<article>
<h1 id="expr.unary.op.not"><a href="#expr.unary.op.not">! 演算子</a></h1>

<p>
! 演算子は、オペランドをboolに変換し、その否定を返す。つまり、オペランドがtrueの場合はfalseに、falseの場合はtrueになる。
</p>

<pre>
!true ; // false
!false ; // true

int x = 0 ;
!x ; // 0はfalseに変換される。その否定なので、結果はtrue
</pre>
</article>

<article>
<h1 id="expr.unary.op.bitwise.not"><a href="#expr.unary.op.bitwise.not">~ 演算子</a></h1>

<p>
~ 演算子は、ビット反転とも呼ばれている。オペランドには、整数型と非scoped enum型が使える。式の結果は、オペランドの1の補数となる。すなわち、オペランドの各ビットが反転された値となる。オペランドには整数のプロモーションが適用される。
</p>

<pre>
int x = 0 ;
// ビット列の各ビットを反転する
~x ;
</pre>
</article>

</article>

<article>
<h1 id="expr.pre.incr"><a href="#expr.pre.incr">インクリメントとデクリメント（Increment and decrement）</a></h1>

<pre>
++ 式
-- 式
</pre>

<p>
ここでは、前置式のインクリメントとデクリメントについて解説する。<a href="#expr.post.incr">後置式のインクリメントとデクリメント</a>も参照。
</p>

<p>
前置式の++ 演算子は、オペランドに1を加算して、その結果をそのまま返す。オペランドは数値型かポインター型で、変更可能なlvalueでなければならない。式の結果はlvalueになる。
</p>

<p>
前置式の-- 演算子は、オペランドから1を減算する。それ以外は、++演算子と同じように動く。
</p>

<pre>
int x = 0 ;
int result = ++x ;
// ここで、result = 1, x = 1
</pre>
</article>

<article>
<h1 id="expr.sizeof"><a href="#expr.sizeof">sizeof（Sizeof）</a></h1>

<pre>
sizeof ( 未評価式 )
sizeof ( 型名 )
sizeof ... ( 識別子 )
</pre>

<p>
sizeofとは、オペランドを表現するオブジェクトのバイト数を返す演算子である。オペランドは、未評価式か型名になる。
</p>

<p>
オペランドに型名を指定した場合、sizeof演算子は、型のオブジェクトのバイト数を返す。sizeof(char)、sizeof(signed char)、sizeof(unsigned char)は、1を返す。それ以外のあらゆる型のサイズは、実装によって定義される。たとえば、sizeof(bool)やsizeof(char16_t)やsizeof(char32_t)のサイズも、規格では決められていない。
</p>

<pre>
// 1
sizeof(char) ;
// int型のオブジェクトのサイズ
sizeof(int) ;
</pre>

<p>
オペランドに式を指定した場合、その式の結果の型のオブジェクトのバイト数を返す。式は評価されない。<a href="#conv.lval">lvalueからrvalueへの型変換</a>、<a href="#conv.array">配列からポインターへの型変換</a>、<a href="#conv.func">関数からポインターへの型変換</a>は行われない。
</p>

<pre>
int f() ;

// int型のオブジェクトのサイズ
sizeof( f() ) ;
// int型のオブジェクトのサイズ
sizeof( 1 + 1 ) ;
</pre>

<p>
関数呼び出しの式の結果の型は、関数の戻り値の型になる。
</p>

<p>
オペランドには、関数と不完全型を使うことはできない。関数は、そもそもオブジェクトではないし、不完全型は、そのサイズを決定できないからだ。「関数」は使えないが、関数呼び出しは「関数」ではないので使える。また、関数ポインターにも使える。
</p>

<pre>
int f () ;
struct Incomplete ;

// 関数呼び出しは「関数」ではない
// sizeof(int) と同じ
sizeof( f() ) ;
// 関数ポインターはオブジェクトであるので、使える
// sizeof ( int (*)(void) ) と同じ
sizeof( &amp;f ) ;

// エラー、関数を使うことはできない
sizeof( f ) ;
// エラー、不完全型を使うことはできない
sizoef( Incomplete ) ;
</pre>

<p>
オペランドがリファレンス型の場合、参照される型のオブジェクトのサイズになる。
</p>

<pre>
void f( int &amp; ref )
{
// sizeof(int)と同じ
sizeof(int &amp;) ;
sizeof(int &amp;&amp;) ;
sizeof( ref ) ;
}
</pre>

<p>
オペランドがクラス型の場合、クラスのオブジェクトのバイト数になる。これには、アライメントの調整や、配列の要素として使えるようにするための実装依存のパディングなども含まれる。クラス型のサイズは、必ず1以上になる。これは、サイズが0では、ポインターの演算などに差し支えるからである。
</p>

<p>
オペランドが配列型の場合、配列のバイト数になる。これはつまり、要素の型のサイズ　×　要素数となる。
</p>

<pre>
// sizeof(int) * 10 と同じ
sizeof( int [10] ) ;

char a[10] ;
// sizeof(char) * 10 = 1 * 10 = 10
sizeof( a ) ;

// この型は配列ではなく、int
// sizeof(int)と同じ
sizeof( a[0] ) ;
</pre>

<p>
sizeof...は、オブジェクトのバイト数とは、何の関係もない。sizeof...のオペランドには、パラメーターパックの識別子を指定できる。sizeof...演算子は、オペランドのパラメーターパックの引数の数を返す。sizeof...演算子の結果は定数で、型はstd::size_tである。
</p>

<pre>
#include &lt;cstddef&gt;
#include &lt;iostream&gt;

template &lt; typename... Types &gt;
void f( Types... args )
{
    std::size_t const t = sizeof...(Types) ;
    std::size_t const a = sizeof...(args) ;

    std::cout &lt;&lt; t &lt;&lt; ", " &lt;&lt; a &lt;&lt; std::endl ;    
}

int main()
{
    f() ; // 0, 0
    f(1,2,3) ; // 3, 3
    f(1,2,3,4,5) ; // 5, 5
}
</pre>
</article>

<article>
<h1 id="expr.new"><a href="#expr.new">new</a></h1>

<p>
確保関数と解放関数の具体的な実装方法については、<a href="#support.dynamic">動的メモリー管理</a>を参照。
</p>

<pre>
::<sub>opt</sub> new 型名 new初期化子<sub>opt</sub>
::<sub>opt</sub> new ( 式リスト ) 型名 new初期化子<sub>opt</sub>
</pre>

<p>
newに必要な宣言の一部は、&lt;new&gt;ヘッダーで定義されているので、使う際は、これをincludeしなければならない。
</p>

<p>
new式は、型名のオブジェクトを生成する。newされる型は、完全型でなければならない。ただし、抽象クラスはnewできない。リファレンスはオブジェクトではないため、newできない。new式の結果は、型が配列以外の場合は、生成されたオブジェクトへのポインターを返す。型が配列の場合は、配列の先頭要素へのポインターを返す。
</p>

<pre>
class C {} ;
int main()
{
    // int型のオブジェクトを生成する
    int * i = new int ;
    // C型のオブジェクトを生成する
    C * c = new C ;
}
</pre>

<p>
newが、オブジェクトのためのストレージの確保に失敗した場合、std::bad_alloc例外がthrowされる。
</p>

<pre>
int main()
{
    try {
        new int ;
    } catch( std::bad_alloc )
    {
        // newが失敗した
    }
}
</pre>

<p>
詳細なエラーについては、後述する。
</p>

<p>
newによって生成されるオブジェクトは、<a href="#basic.stc.dynamic">動的ストレージの有効期間</a>を持つ。つまり、newによって作られたオブジェクトを破棄するためには、明示的にdeleteを使わなければならない。
</p>

<pre>
int main()
{
    int * ptr new int ; // 生成
    delete ptr ; // 破棄
}
</pre>

<section>
<h1>new式の評価</h1>

<p>
new式に、new初期化子が指定されている場合、その式を評価する。次に、確保関数（allocation function）を呼び出して、オブジェクトの生成に必要なストレージを確保する。初期化を行ない、確保したストレージ上に、オブジェクトを構築する。そして、オブジェクトへのポインターを返す。
</p>
</section>

<section>
<h1>配列の生成</h1>
<p>
newで配列を生成する場合、要素数は、定数でなくても構わない。
</p>

<pre>
void f( int n )
{
    // 5個のint型の配列を生成する
    // 要素数は定数
    new int[5] ;

    // n個のint型の配列を生成する
    // 要素数は定数ではない
    new int[n] ;
}
</pre>

<p>
配列の配列、つまり多次元配列を生成する場合、配列型の最初に指定する要素数は、定数でなくても構わない。残りの要素数は、すべて定数でなければならない。
</p>

<pre>
void f( int n )
{
    // 要素数はすべて定数
    new int[5][5][5] ;

    // OK
    // 最初の要素数は定数ではない
    // 残りはすべて定数
    new int[n][5][5] ;

    new int [n] // 最初の要素数は定数でなくてもよい
            [5][5] ; // 残りの要素数は定数でなければならない

    // エラー
    // 最初以外の要素数が定数ではない
    new int[n][n][n] ;
    new int[5][n][n] ;
    new int[5][n][5] ;
}
</pre>

<p>
配列の要素数が0の場合、newは、0個の配列を生成する。配列の要素数が負数であった場合の挙動は未定義である。
</p>

<pre>
int main()
{
    // OK 
    int * ptr = new int[0] ;
    // もちろんdeleteしなければならない
    delete ptr ;

    // エラー
    new int[-1] ;
}
</pre>

<p>
もし、配列型の定数ではない要素数が、実装の制限以上の大きさである場合、ストレージの確保は失敗する。その場合、std::bad_array_new_length例外がthrowされる。要素数が定数であった場合は、通常通り、std::bad_alloc例外がthrowされる。
</p>

<pre>
// int[n]のストレージを確保できないとする。
int main()
{
    try {
        std::size_t n = std::numeric_limits&lt;std::size_t&gt;::max() ;
        new int[n] ; // 要素数は定数ではない
    } catch( std::bad_array_new_length )
    {
        // ストレージを確保できなかった場合
    }

    try {
        // numeric_limitsのメンバー関数maxはconstexpr関数なので、定数になる。
        std::size_t const n = std::numeric_limits&lt;std::size_t&gt;::max() ;
        new int[n] ;// 要素数は定数
    } catch( std::bad_alloc )
    {
        // ストレージを確保できなかった場合
    }    
}
</pre>

<p>
要素数が定数でない場合で、ストレージが確保できない場合のみ、std::bad_array_new_lengthがthrowされる。要素数が定数の場合は、通常通り、std::bad_allocがthrowされる。
</p>
</section>

<section>
<h1>オブジェクトの初期化</h1>

<p>
生成するオブジェクトの初期化は、new初期化子によって指定される。new初期化子とは、( 式リスト )か、初期化リストのいずれかである。new初期化子が指定された場合、オブジェクトは、直接初期化される。new初期化子が省略された場合、デフォルト初期化される。
</p>

<pre>
struct C
{
    C() {}
    C(int) {}
    C(int,int) {}
} ;


int main()
{
    // new初期化子が省略されている
    // デフォルト初期化
    new C ;

    // 直接初期化
    new C(0) ;
    new C(0, 0) ;

    // 初期化リスト
    new C{0} ;
    new C{0,0} ;
}
</pre>

<p>
組み込み型に対するデフォルト初期化は、「初期化しない」という挙動なので、注意を要する。初期化についての詳しい説明は、<a href="#dcl.init">初期化子</a>を参照。
</p>
</section>

<section>
<h1>型名としてのauto</h1>

<p>
newの型名がautoの場合、new初期化子は、( 代入式 )の形を取らなければならない。オブジェクトの型は、代入式の結果の型となる。オブジェクトは代入式の結果の値で初期化される。
</p>

<pre>
int f() { return 0 ; }
int main()
{
    // int型、値は0
    new auto( 0 ) ;
    // double型、値は0.0
    new auto( 0.0 ) ;
    // float型、値は0.0f
    new auto( 0.0f ) ;
    // int型、値は関数fの戻り値
    new auto( f() ) ;
}
</pre>

<p>
これは、auto指定子とよく似ている。
</p>
</section>

<section>
<h1>placement new</h1>

<p>
placement newとは、確保関数に追加の引数を渡すことができるnew式の文法である。これは、対応するnew演算子のオーバーロード関数を呼び出す。
</p>

<pre>
void * operator new( std::size_t size, int ) throw(std::bad_alloc)
{ return operator new(size) ; }
void * operator new( std::size_t size, int, int ) throw(std::bad_alloc)
{ return operator new(size) ; }
void * operator new( std::size_t size, int, int, int ) throw(std::bad_alloc)
{ return operator new(size) ; }

int main()
{
    new(1) int ; // operator new( sizeof(int), 1 )
    new(1,2) int ; // operator new( sizeof(int), 1, 2 )
    new(1,2,3) int ; // operator new( sizeof(int), 1, 2, 3 )
}
</pre>

<p>
このように、newと型名の間に、通常の関数の実引数のリストのように、追加の引数を指定することができる。追加の引数は、operator newの二番目以降の引数に渡される。placement newの追加の引数は、ストレージを確保する方法を確保関数に指定するなどの用途に使える。
</p>
</section>

<section>
<h1>特殊なplacement new</h1>

<p>
C++には、あらかじめplacement newが二つ定義されている。operator new(std::size_t, const std::nothrow_t &amp;) throw()と、operator new(std::size_t, void *) throw()である。
</p>

<p>
operator new(std::size_t, const std::nothrow_t &amp;) throw()は、ストレージの確保に失敗しても例外を投げない特別な確保関数である。これには通常、std::nothrowが渡される。
</p>

<pre>
// デフォルトで実装により定義される確保関数
// void * operator new(std::size_t, const std::nothrow_t &amp;) throw() ;

int main()
{
    // 失敗しても例外を投げない
    int * ptr = new(std::nothrow) int ;

    if ( ptr != nullptr )
    {
        // オブジェクトの生成に成功
        // 参照できる
        *ptr = 0 ;
    }

    delete ptr ;
}
</pre>

<p>
nothrow版のnew演算子のオーバーロードは、ストレージの確保に失敗しても、例外を投げない。かわりに、nullポインターを返す。これは、newは使いたいが、どうしても例外を使いたくない状況で使うことができる。nothrow版のnewを呼び出した場合は、戻り値がnullポインターであるかどうかを確認しなければならない。
</p>

<p>
std::nothrow_tは、単にオーバーロード解決のためのタグに過ぎない。また、引数として渡しているstd::nothrowは、単に便利な変数である。
</p>

<pre>
// 実装例
namespace std {
    struct nothrow_t {} ;
    extern const nothrow_t nothrow ;
}
</pre>

<p>
operator new(std::size_t, void *) throw()は、非常に特別な確保関数である。この形のnew演算子はオーバーロードできない。このnew演算子は、ストレージを確保する代わりに、第二引数に指定されたポインターの指すストレージ上に、オブジェクトを構築する。第二引数のポインターは、オブジェクトの構築に必要なサイズやアライメント要求などの条件を満たしていなければならない。
</p>

<p>
一般に、placement newといえば、この特別なnew演算子の呼び出しを意味する。ただし、正式なplacement newという用語の意味は、追加の実引数を指定するnew式の文法である。
</p>

<pre>
struct C
{
    C(){ std::cout &lt;&lt; "constructed." &lt;&lt; std::endl ; }
    ~C(){ std::cout &lt;&lt; "destructed." &lt;&lt; std::endl ; }
} ;

int main()
{
    // ストレージを自前で確保する
    // operator newの返すストレージは、あらゆるアライメント要求を満たす
    void * storage = operator new( sizeof(C) ) ;

    // placement newによって、ストレージ上にオブジェクトを構築
    C * ptr = new( storage ) C ;

    // ストレージの開放の前に、デストラクターを呼び出す
    ptr-&gt;~C() ;

    // ストレージを自前で開放する
    operator delete( storage ) ;
}
</pre>

<p>
ストレージは自前で確保しなければならないので、通常通りdelete式を使うことはできない。デストラクターを自前で呼び出し、その後に、ストレージを自前で解放しなければならない。
</p>

<p>
ストレージは、動的ストレージでなくても構わない。ただし、アライメント要求には注意しなければならない。
</p>

<pre>
struct C
{
    int x ;
    double y ;
} ;

int main()
{
    // ストレージは自動変数
    char storage [[align(C)]] [sizeof(C)] ;

    // placement newによって、ストレージ上にオブジェクトを構築
    C * ptr = new( storage ) C ;

    // デストラクターはtrivialなので呼ぶ必要はない。
    // ストレージは自動変数なので、開放する必要はない
}
</pre>

<p>
この例では、sizeof(C)の大きさのchar配列の上にオブジェクトを構築している。アトリビュートを使い、アライメントを指定していることに注意。
</p>

<p>
このplacement newは、STLのアロケーターを実装するのにも使われている。
</p>
</section>

<section>
<h1>ストレージの確保に失敗した場合のエラー処理</h1>
<p>
確保関数がストレージの確保に失敗した場合、std::bad_alloc例外がthrowされる。placement newのstd::nothrow_tを引数に取る確保関数の場合は、戻り値のポインターが、nullポインターとなる。
</p>

<pre>
int main()
{
    try {
        new int ;
    } catch( std::bad_alloc )
    {
        // エラー処理
    }

    int * ptr = new(std::nothrow) int ;

    if ( ptr == nullptr )
    {
        // エラー処理
    }
}
</pre>
</section>

<section>
<h1>初期化に失敗した場合のエラー処理</h1>

<p>
newが失敗する場合は、二つある。ストレージが確保に失敗した場合と、オブジェクトの初期化に失敗した場合である。
</p>

<p>
たとえストレージが確保できたとしても、オブジェクトの初期化は、失敗する可能性がある。なぜならば、初期化の際に、コンストラクターが例外を投げるかもしれないからだ。
</p>

<pre>
// 例外を投げるコンストラクターを持つクラス
struct Fail
{
    Fail() { throw 0 ; }
} ;

int main()
{
    try {
        new Fail ; // 必ず初期化に失敗する
    } catch( int ) { }
}
</pre>

<p>
コンストラクターが例外を投げた場合、newは、確保したストレージを、対応する解放関数（deallocation function）を呼び出して解放する。そして、コンストラクターの投げた例外を、そのまま外に伝える。
</p>

<p>
対応する解放関数とは何か。通常は、operator delete(void *)である。しかし、placement newを使っている場合は、最初の引数を除く、残りの引数の数と型が一致するoperator deleteになる。
</p>

<pre>
// placement new
void * operator new( std::size_t size, int, int, int ) throw(std::bad_alloc)
{ return operator new(size) ; }

// placement delete
void operator delete( void * ptr, int, int, int ) throw()
{
    std::cout &lt;&lt; "placement delete" &lt;&lt; std::endl ;
    operator delete(ptr) ;
}

// 例外を投げるかもしれないクラス
struct Fail
{
    Fail() noexcept(false) ; // 例外を投げる可能性がある
} ;

int main()
{
    // コンストラクターが例外を投げた場合、
    // operator delete( /*ストレージへのポインター*/, 1, 2, 3 )が呼ばれる
    Fail * ptr = new(1, 2, 3) Fail ;

    // operator delete(void *)が呼ばれる
    delete ptr ;
}
</pre>

<p>
初期化が失敗した場合のplacement deleteの呼び出しには、placement newに渡された追加の引数と、全く同じ値が渡される。
</p>

<p>
なお、delete式は通常通り、operator delete(void *)を呼び出す。たとえplacement newで確保したオブジェクトであっても、delete式では対応する解放関数は呼ばれない。あくまで、初期化の際に呼ばれるだけである。また、delete式から、placement deleteを呼び出す文法も存在しない。これは、「newの際に指定した情報を、deleteの際にまで保持しておくのは、ユーザー側にとっても実装側にとっても困難である」という思想に基づく。
</p>
</section>

<section>
<h1>確保関数の選択</h1>

<p>
new式が呼び出す確保関数は、以下の方法で選択される。
</p>

<p>
生成するクラスのメンバー関数に、operator newのオーバーロードがある場合、メンバー関数が選ばれる。メンバー関数によってオーバーロードされていない場合、グローバルスコープのoperator newが選ばれる。new式が、「::new」で始まる場合、たとえメンバー関数によるオーバーロードがあっても、グローバルスコープのoperator newが選ばれる
</p>

<pre>
// オーバーロードあり
struct A
{
    void * operator new( std::size_t size ) throw(std::bad_alloc) ;
} ;

// オーバーロードなし
struct B { } ;

int main()
{
    // A::operator newが選ばれる
    new A ;
    // ::operator newが選ばれる
    new B ;

    // ::operator newが選ばれる
    ::new A ;
}
</pre>

<p>
配列の場合も同様である。配列の場合メンバー関数は、配列の要素のクラス型のメンバーから探される。
</p>

<pre>
// オーバーロードあり
struct A
{
    void * operator new[]( std::size_t size ) throw(std::bad_alloc) ;
} ;

// オーバーロードなし
struct B { } ;

int main()
{
    // A::operator new[]が選ばれる
    new A[1] ;
    // ::operator new[]が選ばれる
    new B1[1] ;

    // ::operator new[]が選ばれる
    ::new A[1] ;
}
</pre>

<p>
placement newの場合、追加の引数が、オーバーロード解決によって考慮され、最も最適なオーバーロード関数が選ばれる。
</p>

<pre>
void * operator new( std::size_t size, int ) throw( std::bad_alloc ) ;
void * operator new( std::size_t size, double ) throw( std::bad_alloc ) ;
void * operator new( std::size_t size, int, int ) throw( std::bad_alloc ) ;

int main()
{
    // operator new( std::size_t size, int )
    new(0) int ;
    // operator new( std::size_t size, double )
    new(0.0) int ;
    // operator new( std::size_t size, int, int )
    new(1, 2) int ;
}
</pre>
</section>

<section>
<h1>CV修飾されている型のnew</h1>

<p>
CV修飾子のある型もnewできる。特に変わることはない。
</p>

<pre>
int main()
{
    int const * ptr = new int const(0) ;
    delete ptr ;
}
</pre>
</section>

</article>

<article>
<h1 id="expr.delete"><a href="#expr.delete">delete</a></h1>

<p>
確保関数と解放関数の具体的な実装方法については、<a href="#support.dynamic">動的メモリー管理</a>を参照。
</p>

<pre>
::<sub>opt</sub> delete 式
::<sub>opt</sub> delete [ ] 式
</pre>

<p>
new式によって確保したオブジェクトの寿命は、スコープにはとらわれない。オブジェクトを破棄したければ、delete式で解放しなければならない。
</p>

<p>
deleteのオペランドの値は、new式によって返されたポインターでなければならない。オブジェクトが配列ではない場合は、deleteを、配列の場合は、delete [ ]を使う。delete式の結果の型は、voidである。
</p>

<pre>
int main()
{
    int * ptr = new int ;
    int * array_ptr = new int[1] ;

    delete ptr ;
    delete[] array_ptr ;
}
</pre>

<p>
配列であるかどうかで、deleteとdelete[]を使い分けなければならない。これは間違えやすいので注意すること。
</p>

<p>
deleteのオペランドがクラスのオブジェクトであった場合、非explicitなユーザー定義の変換が定義されている場合、オブジェクトへのポインターに変換される。
</p>

<pre>
struct C
{
    operator int *() { return new int ; }
} ;

int main()
{
    C c ;
    // C::operator int *()を呼び出し、
    // 戻り値を解放する。
    delete c ;
}
</pre>



<p>
delete式は、まず、ポインターの指し示すオブジェクトのデストラクターを呼び出す。次に、解放関数を呼び出して、ストレージを開放する。オブジェクトのの指す型が、メンバー関数としてoperator deleteのオーバーロードを持つ場合、メンバー関数が呼ばれる。オーバーロードされたメンバー関数が存在しない場合、グローバルスコープのoperator deleteを呼び出す。delete式が、「::delete」で始まる場合、メンバー関数のオーバーロードの有無にかかわらず、グローバルスコープのoperator deleteを呼び出す。
</p>

<pre>
// オーバーロードあり
struct A
{
    void operator delete( void * ) throw() ;
} ;

// オーバーロードなし
struct B { } ;

int main()
{
    A * a = new A ;
    // A::operator delete(void*)を呼び出す
    delete a ; 

    B * b = new B ;
    // ::operator delete(void*)を呼び出す
    delete b ;

    a = new A ;
    // ::operator delete(void*)を呼び出す
    ::delete a ;
}
</pre>


<p>
オブジェクトが、placement newで確保されたとしても、呼び出す解放関数は、必ずoperator delete(void *)、もしくはoperator delete[](void *)となる。delete式では、placement deleteは呼び出されない。また、delete式には、placement deleteを呼び出すための文法も存在しない。どうしてもplacement deleteを呼び出したい場合は、手動でデストラクターを呼び出し、さらに手動でplacement deleteを呼び出すしかない。
</p>

<pre>
// placemente delete
void operator delete( void *, int ) throw() ;

struct C
{
    C() {}
    ~C(){}
} ;

void f()
{
    C * ptr = new C ;

    // これでは、operator delete( void * )が呼び出される
    delete ptr ;

    // 擬似デストラクター呼び出し
    ptr->~C() ;
    // operator deleteの明示的な呼び出し
    operator delete( ptr, 0 ) ;
}
</pre>
</article>

<article>
<h1 id="expr.alignof"><a href="#expr.alignof">alignof</a></h1>

<pre>
alignof ( 型名 )
</pre>

<p>
alignof式は、オペランドの型のアライメント要求を返す。オペランドの型は、完全なオブジェクト型か、その配列もしくはリファレンスでなければならない。式の結果は、std::size_t型の定数になる。
</p>

<p>
オペランドが、リファレンス型の場合、結果は参照される型のアライメント要求になる。配列の場合、結果は配列の要素の型のアライメント要求になる。
</p>

<pre>
struct C
{
    char c ; int i ; double d ;
} ;

void f()
{
    // char型のアライメント要求を返す
    alignof( char ) ;
    // int型のアライメント要求を返す
    alignof( int ) ;
    // double型のアライメント要求を返す
    alignof( double ) ;
    // C型のアライメント要求を返す
    alignof( C ) ;
}
</pre>
</article>

<article>
<h1 id="expr.unary.noexcept"><a href="#expr.unary.noexcept">noexcept演算子（noexcept operator）</a></h1>

<pre>
noexcept ( 未評価式 )
</pre>

<p>
noexcept演算子は、オペランドの式が、例外を投げる可能性のある式を含むかどうかを返す。noexcept演算子の結果の型はboolの定数で、例外を投げる可能性のある式を含まない場合trueを、含む場合falseを返す。オペランドの式は、評価されない。
</p>

<p>
結果がfalseとなる場合、すなわち、例外を投げる可能性のある式とは、以下の通りである。
</p>

<p>
throw式。
</p>
<pre>
// false
noexcept( throw 0 ) ;
</pre>

<p>
dynamic_cast式、dynamic_cast&lt;T&gt;(v)において、Tがリファレンス型で、実行時チェックが必要な場合。
</p>

<pre>
struct Base { virtual void f() {} } ;
struct Derived : Base { } ;

void f( Base &amp; ref )
{
    // false
    noexcept( dynamic_cast&lt;Derived &amp; &gt;( ref ) ) ;
}
</pre>

<p>
typeid式において、オペランドがglvalueで、実行時チェックが必要な場合。
</p>


<pre>
struct Base { virtual void f() {} } ;
struct Derived : Base { } ;

void f( Base * ptr )
{
    // false
    noexcept( typeid( *ptr ) ) ;
}
</pre>

<p>
関数、メンバー関数、関数ポインター、メンバー関数ポインターを呼び出す式において、呼び出す関数の例外指定が、無例外（non-throwing）であるもの。
</p>

<pre>
void a() ;
void b() noexcept ; // non-throwing
void c() noexcept(true) ; // non-throwing
void d() noexcept(false) ;
void e() throw() ; // non-throwing
void f() throw(int) ;

int main()
{
    noexcept( a() ) ; // false
    noexcept( b() ) ; // true
    noexcept( c() ) ; // true
    noexcept( d() ) ; // false
    noexcept( e() ) ; // true
    noexcept( f() ) ; // false
}

</pre>

<p>
関数を、「呼び出す式」というのは、関数を間接的に呼び出す場合も該当する。たとえば、new式は確保関数を呼び出すので、関数を呼び出す式である。その場合の結果は、呼び出される確保関数の例外指定に依存する。
</p>

<pre>
int main()
{
    // ::operator new( std::size_t ) throw( std::bad_alloc) を呼び出す
    std::cout &lt;&lt; noexcept( new int ) ; // false

    // ::operator new( std::size_t, std::nothrow_t ) throw() を呼び出す
    std::cout &lt;&lt; noexcept( new(std::nothrow) int ) ; // true
}
</pre>

<p>
もちろん、演算子のオーバーロード関数も、「関数」である。従って、演算子のオーバーロード関数を呼び出す式は、関数を呼び出す式である。
</p>

<pre>
struct C
{
    C operator +( C ) ;
    C operator -( C ) noexcept ;
} ;


int main()
{
    int i = 0 ;
    noexcept( i + i ) ; // true

    C c ;
    noexcept( c + c ) ; // false
    noexcept( c - c ) ; // true
}
</pre>

<p>
その他にも、関数を間接的に呼び出す可能性のある式というのは、非常に多いので、注意しなければならない。
</p>

<p>
関数のオーバーロード解決は静的に行われるので、当然、呼び出される関数に応じて結果も変わる。
</p>

<pre>
void f(int) noexcept ;
void f(double) ;

int main()
{
    noexcept( f(0) ) ; // true
    noexcept( f(0.0) ) ; // false
}
</pre>



<p>
例外を投げる可能性のある式を「含む」というのは、たとえその式が絶対に評価されないでも、例外を投げる可能性があるとみなされる。例えば、
</p>

<pre>
noexcept( true ? 0 : throw 0 ) ; // false
</pre>

<p>
このnoexceptのオペランドの式は、もし評価された場合、決して例外を投げることがない。しかし、例外を投げる可能性のある式を含んでいるので、noexceptの結果はfalseとなる。
</p>

<p>
上記以外の場合、noexceptの結果はtrueとなる。
</p>

<pre>
struct Base { } ;
struct Derived : Base { } ;

int main()
{
    noexcept( 0 ) ; // true

    Derived d ;
    noexcept( d ) ; // true
    noexcept( dynamic_cast&lt;Base &amp;&gt;( d ) ) ; // true
    noexcept( typeid( d ) ) ; // true
}
</pre>
</article>

</article>

<article>
<h1 id="expr.cast"><a href="#expr.cast">キャスト形式による明示的型変換（Explicit type conversion (cast notation)）</a></h1>

<p>
注意：C形式のキャストには様々な問題があるので、使ってはならない。
</p>

<pre>
( 型名 ) 式
</pre>


<p>
これは、悪名高いC形式のキャストである。
</p>

<pre>
int main()
{
    int i = 0 ;
    double * ptr = (double *) &amp;i ;
}
</pre>

<p>
C形式のキャストは、static_castとreinterpret_castとconst_castを組み合わせた働きをする。組み合わせは、以下の順序で決定される。
</p>

<ol>
<li>const_cast</li>
<li>static_cast</li>
<li>static_castとconst_cast</li>
<li>reinterpret_cast</li>
<li>reinterpret_castとconst_cast</li>
</ol>

<p>
上から下に評価していき、変換できる組み合わせが見つかったところで、そのキャストを使って変換する。
</p>

<p>
ただし、C形式のキャストでは、static_castに特別な変更を三つ加える。クラスのアクセス指定を無視できる機能である。
</p>

<section>
<h1>
派生クラスへのポインターやリファレンスから、基本クラスへのポインターやリファレンスに変換できる。文字通り変換できる。アクセス指定などは考慮されない。
</h1>

<pre>
struct Base { } ;
struct Derived : private Base { } ;

int main()
{
    Derived d ;

    Base &amp; ref1 = (Base &amp;) d ; // OK
    Base &amp; ref2 = static_cast&lt;Base &amp;&gt;(d) ; // ill-formed
}
</pre>

<p>
このため、publicではない基本クラスにアクセスできてしまう。
</p>
</section>

<section>
<h1>
派生クラスのメンバーへのポインターから、曖昧ではない非virtualな基本クラスのメンバーへのポインターに変換できる。文字通り変換できる。アクセス指定などは考慮されない。
</h1>

<pre>
struct Base { } ;
struct Derived : private Base { int x ; } ;

int main()
{
    int Base::* ptr1 = (int Base::*) &amp;Derived::x ; // OK
    int Base::* ptr2 = static_cast&lt;int Base::*&gt;(&amp;Derived::x) ; // ill-formed
}
</pre>

<p>
これも、アクセス指定を無視できてしまう。
</p>
</section>

<section>
<h1>
曖昧ではなく非virtualな基本クラスのポインターやリファレンスあるいはメンバーへのポインターは、派生クラスのポインターやリファレンスあるいはメンバーへのポインターに変換できる。文字通り変換できる。アクセス指定などは考慮されない。
</h1>

<pre>
struct Base { int x ; } ;
struct Derived : private Base { } ;

int main()
{
    Derived d ;

    d.x = 0 ; // ill-formed. アクセス指定のため

    int Derived::* ptr = (int Derived::*) &amp;Base::x ; // well-formed.
    d.*ptr = 0 ; // well-formed. C形式のキャストを使ったため、アクセス指定を無視できている
}
</pre>
</section>

<p>
C形式のキャストでしかできないキャストとは、クラスのアクセス指定を無視し、しかもクラス階層のナビゲーションを行うキャストのことである。
</p>

<p>
これらのキャストは、reinterpret_castでもできる。ただし、reinterpret_castは、クラス階層のナビゲーションを行わないので、正しく動かない。static_castは、クラス階層のナビゲーションを行うので、正しく動く。
</p>

<p>
アクセス指定を無視できるキャストをしなければならない場合というのは、現実には存在しないはずである。アクセス指定を無視するぐらいならば、最初からpublicにしておけばいい。
</p>

<p>
reinterpret_castは必要である。C++が必要とされる環境では、ポインターの内部的な値を、そのまま別の型のポインターとして使わなければならない場合も存在する。また、既存のCのコードとの互換性のため、const_castも残念ながら必要である。しかし、アクセス指定は、C++に新しく追加された概念であるので、互換性の問題も存在しないし、また、アクセス指定を無視しなければならない場合というのも、全く考えられない。従って、アクセス指定を無視できるという理由で、C形式のキャストを使ってはならない。
</p>

<p>
そもそも、C形式のキャストは根本的に邪悪であるので、使ってはならない。C形式のキャストの問題点は、できることが多すぎるということだ。安全なキャストも、危険なキャストも、全く同じ文法で行うことができる。C++では、この問題を解決するために、キャストを三つに分けた。static_cast、reinterpret_cast、const_castである。C++では、この新しい形式のキャストを使うべきである。以下にその概要と簡単な使い分けをまとめる。
</p>

<p>
<a href="#expr.static.cast">static_cast</a>は、ほとんどが安全なキャストである。static_castは、型変換を安全にするため、値を変えることもある。値を変更するので、static_castは、クラス階層のナビゲーションを行うことができる。派生クラスと基本クラスとの間のポインターの型変換は、ポインターの内部的な値が変わる可能性があるからだ。ポインターの値は、もとより実装依存であるが、最も多くの環境で再現できるコードは、複数の基本クラスを使うものだ。
</p>

<pre>
struct Base1 { int x ; } ;
struct Base2 { int x ; } ;

struct Derived : Base1, Base2 { } ;


int main()
{
    Derived d ;
    Derived * ptr = &amp;d ;

    // 基本クラスへのキャスト
    Base1 * base1 = static_cast&lt;Base1 *&gt;( ptr ) ;
    Base2 * base2 = static_cast&lt;Base2 *&gt;( ptr ) ;

    // 派生クラスへのキャスト
    Derived * d1 = static_cast&lt;Derived *&gt;( base1 ) ;
    Derived * d2 = static_cast&lt;Derived *&gt;( base2 ) ;


    // 派生クラスのポインターの値
    std::printf( "Derived *: %p\n", ptr ) ;

    // 基本クラスのポインターの値は同じか？
    std::printf( "Base1 *: %p\n", base1 ) ;
    std::printf( "Base2 *: %p\n", base2 ) ;

    // 派生クラスに戻した場合はどうか？
    std::printf( "from Base1 * to Derived *: %p\n", d1 ) ;
    std::printf( "from Base1 * to Derived *: %p\n", d2 ) ;
}
</pre>

<p>
複数の基本クラスの場合、基本クラスのサブオブジェクトが複数あるので、派生クラスと基本クラスのポインターの間で、同じ値を使うことができない。従って、基本クラスへのポインターにキャストするには、ストレージ上の、その基本クラスのサブオブジェクトを指すポインターを返さなければならない。また、派生クラスへのポインターにキャストするには、値を戻さなければならない。
</p>

<p>
このため、クラス階層のナビゲーションには、static_castかdynamic_castを用いなければならない。
</p>

<p>
<a href="#expr.reinterpret.cast">reinterpret_cast</a>は、危険で愚直なキャストである。reinterpret_castは、値を変えない。ただ、その値の型だけを変更する。reinterpret_castは、クラス階層のナビゲーションができない。
</p>

<p>
<a href="#expr.const.cast">const_cast</a>は、CV修飾子を外すキャストである。
</p>

<p>
もし、どのキャストを使うべきなのか判断できない場合は、まずstatic_castを使っておけば問題はない。もし、static_castが失敗した場合、本当にそのキャストは安全なのかということを確かめてから、reinterpret_castを使うべきである。const_castは、既存のCのコードの利用以外に使ってはならない。
</p>
</article>

<article>
<h1 id="expr.mptr.oper"><a href="#expr.mptr.oper">メンバーへのポインター演算子（Pointer-to-member operators）</a></h1>

<pre>
式 .* 式
式 -&gt;* 式
</pre>

<p>
メンバーへのポインター演算子は、「左から右」に評価される。
</p>

<p>
メンバーへのポインター演算子は、クラスのメンバーへのポインターを使って、クラスのオブジェクトのメンバーにアクセスするための演算子である。クラスのメンバーへのポインターを参照するためには、参照するクラスのオブジェクトが必要である。
</p>

<p>
.*演算子の第一オペランドには、クラスのオブジェクトを指定する。-&gt;*演算子の第一オペランドには、クラスへのポインターを指定する。第二オペランドには、クラスのメンバーへのポインターを指定する。
</p>

<pre>
struct C
{
    int member ;
} ;

int main()
{
    int C::* mem_ptr = &amp;C::member ;

    C c ;
    c.*mem_ptr = 0 ;

    C * ptr = &amp;c ;
    ptr-&gt;*mem_ptr = 0 ;
}
</pre>


<p>
メンバー関数の呼び出しの際は、演算子の優先順位に気をつけなければならない。
</p>

<pre>
struct C
{
    void member() {} 
} ;

int main()
{
    void (C::* mem_ptr)() = &amp;C::member ;

    C c ;
    (c.*mem_ptr)() ;

    C * ptr = &amp;c ;
    (ptr-&gt;*mem_ptr)() ;
}
</pre>

<p>
なぜならば、メンバーへのポインター演算子の式より、関数呼び出し式の優先順位の方が高いので、c.*mem_ptr()という式は、c.*( mem_ptr() )という式に解釈されてしまう。これは、mem_ptrという名前に対して、関数呼び出し式を適用した後、その結果を、クラスのメンバーへのポインターとして使う式である。このように解釈されることを避けるために、括弧式を使わなければならない。
</p>

<p>
その他の細かいルールについては、<a href="#expr.ref">クラスメンバーアクセス</a>と同じである。
</p>
</article>

<article>
<h1 id="expr.mul"><a href="#expr.mul">乗除算の演算子（Multiplicative operators）</a></h1>

<pre>
式 * 式
式 / 式
式 % 式
</pre>

<p>
乗除算の演算子は、「左から右」に評価される
</p>

<p>
*演算子と/演算子のオペランドは、数値型かunscoped enum型でなければならない。%演算子のオペランドは、整数型かunscoped enum型でなければならない。オペランドには、通常通り数値に関する標準型変換が適用される。<a href="#expr">式</a>を参照。
</p>

<p>
*演算子は、乗算を意味する。
</p>

<p>
/演算子は、除算を意味する。%演算子は、第一オペランドを第二オペランドで割った余りを意味する。第二オペランドの値が0の場合の挙動は未定義である。/演算子の結果の型が整数の場合、小数部分は切り捨てられる。
</p>

<pre>
int main()
{
    2 * 3 ; // 6
    10 / 5 ; // 2
    3 % 2 ; // 1

    3 / 2 ; // 結果は整数型、小数部分が切り捨てられるので、結果は1

    3.0 / 2.0 ; // 結果は浮動小数点数型の1.5
}
</pre>

<p>
以下は間違っている例である。
</p>

<pre>
// このコードは間違っている例
int main()
{
    // ゼロ除算
    1 / 0 ;

    // %演算子のオペランドに浮動小数点数型は使えない
    3.0 % 2.0 ;
}
</pre>
</article>

<article>
<h1 id="expr.add"><a href="#expr.add">加減算の演算子（Additive operators）</a></h1>

<pre>
式 + 式
式 - 式
</pre>

<p>
加減算の演算子は、「左から右」に評価される。
</p>

<section>
<h1>両方のオペランドが数値型の場合</h1>
<p>
+演算子は、加算を意味する。-演算子は、減算を意味する。-演算子の減算とは、第二オペランドの値を第一オペランドから引くことである。結果の型には、通常通り数値型に関する標準型変換が行われる。
</p>

<pre>
int main()
{
    1 + 1 ; // 2
    1 - 1 ; // 0
}
</pre>
</section>

<section>
<h1>オペランドがポインター型の場合</h1>

<p>
まず、ポインターの型は、完全に定義されたオブジェクトでなければならない。ポインターは、配列の要素を指し示しているものとみなされる。たとえ実際には配列の要素を差していないとしても、配列の要素を指しているものとみなされる。
</p>

<p>
+演算子の片方のオペランドがポインター型の場合、もう片方は、整数型でなければならない。-演算子は、両方のオペランドが同じポインター型か、左オペランドがポインター型で右オペランドが整数型でなければならない。
</p>

<pre>
int main()
{
    int array[3] ;
    int * ptr = &amp;array[1] ;

    // OK
    ptr + 1 ;
    1 + ptr ;
    ptr + (-1) ;
    (-1) + ptr ;
    ptr - ptr ;
    ptr - 1 ;
    ptr - (-1) ;

    // エラー
    ptr + ptr ; // +演算子の両オペランドがポインターとなっている
    1 - ptr ; // -演算子の左オペランドが整数で右オペランドがポインターとなっている
}
</pre>

<p>
ポインターと整数の加減算の結果の型は、ポインターの型である。結果の値は、ポインターが指す要素に対する配列中の添字に、整数を加減算した要素を指すものとなる。もし、ポインターが配列の添字でi番目の要素を指し示している場合、このポインターに整数nを加算することは、i + n番目の要素を指し示すことになる。同様にして、整数nを減算することは、i - n番目の要素を指し示すことになる。
</p>

<pre>
int main()
{
    int array[10] ;
    int * ptr = &amp;array[5] ;

    ptr + 2 ; // &amp;array[5 + 2]と同じ
    ptr - 2 ; // &amp;array[5 - 2]と同じ
}
</pre>

<p>
もし、ポインターが、配列の最後の要素を指している場合、これに1を加えると、結果のポインターは配列の最後の要素のひとつ後ろを指すことになる。ポインターが配列の最後の要素のひとつ後ろを指している場合、これから1を引くと、結果のポインターは配列の最後の要素を指すことになる。
</p>

<pre>
int main()
{
    int array[10] ;
    // 配列の最後の要素を指す
    int * ptr = &amp;array[9] ;

    // 配列の最後の要素のひとつ後ろを指す
    int * one_past_the_last = ptr + 1 ;
    // 配列の最後の要素を指す
    int * last = one_past_the_last - 1 ;
}
</pre>

<p>
ポインター同士を減算した場合、結果は、ポインターの指す配列の添字の差になる。ポインターPが配列の添字でi番目の要素を差しており、ポインターQが配列の添字でj番目の要素を指している場合、P - Qは、i - jとなる。配列の添字は、0から始まることに注意。両方のポインターが同じ配列上の要素を差していない場合、挙動は未定義である。
</p>

<pre>
int main()
{
    int array[10] ;
    int * P = &amp;array[2] ;
    int * Q = &amp;array[7] ;

    P - Q ; // 2 - 7 = -5
    Q - P ; // 7 - 2 = 5
}
</pre>

<p>
ポインター同士の減算の結果の型は、実装依存であるが、&lt;cstddef&gt;ヘッダーで定義されている、std::ptrdiff_tと同じ型になる。
</p>

<p>
0という値が、ポインターに足し引きされた場合、結果は、そのポインターの値になる。
</p>

<pre>
void f( int * ptr )
{
    ptr == ptr + 0 ; // true
    ptr == ptr - 0 ; // true
}
</pre>
</section>
</article>

<article>
<h1 id="expr.shift"><a href="#expr.shift">シフト演算子（Shift operators）</a></h1>

<pre>
式 &lt;&lt; 式
式 &gt;&gt; 式
</pre>

<p>
シフト演算子のオペランドは、整数型かunscoped enum型でなければならない。オペランドには、整数のプロモーションが行われる。結果の型は、整数のプロモーションが行われた後のオペランドの型になる。
</p>

<p>
左シフト、E1 &lt;&lt; E2の結果は、E1をE2ビット、左にシフトしたものとなる。シフトされた後のビットは、0で埋められる。もし、E1の型がunsignedならば、結果の値は、E1 × 2<sup>E2</sup>を、E1の最大値+1で剰余したものとなる。
</p>

<pre>
// コメント内の値は2進数である。
int main()
{
    // 1101
    unsigned int bits = 9 ;

    bits &lt;&lt; 1 ; // 11010
    bits &lt;&lt; 2 ; // 110100
}
</pre>

<p>
E1の型がsignedの場合、E1が負数でなく、E1 × 2<sup>E2</sup>が表現可能であれば、その値になる。その他の場合は未定義である。これは、signedな整数型の内部表現が2の補数であるとは保証していないので、このようになっている。
</p>


<pre>
// コメント内の値は2進数である
int main()
{
    // 1101
    int bits = 9 ;

    bits &lt;&lt; 1 ; // 11010
    bits &lt;&lt; 2 ; // 110100

    -1 &lt;&lt; 1 ; // 結果は未定義
}
</pre>

<p>
右シフト、E1 &gt;&gt; E2の結果は、E1をE2ビット、右にシフトしたものとなる。もし、E1の型がunsignedか、signedで正の数ならば、結果の値は、E1 ÷ 2<sup>E2</sup>の整数部分になる。
</p>

<pre>
// コメント内の値は2進数である
int main()
{
    // 1101
    unsigned int value = 9 ;

    value &gt;&gt; 1 ; // 110
    value &gt;&gt; 2 ; // 11

    int signed_value = 9 ;

    signed_value &gt;&gt; 1 ; // 110
    signed_value &gt;&gt; 2 ; // 11
}
</pre>

<p>
E1の型がsignedで、値が負数の場合、挙動は未定義である。
</p>

<pre>
int main()
{
    -1 >> 1 ; // 結果は未定義
}
</pre>


<p>
右オペランドの値が負数であったり、整数のプローモーション後の左オペランドのビット数以上の場合の挙動は未定義である。
</p>

<pre>
// この環境では、1バイトは8ビット
// sizeof(unsigned int)は2とする。
// すなわち、この環境では、unsigned intは16ビットとなる。
int main()
{
    unsigned int value = 1 ;
    value &lt;&lt; -1 ; // 未定義
    value &gt;&gt; -1 ; // 未定義

    value &lt;&lt; 16 ; // 未定義
    value &gt;&gt; 16 ; // 未定義

    value &lt;&lt; 17 ; // 未定義
    value &gt;&gt; 17 ; // 未定義
}
</pre>

<p>
シフト演算には、未定義の部分が非常に多い。ただし、多くの現実の環境では、何らかの具体的な意味が定義されていて、時として、そのような未定義の挙動に依存したコードを書かなければならない場合がある。その場合、特定の環境に依存したコードだという正しい認識を持たなければならない。
</p>
</article>

<article>
<h1 id="expr.rel"><a href="#expr.rel">関係演算子（Relational operators）</a></h1>

<pre>
式 &lt; 式
式 &gt; 式
式 &lt;= 式
式 &gt;= 式
</pre>

<p>
関係演算子は「左から右」に評価される。
</p>

<p>
関係演算子のオペランドには、数値型、enum型、ポインター型を使うことができる。各演算子の意味は、以下のようになっている。
</p>

<dl>
<dt>A &lt; B</dt>
<dd>AはBより小さい</dd>
<dt>A &gt; B</dt>
<dd>AはBより大きい</dd>
<dt>A &lt;= B</dt>
<dd>AはBより小さいか、等しい</dd>
<dt>A &gt;= B</dt>
<dd>AはBより大きいか、等しい</dd>
</dl>

<p>
結果の型はboolとなる。両オペランドが数値型かenum型の場合、不等号の関係が正しければtrueを、そうでなければfalseを返す。
</p>

<pre>
void f( int a, int b )
{
    a &lt; b ;
    a &gt; b ;
    a &lt;= b ;
    a &gt;= b ;
}
</pre>

<p>
式の結果の型はboolである。
</p>

<p>
ポインター同士の比較に関しては、未規定な部分が多い。ここでは、規格により保証されていることだけを説明する。
</p>

<p>
二つのポインター、pとqが、同じオブジェクトか関数を指している場合、p&lt;=qとp&gt;=qhはtrueとなりp&lt;qとp&gt;qはfalseとなる。
</p>

<pre>
int main()
{
    int object = 0 ;
    int * p = &amp;object ;
    int * q = &amp;object ;

    p &lt;= q ; // true
    p &gt;= q ; // true

    p &lt; q ; // false
    p &gt; q ; // false
}
</pre>

<p>
二つのポインター、pとqが、同じ配列の要素を指している場合、添字の大きい要素の方が、より大きいと評価される。
</p>

<pre>
int main()
{
    int array[2] ;

    int * p = &amp;array[0] ;
    int * q = &amp;array[1] ;

    p &lt; q ; // true
    p &gt; q ; // false

    p &lt;= q ; // true
    p &gt;= q ; // false
}
</pre>

<p>
もし、ポインターが配列の範囲外を指していたとしても、添字の大きい方が、より大きいと評価される。
</p>

<pre>
int main()
{
    int array[2] ;

    int * p = &amp;array[0] ;
    int * q = &amp;array[10] ; // 配列の範囲外

    p &lt; q ; // 必ずtrue
}
</pre>


<p>
二つのポインター、pとqが、unionの同じオブジェクトの非staticなデータメンバーを指している場合、等しいと評価される。
</p>

<pre>
union Object
{
    int x ;
    int y ;
} ;

int main()
{
    Object object ;
    int * p = &amp;object.x ;
    int * q = &amp;object.y ;

    p &lt; q ; // false
    p &gt; q ; // false

    p &lt;= q ; // true
    p &gt;= q ; // true

    p == q ; // true
}
</pre>

<p>
二つのポインター、pとqが、同じオブジェクトの非staticで同じアクセス指定のデータメンバーを指している場合、後に宣言されているデータメンバーを指しているポインターの方が、より大きいと評価される。
</p>

<pre>
struct Object
{
    int x ;
    int y ;
} ;

int main()
{
    Object object ;
    // 同じオブジェクトで、同じアクセス指定のデータメンバーを指す
    int * p = &amp;object.x ;
    int * q = &amp;object.y ;

    // qはpより大きい

    p &lt; q ; // true
    p &gt; q ; // false

    p &lt;= q ; // true
    p &gt;= q ; // false
}
</pre>

<p>
アクセス指定が違うメンバーのポインターを比較した際の挙動は、未規定である。
</p>

<pre>
struct Object
{
private :
    int x ;
public :
    int y ;
} ;

int main()
{
    Object object ;
    int * p = &amp;object.x ;
    int * q = &amp;object.y ;

    p &lt; q ; // 結果は未規定
}
</pre>

<p>
voidへのポインター型は、比較することができる。また、片方のオペランドがvoidへのポインター型で、もう片方が別のポインター型である場合、もう片方のオペランドが、標準型変換によってvoidへのポインター型に変換されるので、比較することができる。もし、両方のポインターが、同じアドレスであった場合かnullポインターの場合は、等しいと評価される。それ以外は、未規定である。
</p>

<pre>
int main()
{
    int object = 0 ;

    int * ptr = &amp;object ;
    void * p = ptr ;
    void * q = ptr ;

    p &lt; q ; // false
    p &gt; q ; // false

    p &lt;= q ; // true
    p &gt;= q ; // true

    // 標準型変換によって、別のポインター型とも比較できる
    p &lt;= ptr ; // true    
}
</pre>


<p>
これ以外の比較の結果は、すべて未規定となっている。未定義ではなく、未規定なので、実装によっては、意味のある結果を返すこともある。しかし、実装に依存する挙動なので、移植性に欠ける。
</p>
</article>

<article>
<h1 id="expr.eq"><a href="#expr.eq">等価演算子（Equality operators）</a></h1>

<pre>
式 == 式
式 != 式
</pre>

<p>
==演算子（等しい）と、!=演算子（等しくない）は、<a href="#expr.rel">関係演算子</a>とオペランドや結果の型、評価の方法は同じである。ただし比較の意味は、「等しい」か、「等しくない」かである。
</p>

<pre>
int main()
{
    1 == 1 ; // true
    1 != 1 ; // false

    1 == 2 ; // false
    1 != 2 ; // true
}
</pre>

<p>
同じ型のポインターの場合、ともにアドレスが同じか、ともにnullポインターの場合、trueと評価される。
</p>


<p>
==演算子は、代入演算子である=演算子と間違えやすいので、注意しなければならない。
</p>

<pre>
void f( int x )
{
    if ( x = 1 ) // 間違い
    {
        // 処理
    } else {
        // 処理
    }
}
</pre>

<p>
この例では、if文の条件式の結果は、代入式の結果となってしまう。それは、1であるので、このif文は常にtrueであると評価されてしまう。
</p>
</article>

<article>
<h1 id="expr.bit.and"><a href="#expr.bit.and">ビット列論理積演算子（Bitwise AND operator）</a></h1>

<pre>
式 &amp; 式
</pre>

<p>
ビット列論理積演算子は、両オペランドの各ビットごとの論理積（AND）を返す。オペランドは整数型か、unscoped enum型でなければならない。
</p>
</article>

<article>
<h1 id="expr.xor"><a href="#expr.xor">ビット列排他的論理和演算子（Bitwise exclusive OR operator）</a></h1>

<pre>
式 ^ 式
</pre>

<p>
ビット列排他的論理和演算子は、両オペランドの各ビットごとの排他的論理和（exclusive OR）を返す。オペランドは整数型か、unscoped enum型でなければならない。
</p>
</article>

<article>
<h1 id="expr.or"><a href="#expr.or">ビット列論理和演算子（Bitwise inclusive OR operator）</a></h1>

<pre>
式 | 式
</pre>

<p>
ビット列論理和演算子は、両オペランドの各ビットごとの論理和（inclusive OR）を返す。オペランドは整数型か、unscoped enum型でなければならない。
</p>
</article>

<article>
<h1 id="expr.log.and"><a href="#expr.log.and">論理積演算子（Logical AND operator）</a></h1>

<pre>
式 &amp;&amp; 式
</pre>

<p>
&amp;&amp;演算子は「左から右」に評価される。
</p>

<p>
論理積演算子は、オペランドの論理積を返す演算子である。両オペランドはboolに変換される。結果の型はboolである。両方のオペランドがtrueであれば、結果はtrue。それ以外はfalseとなる。
</p>

<pre>
true &amp;&amp; true ; // true
true &amp;&amp; false ; // false
false &amp;&amp; true ; // false
false &amp;&amp; false ; // false
</pre>

<p>
第一オペランドを評価した結果がfalseの場合、第二オペランドは評価されない。なぜならば、第一オペランドがfalseであれば、第二オペランドを評価するまでもなく、結果はfalseであると決定できるからである。
</p>

<pre>
bool f() { return false ; }
bool g() { return true ; }

int main()
{
    // g()は呼ばれない。結果はfalse
    f() &amp;&amp; g() ;
}
</pre>

<p>
この例では、第一オペランドである関数fの呼び出しはfalseを返すので、第二オペランドの関数gの呼び出しが評価されることはない。つまり、関数gは呼ばれない。
</p>

<p>
第二オペランドが評価される時、第一オペランドの評価によって生じた値の計算や副作用は、すべて行われている。
</p>

<pre>
int main()
{
    int value = 0 ;

    ++value // 値は1になるので、trueと評価される
        &amp;&amp;
    value ; // 値はすでに1となっているので、trueと評価される
}
</pre>
</article>

<article>
<h1 id="expr.log.or"><a href="#expr.log.or">論理和演算子（Logical OR operator）</a></h1>

<pre>
式 || 式
</pre>

<p>
||演算子は、「左から右」に評価される。
</p>

<p>
論理和演算子は、オペランドの論理和を返す演算子である。両オペランドはboolに変換される。結果の型はboolである。オペランドが片方でもtrueと評価される場合、結果はtrueとなる。両オペランドがfalseの場合に、結果はfalseとなる。
</p>

<pre>
int main()
{
    true || true ; // true
    true || false ; // true
    false || true ; // true
    false || false ; // false
}
</pre>

<p>
第一オペランドを評価した結果がtrueの場合、第二オペランドは評価されない。なぜならば、第一オペランドがtrueであれば、第二オペランドを評価するまでもなく、結果はtrueとなるからである。
</p>

<pre>
bool f() { return true ; }
bool g() { }

int main()
{
    // g()は呼ばれない。結果はtrue
    f() &amp;&amp; g() ;
}
</pre>

<p>
論理積と同じように、第二オペランドが評価される場合、、第一オペランドの評価によって生じた値の計算や副作用は、すべて行われている。
</p>
</article>

<article>
<h1 id="expr.cond"><a href="#expr.cond">条件演算子（Conditional operator）</a></h1>

<pre>
式 ? 式 : 代入式
</pre>

<p>
条件演算子は「左から右」に評価される。
</p>

<p>
条件演算子は、三つのオペランドを取る。C++には他に三つのオペランドを取る演算子がないことから、三項演算子といえば、条件演算子の代名詞のように使われている。しかし、正式名称は条件式であり、演算子の名称は条件演算子である。
</p>

<p>
条件演算子の第一オペランドはboolに変換される。値がtrueであれば、第二オペランドの式が評価され、その結果が返される。値がfalseであれば、第三オペランドの式が評価され、その結果が返される。第二オペランドと第三オペランドは、どちらか片方いしか評価されない。
</p>

<pre>
bool cond() ;
int e1() ;
int e2() ;

int main()
{
    true ? 1 : 2 ; // 1
    false ? 1 : 2 ; // 2

    // 関数condの戻り値によって、関数e1、あるいはe2が呼ばれ、その戻り値が返される。
    // e1とe2は、どちらか片方しか呼ばれない。
    cond() ? e1() : e2() ;
}
</pre>

<p>
実は、条件演算子は見た目ほど簡単ではない。特に、結果の型をどのようにして決定するかということが、非常に難しい。ここでは、結果の型を決定する完全な詳細は説明しないが、特に重要だと思われる事を取りあげる。
</p>

<p>
条件演算子の第二第三オペランドには、結果がvoid型となる式を使うことができる。
</p>

<pre>
void f() {}

int main()
{
    true ? f() : f() ;

    int * ptr = new int ;
    true ? delete ptr : delete ptr ;

    true ? throw 0 : throw 0 ;
}
</pre>

<p>
片方のオペランドがvoidで、もう片方がvoidではない場合、エラーである。
</p>

<pre>
void f() {}
int main()
{
    true ? 0 : f() ; // エラー
    true ? f() : 0 ; // エラー
}
</pre>

<p>
ただし、片方のオペランドがthrow式の場合に限り、もう片方のオペランドに、voidではない式を使うことができる。もう片方のオペランドがvoid型の場合はエラーとなる。結果はprvalueの値で、型はvoidではない式の型になる。
</p>

<pre>
void f() {}

int main()
{
    // OK
    // xに0を代入する
    int x = true ? 0 : throw 0 ;

    // エラー
    // 戻り値に123を代入しようとしているが、prvalueには代入できない
    (true ? x : throw 0) = 123 ;

    true ? throw 0 : f() ; // エラー
}
</pre>

<p>
両オペランドが、ともに同じ値カテゴリーで、同じ型の場合は、条件演算子の結果は、その値カテゴリーと型になる。
</p>

<pre>
int f() { return 0 ; }

int main()
{
    int x = 0 ;

    // 両オペランドとも、lvalueのint型
    // 結果はlvalueのint
    ( true ? x : x ) = 0 ; // lvalueなので代入も可能

    // 両オペランドとも、xvalueのint型
    // 結果はxvalueのint
    true ? std::move(x) : std::move(x) ;

    // 両オペランドとも、prvalueのint型
    // 結果はprvalueのint
    true ? f() : f() ;
}
</pre>

<p>
もし、オペランドの値カテゴリーや型が違う場合、暗黙の型変換によって、お互いの型と値カテゴリーを一致させようという試みがなされる。この変換の詳細は、非常に複雑で、通常は意識する必要はないため、本書では省略する。
</p>
</article>

<article>
<h1 id="expr.ass"><a href="#expr.ass">代入と複合代入演算子（Assignment and compound assignment operators）</a></h1>

<pre>
式 <i>代入演算子</i> 式

<i>代入演算子</i>:以下のうちどれか
= *= /= %= += -= &gt;&gt;= &lt;&lt;= &amp;= ^= |=
</pre>

<p>
代入演算子（=）と、複合代入演算子は、「右から左」に評価される。
</p>

<p>
代入演算子は、左側のオペランドに、右側のオペランドの値を代入する。左側のオペランドは変更可能なlvalueでなければならない。結果として、左型のオペランドのlvalueを返す。
</p>

<pre>
int main()
{
    int x ;
    x = 0 ;
}
</pre>

<p>
初期化と混同しないように注意。
</p>

<pre>
int main()
{
    int x = 0 ; // これは初期化
    x = 0 ; // これは代入
}
</pre>

<p>
=を代入演算子といい、その他の演算子を、複合代入演算子という。
</p>

<p>
クラスの代入に関する詳細は、<a href="#class.copy">クラスオブジェクトのコピーとムーブ</a>や、オーバーロードの<a href="#over.ass">代入</a>を参照。
</p>

<p>
複合代入演算子の式、E1 op = E2は、E1 = E1 op E2と同じである。ただし、E1という式は、一度しか評価されない。opには、任意の複合代入演算子が入る。
</p>

<pre>
int main()
{
    int x = 0 ;

    x += 1 ; // x = x + 1と同じ
    x *= 2 ; // x = x * 2と同じ
}
</pre>

<p>
右側のオペランドには、初期化リストを使うことができる。
</p>

<p>
左側のオペランドがスカラー型の場合、ある型Tの変数をxとすると、x = {v}という式は、x = T(v)という式と同じ意味になる。ただし、初期化リストなので、縮小変換は禁止されている。x = {}という式は、x = T()という式と同じ意味になる。
</p>

<pre>
int main()
{
    int x ;
    x = {1} ; // x = int(1) と同じ
    x = {} ; // x = int()と同じ
    short s ;
    s = {x} ; // エラー、縮小変換は禁止されている。
}
</pre>

<p>
それ以外の場合は、初期化リストを実引数として、ユーザー定義の代入演算子が呼び出される。
</p>

<pre>
struct C
{
    C(){}
    C( std::initializer_list&lt;int&gt; ) {}
} ;

int main()
{
    C c ;
    c = { 1, 2, 3 } ;
}
</pre>
</article>

<article>
<h1 id="expr.comma"><a href="#expr.comma">コンマ演算子（Comma operator）</a></h1>

<pre>
式 , 式
</pre>

<p>
コンマ演算子は、「左から右」に評価される。
</p>

<p>
コンマ演算子は、まず左のオペランドの式が評価され、次に、右のオペランドの式が評価される。左のオペランドの式を評価した結果は破棄され、右のオペランドの結果が、コンマ演算子の結果として、そのまま返される。結果の型や値、値カテゴリーは、右のオペランドの式を評価した結果と全くおなじになる。
</p>

<pre>
int main()
{
    1, 2 ; // 2
    1, 2, 3, 4, 5 ; // 5
}
</pre>

<p>
右のオペランドの式が評価される前に、左のオペランドの式の値計算や副作用は、すでに行われている。
</p>

<pre>
int f() ;
int g() ;

int main()
{
    int i = 0 ;
    // 左のオペランドのiは、すでにインクリメントされている。
    ++i, i ;
    // 関数gが呼ばれる前に、関数fはすでに呼ばれ終わっている。
    f() , g() ;    
}
</pre>

<p>
コンマが特別な意味を持つ場面では、コンマ演算子を使うには、明示的に括弧で囲まなければならない。コンマが特別な意味を持つ場面には、例えば、関数の実引数リストや、初期化リストなどがある。
</p>

<pre>
void f(int, int, int) {}
int main()
{
    int x ;
    // 括弧が必要
    f( 1, (x=0, x), 2) ;
}
</pre>

<p>
この例では、関数fは三つの引数を取る。二つめの引数は、括弧式に囲まれたコンマ演算子の式である。これは変数xに0を代入した後、そのxを引数として渡している。
</p>
</article>

<article>
<h1 id="expr.const"><a href="#expr.const">定数式（Constant expressions）</a></h1>

<p>
定数式（constant expression）とは、値がコンパイル時に決定できる式のことである。定数式かどうかということは、C++のいくつかの場面で、重要になってくる。例えば、配列を宣言する時、要素数は定数式でなければならない。
</p>

<pre>
int main()
{
    // 整数リテラルは定数式
    int a[5] ;

    // const修飾されていて、初期化式が定数式であるオブジェクトは定数式
    int const n = 5 ;
    int b[n] ; // OK

    int m = 5 ; // これは定数式ではない
    int c[m] ; // エラー
}
</pre>

<h1>定数式ではない式</h1>
<p>
以下に列挙する式は、定数式ではない式である。これらの式を含む式は、その値をコンパイル時に決定することができないので、定数式にはならない。
</p>

<p>
TODO: constant expressionとconstexpr specifierについては、まだ議論が多く、変更される可能性があるため、執筆を保留。
</p>
</article>
</article>

<article class="toplevel">
<h1 id="stmt.stmt"><a href="#stmt.stmt">文（Statements）</a></h1>

<article>
<h1 id="stmt.label"><a href="#stmt.label">ラベル文（Labeled statement）</a></h1>

<pre>
識別子 : 文
case 定数式 : 文
default : 文
</pre>

<p>
文にはラベルを付けることができる。ラベルとは、その文を指す識別子である。文にラベルを付けるための文を、ラベル文（label statement）という。ラベル文には、必ず後続する文が存在しなければならない。
</p>

<pre>
void f()
{
    label :
// エラー、ラベルに続く文がない
} // ブロックの終わり

void g()
{
// OK、ラベルに続く文がある
    label_1 :/* 式文 */ ;
    label_2 : {/* 複合文 */} ;
}
</pre>

<p>
識別子ラベル（identifier label）は、識別子を宣言する。この識別子は、goto文でしか使えない。
</p>

<pre>
int main()
{
label_1 : ;
label_2 : ;
label_3 : ;

    goto label_2 ;
} 
</pre>

<p>
ラベルの識別子のスコープは、宣言された関数内である。ラベルを再宣言することはできない。ラベルの識別子は、宣言する前にgoto文で使うことができる。
</p>

<pre>
// ラベルのスコープは、宣言された関数内
void f() { label_f : ; }
vopd g()
{
    goto label_f ; // エラー、この関数のスコープのラベルではない
}

// ラベルを再宣言することはできない
void h()
{
    label_h : ; // label_hの宣言
    label_h : ; // エラー、ラベルの再宣言はできない
}

// ラベルの識別子は、宣言する前にgoto文で使うことができる
void i()
{
// 識別子label_iは、この時点では、まだ宣言されていないが、使うことができる
    goto label_i ;
label_i ;
}
</pre>

<p>
ラベルの識別子は、独自の名前空間を持つので、他の識別子と混同されることはない。
</p>

<pre>
int main()
{
    identifier : ; // ラベルの識別子
    int identifier ; // 変数の識別子

    goto identifier ; // ラベルの識別子が使われる
    identifier = 0 ; // 変数の識別子が使われる
}
</pre>

<p>
caseラベルとdefaultラベルは、switch文の中でしか使うことができない。
</p>

<pre>
int main()
{
    switch(0)
    {
        case 0 : ;
        default : ; 
    }
}
</pre>
</article>

<article>
<h1 id="stmt.expr"><a href="#stmt.expr">式文（Expression statement）</a></h1>

<pre>
式<sub>opt</sub> ;
</pre>

<p>
式文（expression statement）とは、式を書く事のできる文である。文の多くは、この式文に該当する。式文は、セミコロン（;）を終端記号として用いる。式文は、書かれている式を評価する。
</p>

<pre>
int main()
{
    0 ; // 式は0
    1 + 1 ; // 式は1 + 1

    // これは式文ではなく、return文
    return 0 ; 
}
</pre>

<p>
式文は、式を省略することもできる。式を省略した式文を、null文という。
</p>

<pre>
    /* 式を省略*/ ; // null文

    ;;;; // null文が四つ
    ;;;;;;;; // null文が八つ
</pre>

<p>
null文は、評価すべき式がないので、何もしない文である。null文はたとえば、ブロックの終りにラベル文を書きたい場合や、for文やwhile文のようなループを、単に回したい場合などに、使うことができる。
</p>

<pre>
int main()
{
    // 単にループを回すだけのfor文
    for ( int i = 0 ; i != 10 ; ++i ) ;

label : ; // ラベル文には、後続する文が必要。
}
</pre>
</article>

<article>
<h1 id="stmt.block"><a href="#stmt.block">複合文、ブロック（Compound statement or block）</a></h1>

<pre>
{ ひとつ以上の文<sub>opt</sub> }
</pre>

<p>
複合文、またはブロックという文は、文をひとつしか書けない場所に、複数の文を書くことができる文である。
</p>

<pre>
void f( bool b )
{
    if ( b )
        /*ここにはひとつの文しかかけない*/ ;

    if ( b )
    {
        // いくらでも好きなだけ文を書くことができる。
    }
}
</pre>

<p>
複合文は、ブロックスコープを定義する。
</p>

<pre>
int main()
{// ブロックスコープ
    { // 新たなブロックスコープ
    }
}
</pre>
</article>

<article>
<h1 id="stmt.select"><a href="#stmt.select">選択文（Selection statements）</a></h1>
<p>
選択文は、複数あるフローのうち、どれかひとつを選ぶ文のことである。
</p>

<p>
もし、選択文の中の文が、複合文ではなかった場合、その文を複合文で囲んだ場合と同じになる。
</p>

<pre>
void f( bool b )
{
    if ( b )
        int x ;

    x = 0 ; // エラー、xは宣言されていない
}
</pre>

<p>
このコードは、以下のコードと同等であるため、if文の次の式文で、xという名前を見つけられない。
</p>

<pre>
void f( bool b )
{
    if ( b )
    { int x ; }

    x = 0 ; // エラー、xは宣言されていない
}
</pre>

<h1>条件について</h1>

<pre>
条件:
    式
    宣言
</pre>
<p>
条件には、式が宣言を書くことができる。条件は、if文やswitch文だけではなく、while文などでも使われる。
</p>

<pre>
void f()
{
    if ( true ) ;
    if ( int x = 1 ) ;
}
</pre>

<p>
条件に宣言を書くことができる理由は、コードを単純にするためである。
</p>

<pre>
// 何か処理をして結果を返す関数
int do_something() ;

int main()
{
    int result = do_something() ;
    if ( result )
    {
        // 処理
    }
}
</pre>

<p>
条件には宣言を書く事ができるため、以下のように書くことができる。
</p>



<pre>
if ( int result = do_something() )
</pre>

<article>
<h1 id="stmt.if"><a href="#stmt.if">if文（The if statement）</a></h1>

<pre>
if ( 条件 ) 文
if ( 条件 ) 文 else 文
</pre>

<p>
if文は、条件の値によって、実行すべき文を変える。
</p>

<p>
条件がtrueと評価された場合、一つ目の文が実行される。条件がfalseと評価された場合、elseに続く二つ目の文が有るのならば、二つ目の文が実行される
</p>

<pre>
int main()
{
    if ( true ) // 一つ目の文が実行される
        /*一つ目の文*/ ;

    if ( false ) // 一つ目の文は実行されない
        /*一つ目の文*/ ;

    if ( true ) // 一つ目の文が実行される
        /*一つ目の文*/ ;
    else
        /*二つ目の文*/ ;

    if ( false ) // 二つ目の文が実行される
        /*一つ目の文*/ ;
    else
        /*二つ目の文*/ ;
}
</pre>

<p>
elseは、近い方のif文に対応する。
</p>

<pre>
int main()
{
    if ( false ) // #1
        if ( true ) ;// #2

    else { } // #2のif文に対応するelse
}
</pre>

<p>
インデントに騙されてはいけない。インデントを正しく対応させると、以下のようになる。
</p>

<pre>
int main()
{
    if ( false ) // #1
        if ( true ) ;// #2
        else ; // #2のif文に対応するelse
}
</pre>

<p>
このため、elseのあるif文の中に、さらにif文をネストさせたい場合は、内側のif文にも、elseが必要である。
</p>

<pre>
int main()
{
    if ( false ) // #1
        if ( true ) ;// #2
        else ; // #2のif文に対応するelse
    else ; // #1のif文に対応するelse
}
</pre>

<p>
あるいは、ブロック文を使うという手もある。
</p>

<pre>
int main()
{
    if ( false ) // #1
    { if ( true ) ; }

    else ; // #1のif文に対応するelse
}
</pre>
</article>

<article>
<h1 id="stmt.switch"><a href="#stmt.switch">switch文（The switch statement）</a></h1>

<pre>
switch( 条件 ) 文 
</pre>

<p>
switch文は、条件の値によって、実行する文を選択する。
</p>

<p>
条件は、整数型かenum型、もしくは非explicitな変換関数を持つクラス型でなければならない。条件がクラス型の場合、整数型かenum型に型変換される。
</p>

<pre>
struct C
{
    operator int(){ return 0 ; }
} ;

int main()
{
    switch(1) ; // OK
    C c ;
    switch(c) ; // OK、C::operator int()が呼ばれる

    switch(1.0) ; // エラー、浮動小数点数型は指定できない

    switch( static_cast&lt;int&gt;(1.0) ) ; // OK
}
</pre>

<p>
switch文の中の文には、通常、複合文を指定する。複合文の中には、caseラベル文やdefaultラベル文を書く。
</p>

<pre>
switch(1)
{
    case 1 :
        /* 処理 */ ;
    break ;

    case 2 :
        /* 処理 */ ;
    break ;

    default :
        /* 処理 */ ;
}
</pre>

<p>
caseラベル文に指定する式は、整数の定数式でなければならない。また、同じswitch内で、caseラベル文の値が重複してはならない。
</p>

<p>
defaultラベル文は、switch文の中の文に、ひとつだけ書くことができる。
</p>

<p>
switch文が実行されると、まず条件が評価される。結果の値が、switch文の中にあるcaseラベルに対して、ひとつづつ比較される。もし、値が等しいcaseラベル文が見つかった場合、そのラベル分に実行が移る。
</p>

<pre>
void f( int const value )
{
    switch( value )
    {
        case 1 :
            std::cout &lt;&lt; "Good morning." &lt;&lt; std::endl ;
        break ;
        case 2 :
            std::cout &lt;&lt; "Good afternoon." &lt;&lt; std::endl ;
        break ;
        case 3 :
            std::cout &lt;&lt; "Good evening." &lt;&lt; std::endl ;
        break ;
    }
}

int main()
{
    f( 1 ) ; // Good morning.
    f( 2 ) ; // Good afternoon.
    f( 3 ) ; // Good evening.
}
</pre>

<p>
条件と値の等しいcaseラベルが見つからない場合で、defaultラベルがある場合、defaultラベルに実行が移る。
</p>

<pre>
void f( bool const value )
{
    switch( value )
    {
        case true :
            std::cout &lt;&lt; "true" &lt;&lt; std::endl ;
        break ;

        default :
            std::cout &lt;&lt; "false" &lt;&lt; std::endl ;
        break ;
    }
}

int main()
{
    f( true ) ; // true
    f( false ) ; // false
}
</pre>

<p>
条件と値の等しいcaseラベルが見つからず、defaultラベルもない場合、switch内の文は実行されない。
</p>

<pre>
int main()
{
    // switch内の文は実行されない
    switch( 0 )
    {
        case 999 :
            std::cout &lt;&lt; "hello" &lt;&lt; std::endl ;
        break ;
        case 123456 :
            std::cout &lt;&lt; "hello" &lt;&lt; std::endl ;
        break ;
    }
}
</pre>

<p>
caseラベルとdefaultラベル自体には、文の実行を変更する機能はない。
</p>

<pre>
void f( int const value )
{
    switch( value )
    {
        case 1 :
            std::cout &lt;&lt; "one" &lt;&lt; std::endl ;
        default :
            std::cout &lt;&lt; "default" &lt;&lt; std::endl ;
        case 2 :
            std::cout &lt;&lt; "two" &lt;&lt; std::endl ;
    }
}
</pre>

<p>
この場合、valueの値が1の場合、case 1のラベル文に続く文も、すべて実行されてしまう。また、valueの値が1でも2でもない場合、defaultラベル文に続くcase 2のラベル文も、実行されてしまう。このため、switch内の実行を切り上げたい時点で、<a href="#stmt.break">break文</a>を書かなければならない。break文を書き忘れたことによる、意図しない文の実行は、よくあることなので、注意が必要である。なお、このことは、逆に利用することもできる。
</p>

<pre>
void f( int const value )
{
    switch( value )
    {
        case 3 :
        case 5 :
        case 7 :
            /* 何らかの処理 */ ;
    }
}
</pre>

<p>
この例では、valueの値が3, 5, 7のいずれかの場合に、何らかの処理が実行される。
</p>
</article>

</article>

<article>
<h1 id="stmt.iter"><a href="#stmt.iter">繰り返し文（Iteration statements）</a></h1>
<p>
繰り返し文（Iteration statements）は、ループを書くための文である。
</p>

<p>
繰り返し文の中の文は、暗黙的に、ブロックスコープを定義する。このブロックスコープは、文の実行のループ一回ごとに、出入りする。例えば、
</p>

<pre>
while( true )
    int i ;
</pre>

<p>
という文は、以下のように書いたものとみなされる。
</p>

<pre>
while( true )
{ int i ; }
</pre>

<p>
従って、繰り返し文の中の変数は、ループが回されるごとに、生成、破棄されることになる。
</p>

<pre>
struct C
{
    C(){ std::cout &lt;&lt; "constructed." &lt;&lt; std::endl ; }
    ~C(){ std::cout &lt;&lt; "destructed." &lt;&lt; std::endl ; }
} ;

int main()
{
    while( true )
    { // 生成、破棄を繰り返す
        C c ;
    }
}
</pre>

<article>
<h1 id="stmt.while"><a href="#stmt.while">while文（The while statement）</a></h1>

<pre>
while ( 条件 ) 文
</pre>

<p>
while文は、条件の結果がfalseになるまで、文を繰り返し実行する。条件は、文の実行前に、繰り返し評価される。
</p>

<pre>
int main()
{
    // 一度も繰り返さない
    while ( false )
    {
        std::cout &lt;&lt; "hello" &lt;&lt; std::endl ; 
    }

    // 無限ループ
    while ( true )
    {
        std::cout &lt;&lt; "hello" &lt;&lt; std::endl ; 
    }

    // iが10になるまで繰り返す
    int i = 0 ;
    while ( i != 10 )
    {
        ++i ;
    }

}
</pre>

<p>
条件が宣言である場合、変数のスコープは、while文の宣言された場所から、while文の最後までである。条件の中で宣言された変数は、文の実行が繰り返されるたびに、生成、破棄される。
</p>

<pre>
while ( T t = x ) 文
</pre>

<p>
という文は、
</p>

<pre>
label:
{
    T t = x;
    if (t) {
        statement
        goto label;
    }
}
</pre>

<p>
と書くのに等しい。
</p>
</article>

<article>
<h1 id="stmt.do"><a href="#stmt.do">do文（The do statement）</a></h1>
<pre>
do 文 while ( 式 ) ;
</pre>

<p>
do文の式は、boolに変換される。boolに変換できない場合、エラーとなる。
</p>

<p>
do文は、式の結果がfalseになるまで、文が繰り返し実行される。ただし、式の評価は、文の実行の後に行われる。
</p>

<pre>
int main()
{
    // 一度だけ文を実行
    do {
        std::cout &lt;&lt; "hello" &lt;&lt; std::endl ; 
    } while ( false ) ;


    // 無限ループ
    do {
        std::cout &lt;&lt; "hello" &lt;&lt; std::endl ; 
    } while ( true ) ;
}
</pre>
</article>

<article>
<h1 id="stmt.for"><a href="#stmt.for">for文（The for statement）</a></h1>
<pre>
for ( for初期化文 条件<sub>opt</sub> ; 式<sub>opt</sub> ) 文

for初期化文:
    式文
    宣言
</pre>

<p>
for文は、for初期化文で、ループ前の初期化を書き、条件で、ループを実行するかどうかの判定を行い、文が実行されたあとに、そのつど式が評価される。
</p>

<p>
for文の実行では、まず、for初期化文が実行される。for初期化文は、式文か、変数の宣言を行うことができる。変数のスコープは、for文の最後までである。次に、文の実行の前に、条件が評価され、falseとなるまで文が繰り返し実行される。文の実行の後に、式が評価される。
</p>

<pre>
for ( for初期化文 条件 ; 式 ) 文
</pre>

<p>
は、以下のコードと同等である。
</p>

<pre>
{
    for初期化文
    while ( 条件 ) {
        文
        式 ;
    }
}
</pre>

<p>
ただし、文の中でcontinue文を使ったとしても、式は評価されるという違いがある。
</p>

<p>
for文は、while文でよく書かれるコードを書きやすくした構文である。例えば、while文を10回実行したい場合、
</p>

<pre>
int main()
{
    // カウンター用の変数の宣言
    int i = 0 ; 

    while ( i != 0 )
    {
        // 処理
        ++i ;
    }
}
</pre>

<p>
このようなコードを書く。for文は、このようなコードを、一度に書けるようにしたものである。
</p>

<pre>
int main()
{
    for ( int i = 0 ; i != 0 ; ++i )
    {
        // 処理
    }
}
</pre>

<p>
for文の条件と式は、省略することができる。条件を省略した場合、trueとみなされる。
</p>

<pre>
int main()
{
    // 条件を省略、for ( ; true ; ) と同じ
    for ( ; ; ) ;
}
</pre>
</article>

<article>
<h1 id="stmt.ranged"><a href="#stmt.ranged">range-based for文（The range-based for statement）</a></h1>

<p>
TODO: Madrid meeting後に変更する。ADL baseではなくtraits baseになる予定。
</p>

<p>
ここでは、range-based forの言語機能を説明している。ライブラリとしてのレンジや、ユーザー定義のクラスでレンジをサポートする方法については、ライブラリの<a href="#iterator.range">レンジ</a>を参照。
</p>

<article>
<h1><a href="#stmt.ranged.basic">range-based forの基本</a></h1>
<pre>
for ( for-range-宣言 : for-range-初期化子 ) 文
</pre>

<p>
range-based forは、レンジをサポートしている配列、初期化リスト、クラスの各要素に対して、それぞれ文を実行するための文である。
</p>

<p>
range-based forは、forに続けて、括弧を書く。括弧の中には、変数の宣言と、レンジとを、:で区切る。
</p>

<pre>
int main()
{
    int a[] = { 1, 2, 3 } ;
    for( int i : a ) ; // 各要素をint型のコピーで受ける
    for ( int &amp; ref : a ) ; // 各要素をリファレンスで受ける
    for ( auto i : a ) ; // auto指定子を使った例
}
</pre>

<p>
このようにして宣言した変数は、range-based for文の中で使うことができる。range-based for文は、変数をレンジの各要素で初期化する。
</p>

<pre>
int main()
{
    int a[] = { 1, 2, 3 } ;
    for ( auto i : a )
    {
        i ;
    }
}
</pre>

<p>
この例では、ループは3回実行され、変数iの値は、それぞれ、1, 2, 3となる。
</p>

<p>
ループを使ってコードを書く場合、配列やコンテナーの各要素に対して、それぞれ何らかの処理をするという事が多い。
</p>

<pre>
#include &lt;iostream&gt;

int main()
{
    int a[5] = { 1, 2, 3, 4 ,5 }  ;
    for (
        int * iter = &amp;a ; // 各要素を表す変数の宣言
        iter != &amp;a + 5 ; // 終了条件の判定
        ++iter // 次の要素の参照
    )
    {
        // 各要素に対する処理
        std::cout &lt;&lt; *iter &lt;&lt; std::endl ;
    }
}
</pre>

<p>
しかし、このようなループを正しく書くのは、至難の業である。なぜならば、人間は間違いを犯すからである。しかし、このようなループは、誰が書いても、概ね似たようなコードになる。range-based forを使えば、このような冗長なコードを省くことができる。
</p>

<pre>
int main()
{
    int a[5] = { 1, 2, 3, 4 ,5 }  ;
    for ( auto i : a )
    {
        std::cout &lt;&lt; i &lt;&lt; std::endl ;
    }
}
</pre>

<p>
range-based forは、極めて簡単に使うことができる。for-range-宣言で、各要素を得るための変数を宣言する。for-range初期化子で、レンジをサポートした式を書く。文で、各要素に対する処理を書く。
</p>

<pre>
int main()
{
    int a[5] = { 1, 2, 3, 4 ,5 }  ;
    for ( int &amp; i : a )
    {
        i *= 2 ; // 二倍する
    }
}
</pre>

<p>
この例では、配列aの各要素は、二倍される。配列の要素を書き換えるために、変数は参照で受けている。
</p>

<p>
range-based forには、配列の他にも、初期化リストや、レンジをサポートしたクラスを書く事ができる。STLのコンテナーは、レンジをサポートしている。配列以外にrange-based forを適用する場合、&lt;iterator&gt;の#includeが必要である。
</p>

<pre>
#include &lt;iterator&gt;

int main()
{
    // 配列
    int a[] = { 1, 2, 3 } ;
    for ( auto i : a )
    { std::cout &lt;&lt; i &lt;&lt; std::endl ; }     
    
    // 初期化リスト
    for ( auto i : { 1, 2, 3 } )
    { std::cout &lt;&lt; i &lt;&lt; std::endl ; } 

    // クラス
    std::vector&lt;int&gt; v = { 1, 2, 3 } ;
    for ( auto i : v )
    { std::cout &lt;&lt; i &lt;&lt; std::endl ; } 
}
</pre>
</article>

<article>
<h1 id="stmt.ranged.detail"><a href="#stmt.ranged.detail">range-based forの詳細</a></h1>

<p class="editrial-note">
TODO:メンバー関数begin/end優先の追記。
</p>

<p>
range-based forは、本来、コンセプトという言語機能と共に提供される予定であった。しかし、コンセプトは紆余曲折を経た結果、C++11では却下された。そのため、現行のrange-based forは、コンセプトではなく、ADLによる実装をされている。
</p>

<p>
以下のrange-based for文があるとする。
</p>

<pre>
for ( for-range-宣言 : for-range-初期化子 ) 文
</pre>

<p>
このrange-based for文は、以下のように変換される。
</p>

<p>
for-range-初期化子が式の場合、括弧でくくられる。これは、コンマ式が渡されたときに、正しく式を評価するためである。
</p>

<pre>
for ( auto i : a, b, c, d ) ;
// 括弧でくくる
for ( auto i : (a, b, c, d) ) ;
</pre>

<p>
for-range-初期化子が初期化リストの場合、なにもしない。
</p>

<pre>
{
    // 式の結果をlvalueかrvalueのリファレンスで束縛
    auto &amp;&amp; __range = for-range-初期化子 ;
    for (
        auto __begin = begin式, // 先頭のイテレーター
        __end = end式 ; // 終端のイテレーター
        __begin != __end ; // 終了条件
        ++__begin ) // イテレーターのインクリメント
    {
        for-range-宣言 = *__begin; // 要素を得る
        文
    }
}
</pre>

<p>
ここでの、__range、__begin、__endという変数は、説明のための仮の名前である。実際のrange-based for文の中では、このような変数名は存在しない。
</p>

<p>
__rangeとは、for-range-初期化子の式の結果を保持するためのリファレンスである。auto指定子とrvalueリファレンスの宣言子が使われていることにより、式のlvalue、rvalue、CV修飾子をいかんを問わずに、結果をリファレンスとして束縛できる。
</p>

<p>
begin式とend式は、先頭と終端へのイテレーターを得るための式である。
</p>

<p>
for-range-初期化子の型が、配列の場合、begin式は「__range」となり、end式は、「__range + 配列の要素数」となる。
</p>

<pre>
int x [10] ;
for ( auto i : x )
{
    // 処理
}
</pre>

<p>
上記のrange-based for文は、以下のように変換される。
</p>

<pre>
int x [10] ;
{
    auto &amp;&amp; __range = ( x ) ;
    for (
        auto __begin = __range,
        __end = __range + 10 ;
        __begin != __end ;
        ++__begin )
    {
        auto i = *__begin; 
        // 処理
    }
}
</pre>

<p>
型が配列以外の場合、begin式は「begin(__range)」に、end式は「end(__range)」に変換される。
</p>

<pre>
std::vector&lt;int&gt; v ;
for( auto i : v )
{
    // 処理
}
</pre>

<pre>
std::vector&lt;int&gt; v ;
{
    // 式の結果をlvalueかrvalueのリファレンスで束縛
    auto &amp;&amp; __range = ( v ) ;
    for (
        auto __begin = begin(__range),
        __end = end(__range) ;
        __begin != __end ;
        ++__begin )
    {
        auto i = *__begin; 
        // 処理
    }
}
</pre>

<p>
ここでのbegin(__range)とend(__range)は、関数呼び出しである。ただし、この名前の解決には、通常の名前探索のルールは用いられない。begin/endの名前探索には、関連名前空間に特別にstdを加えた、ADLによってのみ名前探索される。通常のunqualified名前探索は用いられない。<a href="#basic.lookup.argdep">ADL</a>の詳細については、詳しい説明を別に設けてあるので、そちらを参照。
</p>
</article>

</article>



<article>
<h1 id="stmt.jump"><a href="#stmt.jump">ジャンプ文（Jump statements）</a></h1>
<p>
ジャンプ文は、実行する文を無条件で変更するための文である。
</p>

<article>
<h1 id="stmt.break"><a href="#stmt.break">break文（The break statement）</a></h1>

<pre>
break ;
</pre>

<p>
break文は、繰り返し文かswitch文の中で使うことができる。break文は、最も内側の繰り返し文かswitch文から、抜け出す機能を持つ。もし繰り返し文かswitch文に続く、次の文があれば、実行はその文に移る。break文は、ループを途中で抜けたい場合に使うことができる。
</p>

<pre>
int main()
{
    while( true )
    {
        break ;
    }

    do
    {
        break ;
    } while ( true ) ;

    for ( ; ; )
    {
        break ;
    }

    switch(0)
    {
        default :
            break ;
    }
}
</pre>


<p>
break文によって抜ける繰り返し文かswitch文とは、break文が書かれている場所からみて、最も内側の文である。
</p>

<pre>
int main()
{
    while( true ) // 外側
        while ( true ) // 内側
        {
            break ;
        }
}
</pre>

<p>
break文が使われている内側の文からは抜けるが、外側の文から抜けることはできない。
</p>
</article>

<article>
<h1 id="stmt.cont"><a href="#stmt.cont">continue文（The continue statement）</a></h1>

<pre>
continue ;
</pre>

<p>
continue文は、繰り返し文の中で使うことができる。continue文を実行すると、そのループの実行を中止する。
</p>

<p>
while文やdo文の場合、条件が評価され、その結果次第で、次のループが再び始まる。for文の場合は、ループの最後に必ず行われる式が、もしあれば評価され、条件が評価され、その結果次第で、次のループが再び始まる。
</p>

<pre>
int main()
{
    while( true )
    {
        continue ;
    }

    do
    {
        continue ;
    } while ( true ) ;

    for ( int i = 0 ; true ; ++i )
    {
        continue ;// for文の式である++iが評価される。
    }
}
</pre>

<p>
continue文に対する繰り返し文とは、continue文が書かれている場所からみて、最も内側の繰り返し文のループである。
</p>

<pre>
int main()
{
    while ( true ) // 外側
        while ( true ) // 内側
        {
            continue ;
        }

}
</pre>

<p>
この例では、continue文は、内側のwhile文のループを中止する。ただし、continue文はbreak文とは違い、繰り返し文から抜け出すわけではないので、内側のwhile文の実行が続く。
</p>
</article>

<article>
<h1 id="stmt.return"><a href="#stmt.return">return文（The return statement）</a></h1>

<pre>
return 式<sub>opt</sub> ;
return 初期化リスト ;
</pre>

<p>
return文は、関数の呼び出し元に実行を戻す文である。
</p>

<pre>
int f()
{
    return 0 ; // OK
    return ; // エラー、戻り値がない
}
</pre>

<p>
return文の式は、関数の呼び出し元に、戻り値として返される。式は関数の戻り値の型に暗黙的に変換される。変換できない場合はエラーとなる。
</p>

<p>
戻り値を返さない関数の場合、return文の式は省略できる。戻り値を返さない関数はとは、戻り値の型がvoid型の関数、コンストラクター、デストラクターである。
</p>

<pre>
struct C
{
    C() { return ; }
    ~C() { return ; }
} ;

void f() { return ; }
</pre>


<p>
戻り値を返さない関数の場合は、return文で戻り値を返してはならない。
</p>

<pre>
void f()
{
    return ; // OK
    return 0 ; // エラー、関数fは戻り値を返さない
}
</pre>

<p>
ただし、return文の式がvoidと評価される場合は、戻り値を返していることにはならない。
</p>

<pre>
void f() { }
void g()
{
    // 関数fの呼び出しの結果は、void
    return f() ;
}
</pre>

<p>
関数の本体の最後は、値を返さないreturn文が書かれたことになる。
</p>

<pre>
void f()
{
// 値を返さないreturn文が書かれた場合と同じ
}
</pre>

<p>
値を返す関数で、return文が省略された場合の挙動は未定義である。ただし、main関数だけは、特別に0が返されたものとみなされる。
</p>

<pre>
// 値を返す関数
int f( bool b )
{
    if ( b ) 
    { return 0 ; }
// bがfalseの場合の挙動は未定義
}

int main()
{
// return 0 ;が書かれた場合と同じ
}
</pre>

<p>
return文には、初期化リストを書くことができる。
</p>

<pre>
std::initializer_list&lt;int&gt; f()
{
    return { 1, 2, 3 } ;
}

struct List
{
    List( std::initializer_list&lt;int&gt; ) { }
} ;

List g()
{
    return { 1, 2, 3 } ;
}
</pre>

<p>
return文は、関数の戻り値の為に、一時オブジェクトを生成するかもしれない。一時オブジェクトを生成する場合、値はコピーかムーブをしなければならないが、return文では、コピーかムーブかの選択のために、式をrvalueとみなす可能性もある。式をrvalueとみなすということは、lvalueであっても、暗黙的にムーブされる可能性があることを意味する。これは例えば、「return文を実行して関数の呼び出し元に戻った場合、関数のローカル変数は破棄されるためムーブしてもかまわない」という状況で、コピーではなく、ムーブを選択できるようにするためである。
</p>

<pre>
// コピーとムーブが可能なクラス
struct C
{
    C() = default ; // デフォルトコンストラクター
    C( C const &amp; ) = default ; // コピーコンストラクター
    C( C &amp;&amp; ) = default ; // ムーブコンストラクター
} ;

C f()
{
    C c ;
    // 一時オブジェクトが生成される場合、コピーかムーブが行われる。
    return c ; 
// なぜならば、ローカル変数はreturn文の実行後、破棄されるので、ムーブしても構わないからである。
}
</pre>

<p>
また、上記のコードで、一時オブジェクトが生成されない場合もある。これはインライン展開やフロー解析などによる最適化の結果、コピーもムーブも行わなくてもよいと判断できる場合、そのような最適化を許可するためである。
</p>
</article>

<article>
<h1 id="stmt.goto"><a href="#stmt.goto">goto文（The goto statement）</a></h1>

<pre>
goto 識別子 ;
</pre>
<p>
goto文は、関数内のラベル文に無条件で実行を移すための文である。同じ関数内であれば、どこにでもジャンプできる。
</p>

<pre>
int main()
{
label : ; // labelという名前のラベル文

    goto label ;
}
</pre>

<p>
宣言文の前にジャンプする。あるいは、宣言文を飛び越すことについては、宣言文の項目で詳しく解説している。
</p>
</article>

</article>

</article>


<article>
<h1 id="stmt.dcl"><a href="#stmt.dcl">宣言文（Declaration statement）</a></h1>

<pre>
ブロック宣言 ;
</pre>

<p>
宣言文は、あるブロックの中に、新しい識別子を導入するための文である。ブロック宣言や、その他の宣言についての詳細は、宣言、宣言子、クラスを参照。
</p>

<pre>
int main()
{
    int a ; // int型の識別子aという変数の宣言

    void f(void) ; // void (void)型の識別子fという関数の宣言

}
</pre>

<p>
<a href="#basic.stc.auto">自動ストレージの有効期間</a>を持つ変数は、宣言文が実行されるたびに、初期化される。また、宣言されているブロックから抜ける際に、破棄される。
</p>

<pre>
struct Object
{
    Object()
    { std::cout &lt;&lt; "constructed." &lt;&lt; std::endl ;}
    ~Object()
    { std::cout &lt;&lt; "destructed." &lt;&lt; std::endl ;}
} ;

int main()
{
    {
        Object object ; // 生成
    } // ブロックスコープから抜ける際に破棄される
}
</pre>

<p>
ジャンプ文を使えば、宣言文の後から前に実行を移すことが可能である。その場合、宣言文によって生成されたオブジェクトは破棄され、宣言文の実行と共に、再び生成、初期化される。
</p>

<pre>
struct Object
{
    Object()
    { std::cout &lt;&lt; "constructed." &lt;&lt; std::endl ;}
    ~Object()
    { std::cout &lt;&lt; "destructed." &lt;&lt; std::endl ;}
} ;

int main()
{
label :
    Object object ; // 変数objectが生成、初期化される

    goto label ; // 変数objectは破棄される
}
</pre>

<p>
この例では、Objectクラスの変数objectは、gotoで宣言文の前にジャンプするたびに、破棄されることになる。
</p>

<p>
goto文やswitch文などのジャンプ文を使えば、自動変数の宣言文を実行せずに、通り越すコードが書ける。
</p>

<pre>
// goto文の例
void f()
{
    // labelという名前のラベル文にジャンプする
    goto label ;

    int value ; // 自動変数の宣言文

label : ;
// valueの宣言文を、実行せずに通り越してしまった。
}

// switch文の例
void g( int value )
{
    switch ( value )
    {
        int value ; // 変数の宣言文

        // 宣言文を飛び越えてしまっている。
        case 0 : break ;
        case 1 : break ;
        default : break ;
    }
}
</pre>

<p>
このようなコードは、ほぼすべての場合、エラーとなるので、書くべきではない。では、変数の宣言文を通り越してもエラーとならない場合は何か。これは、相当の制限を受ける。まず、変数の型は、スカラー型か、trivialなデフォルトコンストラクターとtrivialなデストラクターを持つクラス型でなければならない。また、そのような型にCV修飾子を加えた型と、配列型でもよい。その上で、初期化子が存在していてはならない。
</p>

<pre>
struct POD { } ;
// trivialではないコンストラクターを持つクラス
struct Object { Object() {} } ;

int main()
{
    // 変数の宣言文を飛び越えるgoto文
    goto label ;

    // エラー
    // 変数の型はスカラー型だが、初期化子がある。
    int value = 0; 

    int scalar ; // OK

    // エラー
    // 変数のクラス型がtrivialではないコンストラクターを持っている
    Object object ;

    POD pod ; // OK

label : ;
}
</pre>

<p>
すべてのstatic変数とthread_local変数は、他のあらゆる初期化に先立って、ゼロ初期化される。
</p>

<pre>
int main()
{
    goto label ;
    static int value ; // static変数は必ずゼロ初期化される
label : 
    // この場合、valueは0であることが保証されている
    if ( value == 0 ) ;
}
</pre>

<p>
ブロックスコープ内のstatic変数とthread_local変数は、定数初期化による早期の初期化が行われない場合、宣言に始めて処理が到達した際に、初期化される。
</p>

<pre>
// 定数初期化できない型
struct X
{
    int member ;
    X( int value ) : member( value ) { }
} ;

void f()
{
    // xのゼロ初期化はすでに行われている
    static X x(123) ;
    // この時点で、xの初期化は完了している。
}
</pre>


<p>
ブロックスコープ内のstatic変数とthread_local変数が定数初期化されている場合、実装は早期に初期化を行なってもかまわない。ただし、行われるという保証はない。
</p>

<pre>
// 定数初期化できる型
struct X
{
    int member ;
    constexpr X( int value ) : member(value) { }
} ;

// 定数初期化できない型
struct Y
{
    int member ;
    Y ( int value ) : member(value) { }
} ;

int g()
{
    goto label ; // 宣言文を飛び越してしまっている。

    // constexpr指定子が使われていないことに注意
    // xはstatic変数であり、constexprコンストラクターを使っているため、定数初期化である
    static X x( 123 ) ;
    // constexprコンストラクターを使っていないため、定数初期化ではない
    static Y y( 123 ) ;

label : 
    // xは初期化されているかもしれないし、初期化されていないかもしれない
    // yは初期化されていない
    // 両方とも、ゼロ初期化は保証されている
}
</pre>

<p>
この例では、関数gのstaticローカル変数xとyの宣言文には、処理が到達しない。そのため、xとyが初期化されている保証はない。ただし、xは定数初期化なので、実装によっては、早期初期化されている可能性がある。ゼロ初期化だけは常に保証されている。
</p>



<p>
static変数とthread_local変数は、宣言文の実行のたびに初期化されることはない。
</p>

<pre>
int f( int x )
{
    // 一回だけ初期化される
    // 定数初期化なので、いつ初期化されるかは定められていない
    // ただし、ゼロ初期化はすでに行われている
    static int value = 1 ;
    // この時点で、初期化は完了していることが保証されている
 
    int temp = value ;
    value = x ;

    return temp ;
}

int main()
{
    f(2) ; // 1
    f(3) ; // 2
    f(4) ; // 3
}
</pre>

<p>
もし、static変数とthread_local変数の初期化が、例外がthrowされたことにより終了した場合は、初期化は未完了だとみなされる。そのような場合、次に宣言文を実行した際に、再び初期化が試みられる。
</p>

<pre>
int flag = 0 ;

struct X
{
    X()
    {
        if ( flag++ == 0 )
            throw 0 ;
    }

} ;

void f()
{
    static X x ;
}

int main()
{
    try
    {
        f() ; // 関数fのstaticローカル変数xの初期化は未完了
    }
    catch( ... ) { }
    f() ; // 関数fのstaticローカル変数xの初期化完了

}
</pre>


<p>
もし、static変数とthread_local変数の宣言文の初期化が再帰した場合、挙動は未定義である。
</p>

<pre>
int f( int i )
{
    static int s = f(2*i); // エラー、初期化が再帰している
    return i+1;
}
</pre>

<p>
この例では、static変数sの初期化が終わらなければ、関数fはreturn文を実行できない。しかし、sの初期化は、再帰している。この場合、挙動は未定義である。
</p>
</article>

<article>
<h1 id="stmt.ambig"><a href="#stmt.ambig">曖昧解決（Ambiguity resolution）</a></h1>

<p>
関数形式のキャストを用いた式文と、宣言文とは、文法が曖昧になる場合がある。その場合、宣言文だと解釈される。
</p>

<pre>
int main()
{
    int x = 0 ;
// 不必要な括弧がついた宣言文？　それともキャスト？
    int(x) ;
}
</pre>

<p>
この場合、int(x) ;という文は、キャストを含む式文ではなく、宣言文になる。したがって、上記の例は、変数xの再定義となるので、エラーである。
</p>
</article>

</article>



<article class="toplevel">
<h1 id="dcl.dcl"><a href="#dcl.dcl">宣言（Declarations）</a></h1>

<p>
宣言（declaration）とは、名前がどのように解釈されるかを指定するための文法である。
</p>

<p>
宣言には、ブロック宣言（block-declaration）、関数定義（function-definition）、テンプレート宣言（template-declaration）、明示的インスタンス化（explicit-instantiation）、明示的特殊化（explicit-specialization）、リンケージ指定（linkage-specification）、名前空間定義（namespace-definition）、空宣言（empty-declaration）、アトリビュート宣言（attribute-declaration）がある。
</p>

<p>
ブロック宣言には、単純宣言（simple-declaration）、名前空間エイリアス定義（namespace-alias-definition）、using宣言（using-declaration）、usingディレクティブ（using-directive）、static_assert宣言（static_assert-declaration）、エイリアス宣言（alias-declaration）、opaque-enum宣言（opaque-enum-declaration）がある。
</p>

<article>
<h1 id="dcl.simple-declaration"><a href="#dcl.simple-declaration">単純宣言（simple-declaration）</a></h1>
<p>
単純宣言（simple-declaration）は、大きく分けて三つに分割できる。
</p>

<pre>
アトリビュート指定子 指定子　宣言子 ;
</pre>

<p>
変数や関数の宣言などは、この単純宣言で書かれることになる。
</p>

<p>
単純宣言のアトリビュート指定子は、宣言子のエンティティに属する。詳しくは、<a href="#dcl.attr">アトリビュート</a>を参照。
</p>

<p>
指定子というのは、intやclass C、typedefなどを指す。指定子は複数指定できる。
</p>

<p>
宣言子は、変数や関数、型などを、ひとつする。宣言子も複数指定できる。
</p>

<pre>
// int型の変数xの宣言
int // 指定子
x // 宣言子
;

// int const * const型の変数pの宣言
const int // 指定子
* const p // 宣言子
;

// typeという名前のint型を宣言。
typedef int // 指定子
type // 宣言子
;
</pre>

<p>
宣言子を複数指定できることには、注意が必要である。例えば、ひとつの宣言文で、複数の変数を宣言することもできる。
</p>

<pre>
// int型で、それぞれa, b, c, dという名前の変数を宣言
// 宣言子は4個
int a, b, c, d ;
</pre>

<p>
これは、比較的分かりやすい。しかし、ポインターや配列、関数などという型は、宣言子で指定するので、ひとつの宣言文で、複数の宣言子を使うということは、非常に読みにくいコードを書く事もできてしまうのである。
</p>

<pre>
int * a, b, c[5], (*d)(void) ;
</pre>

<p>
この文は非常に分かりにくい。この文を細かく区切って解説すると、以下のようになる。
</p>

<pre>
int // 指定子
* a, // int *型の変数
b, // int型の変数
c[5], // int [5]型の変数
(*d)(void) // int(*)(void)型の変数、引数を取らずint型の戻り値を返す関数ポインター
;
</pre>

<p>
ひとつの宣言文で複数の宣言子を書くことは避けるべきである。
</p>
</article>

<article>
<h1 id="dcl.static_assert-declaration"><a href="#dcl.static_assert-declaration">static_assert宣言（static_assert-declaration）</a></h1>

<pre>
static_assert ( 定数式 , 文字列リテラル ) ;
</pre>

<p>
static_assert宣言は、条件付きのコンパイルエラーを引き起こすための宣言である。static_assertの定数式はboolに変換される。結果がtrueならば、何もしない。結果がfalseならば、コンパイルエラーを引き起こす。いわば、コンパイル時のassertとして働くのである。結果がfalseの場合、C++のコンパイラーは文字列リテラルをエラーメッセージとして、何らかの方法で表示する。
</p>

<pre>
static_assert( true, "" ) ; // コンパイルが通る
static_assert( false, "" ) ; // コンパイルエラー

// コンパイルエラー
// 何らかの方法で、helloと表示される。
static_assert( false, "hello" ) ;
</pre>

<p>
具体的な利用例としては、今、int型のサイズが4バイトであることを前提としたコードを書きたいとする。このコードは当然ながらポータビリティがない。そこで、int型のサイズが4バイトではない環境では、コンパイルエラーになってほしい。これは、以下のように書ける
</p>

<pre>
static_assert( sizeof(int) == 4, "sizeof(int) must be 4") ;
</pre>

<p>
sizeof(int)が4ではない環境のC++のコンパイラーでは、このコードはコンパイルエラーになる。また、文字列リテラルが、何らかの方法で表示される。
</p>

<p>
また別の例では、以下のような関数があるとする。
</p>

<pre>
// 仕様：Derived型はBase型から派生されていること
template &lt; typename Base, typename Derived &gt;
void f( Base base, Derived derived )
{
// 処理
}
</pre>

<p>
この関数では、Derivedという型は、Baseという型から派生されていることを前提とした処理を行う。そこで、もしユーザーがうっかり、そのような要求を満たさない型を渡した場合、エラーになって欲しい。これは、以下のように書ける。
</p>

<pre>
#include &lt;type_traits&gt;

template &lt; typename Base, typename Derived &gt;
void f( Base base, Derived derived )
{
    static_assert(
        !std::is_same&lt;Base, Derived&gt;::value // 同じ型でなければtrue
        &amp;&amp; std::is_base_of&lt;Base, Derived&gt;::value // DerivedがBaseから派生されていればtrue
        , "Derived must derive Base.") ;

// 処理
}

struct Base { } ;
struct Derived : Base { } ;

int main()
{
    Base b ; Derived d ;

    f(b, d) ; // OK
    f(b, b) ; // エラー
}
</pre>

<p>
このように、テンプレート引数の型が、あらかじめ定められた要求を満たしていない場合、static_assertを使ってコンパイルエラーにすることもできる。
</p>

<p>
static_assertの文字列リテラルには、<a href="#lex.charset">基本ソース文字セット</a>を使うことができる。C++の実装は、基本ソース文字セット以外の文字を、エラーメッセージとして表示する義務がない。我々日本人としては、日本語を使いたいところだが、すべてのコンパイラーに日本語の文字コードのサポートを義務づけるのが現実的ではない。そのため規格では、現実的に最低限保証できる文字しかサポートを義務づけていない。もちろん、コンパイラーがstatic_assertの日本語表示をサポートするのは自由である。しかし、サポートする義務がない以上、static_assertの文字列リテラルに基本ソース文字セット以外の文字を使うのは、ポータビリティ上の問題がある。
</p>

<pre>
// 文字列リテラルが表示されるかどうかは実装依存
static_assert( sizeof(int) == 4, u"このコードはint型のサイズは4であることを前提にしている" ) ;
</pre>
</article>


<article>
<h1 id="dcl.spec"><a href="#dcl.spec">指定子（Specifiers）</a></h1>

<p>
指定子には、ストレージクラス指定子、関数指定子、typedef指定子、friend指定子、constexpr指定子、型指定子がある。
</p>

<p>
指定子は、組み合わせて使うことができる場合もある。例えば、typedef指定子と型指定子は、組み合わせて使うことができる。その際、指定子の順番には、意味が無い。以下の2行のコードは、全く同じ意味である。
</p>

<pre>
// int型の別名typeを宣言
// typedefはtypedef指定子、intは型指定子、typeは宣言子
typedef int type ;
int typedef type ;
</pre>

<p>
もちろん、指定子と宣言子は違うので、以下はエラーである。
</p>

<pre>
// エラー、*は宣言子。宣言子の後に指定子を書く事はできない
int * typedef type ;
</pre>

<article>
<h1 id="dcl.stc"><a href="#dcl.stc">ストレージクラス指定子（Storage class specifiers）</a></h1>

<p>
ストレージクラス指定子には、register、static、thread_local、extern、mutableがある。
</p>

<p>
ひとつの宣言の中には、ひとつのストレージクラス指定子しか書く事はできない。つまり、ストレージクラス指定子同士は、組み合わせて使うことができない。ただし、thread_localだけは、staticやexternと併用できる。
</p>


<article>
<h1 id="dcl.stc.register"><a href="#dcl.stc.register">register指定子</a></h1>
<p>
register指定子を使ってはならない。registerは、変数への最適化のヒントを示す目的で導入された。これは、まだハードウェアが十分に高速でないので、賢いコンパイラを実装できなかった当時としては、意味のある機能であった。しかし、現在では、ハードウェアの性能の向上により、コンパイラーはより複雑で高機能な実装ができるようになり、registerは単に無視されるものとなってしまった。
</p>

<p>
registerは歴史的理由により存在する。この機能は、現在では互換性のためだけに残されている機能であり、使用を推奨されていない。また、将来的には廃止されるだろう。
</p>
</article>

<article>
<h1 id="dcl.stc.thread_local"><a href="#dcl.stc.thread_local">thread_local指定子</a></h1>
<p>
thread_local指定子のある変数は、<a href="#basic.stc.thread">スレッドストレージの有効期間</a>を持つ。すなわち、thread_localが指定された変数は、スレッドごとに別のオブジェクトを持つことになる。
</p>

<p>
thread_local指定子は、名前空間スコープかブロックスコープの中の変数と、staticデータメンバーに対して適用することができる。ブロックスコープの変数にthread_localが指定された場合は、たとえstatic指定子が書かれていなくても、暗黙的にstaticと指定されたことになる。
</p>

<p>
正しい例
</p>
<pre>
// グローバル名前空間のスコープ
thread_local int global_variable ;

// 名前の付いている名前空間のスコープ
namespace perfect_cpp
{
    thread_local int variable ;
}

// ブロックスコープ
void f()
{
// 以下の3行は、すべてthread_localかつstaticな変数である。
    thread_local int a ;
    thread_local static int b ;
    static thread_local int c ;
}

struct C
{
// 以下の2行は、すべてthread_localなstaticデータメンバーである。
    static thread_local int a ;
    thread_local static int b ;
} ;
</pre>

<p>
thread_local指定子は、staticデータメンバーにしか指定できないということには、注意を要する。データメンバーがstaticデータメンバーとなるには、static指定子がなければならない。ブロックスコープ内の変数とは違い、暗黙のうちにstaticが指定されたことにはならない。
</p>

<pre>
struct C
{
    // エラー、thread_localは非staticデータメンバーには適用できない。
    thread_local int a ;
} ;
</pre>

<p>
thread_localが指定された変数に対する、同じ宣言は、すべてthread_local指定されていなければならない。
</p>

<pre>
// 翻訳単位 1
thread_local int value ;

// 翻訳単位 2
extern thread_local int value ;

// 翻訳単位 2
extern int value ; // エラー、thread_localが指定されていない
</pre>
</article>

<article>
<h1 id="dcl.stc.static"><a href="#dcl.stc.static">static指定子</a></h1>
<p>
static指定子には、変数をstatic変数にするという機能と、名前を内部リンケージにするという機能がある。static指定子は、変数と関数と無名unionに指定することができる。ただし、ブロックスコープ内の関数宣言と、関数の仮引数に指定することはできない。
</p>

<pre>
struct C
{
    // staticデータメンバー
    static int data ;
    // staticメンバー関数
    static void f() {}
} ;

int main()
{
    // 変数、static変数になる
    static int x ;

    // 無名union、static変数になる
    static union { int i ; float f ; } ;
}
</pre>

<p>
static指定子が指定された変数は、<a href="#basic.stc.static">静的ストレージの有効期間</a>を持つ。ただし、thread_local指定子も指定されている場合は、<a href="#basic.stc.thread">スレッドストレージの有効期間</a>を持つ。
</p>

<p>
クラスのメンバーに対するstatic指定子については、<a href="#class.static">staticメンバー</a>を参照。
</p>

<p>
static指定子とリンケージの関係については、<a href="#basic.link">プログラムとリンケージ</a>を参照。
</p>

<p>
名前空間スコープにおける、リンケージ指定目的でのstaticの使用は、無名名前空間で代用した方がよい。この機能は、C++11で非推奨にされるはずだったが、直前で見直された。理由は、既存のコードを考えると、この機能を将来的に廃止することはできないからである。
</p>

<pre>
// グローバル名前空間スコープ
// 内部リンケージの指定
static int x ;
static void f() {} 

// 無名名前空間を使う
namespace
{
    static int x ;
    static void f() {} 
}
</pre>
</article>

<article>
<h1><a href="#dcl.stc.extern">extern指定子</a></h1>
<p>
extern指定子には、名前のリンケージを外部リンケージにするという機能と、名前の定義をしないという機能がある。extern指定子は、変数と関数に適用できる。ただし、クラスのメンバーと関数の仮引数には指定できない。
</p>

<pre>
// 変数
extern int i ;
// 関数
extern void f() ;
</pre>

<p>
extern指定子と、宣言と定義の関係については、<a href="#basic.def">宣言と定義</a>を参照。
</p>
<p>
extern指定子とリンケージの関係については、<a href="#basic.link">プログラムとリンケージ</a>を参照。
</p>

<p>
テンプレートの<a href="#temp.explicit">明示的なインスタンス化</a>と、<a href="#dcl.link">リンケージ指定</a>は、externキーワードを使うが、指定子ではない。
</p>
</article>

<article>
<h1 id="dcl.stc.mutable"><a href="#dcl.stc.mutable">mutable指定子</a></h1>
<p>
mutable指定子は、constでもstaticでもないクラスのデータメンバーに適用することができる。mutable指定子の機能は、クラスのオブジェクトへのconst指定子を、無視できることである。これにより、constなメンバー関数から、データメンバーを変更することができる。
</p>

<pre>
class C
{
private:
    mutable int value ;

public :
    void f() const
    {
        // 変更できる
        value = 0 ;
    }
} ;

int main()
{
    C c ;
    c.f() ;
}
</pre>

<p>
mutableの機能について詳しくは、<a href="#dcl.type.cv">CV修飾子</a>も参照。
</p>
</article>

</article>

<article>
<h1 id="dcl.fct.spec"><a href="#dcl.fct.spec">関数指定子（Function specifiers）</a></h1>
<p>
関数指定子（Function specifier）には、inline、virtual、explicitがある。
</p>

<article>
<h1 id="dcl.fct.spec.inline"><a href="#dcl.fct.spec.inline">inline指定子</a></h1>
<p>
inline指定子が書かれた関数宣言は、インライン関数（inline function）を宣言する。inline指定子は、この関数をインライン展開することが望ましいと示すための機能である。ただし、インライン関数だからといって、必ずしもインライン展開されるわけではない。インライン関数ではなくても、インライン展開されることもある。あくまで最適化のヒントに過ぎない。
</p>

<pre>
// インライン関数
inline void f() { }
</pre>

<p>
クラス定義の中の関数定義は、inline指定子がなくても、自動的にinline関数になる。
</p>

<pre>
struct C
{
    // 関数定義、インライン関数である
    void f() {}
    // 関数の宣言、インライン関数である
    inline void g() ;
    // 関数の宣言、インライン関数ではない
    void h() ;
} ;

// 関数C::gの定義
inline void C::g() { }

// 関数C::hの定義
void C::h() { }
</pre>


<p>
インライン指定子は、関数のリンケージに何の影響も与えない。インライン関数のリンケージは、通常の関数と同じである。すなわち、static指定子があれば内部リンケージ持つ。そうでなければ外部リンケージを持つ。
</p>

<pre>
// 外部リンケージを持つ
inline void f() {}
// 内部リンケージを持つ
inline static void g() {}
</pre>


<p>
ただし、インライン関数は、外部リンケージを持っていたとしても、通常の関数とは異なる扱いを受ける。これは、インライン展開の実装を容易にするための制約である。インライン関数は、その関数を使用するすべての翻訳単位で、「定義」されていなければならない。インライン関数の定義は、すべての翻訳単位で、まったく同一でなければならない。
</p>

<pre>
// 翻訳単位 1
// translation_unit_1.cpp

// 外部リンケージを持つインライン関数の定義
inline void f() {}
inline void g() {}
</pre>

<pre>
// 翻訳単位 2
// translation_unit_2.cpp

// 宣言だけ
inline void f() ;

// 定義
inline void g() {}

// 関数の宣言
int main()
{
    // エラー
    // この翻訳単位に関数fの定義がない
    f() ; 

    // OK、定義もある
    g() ;
}
</pre>

<p>
これは、テンプレートと同じような制限となっている。そのため、外部リンケージを持つインライン関数は、通常、ヘッダーファイルに書き、必要な翻訳単位で#includeする。まったく同一ということに関して、詳しくは、<a href="#basic.def.odr">ODR（One definition rule）</a>を参照。
</p>

<p>
ただし、翻訳単位に定義があればいいので、呼び出す場所では、宣言だけだとしても、問題はない。
</p>

<pre>
// 宣言
inline void f() ;

int main()
{
    // すでに名前fは宣言されていて、この翻訳単位に定義がある
    f() ; // OK
}

// 定義
inline void f() {} 
</pre>
</article>

<article>
<h1 id="dcl.fct.spec.virtual"><a href="#dcl.fct.spec.virtual">virtual指定子</a></h1>
<p>
virtual指定子は、クラスの非staticメンバー関数に指定することができる。詳しくは、<a href="#class.virtual">virtual関数</a>を参照。
</p>
</article>

<article>
<h1 id="dcl.fct.spec.explicit"><a href="#dcl.fct.spec.explicit">explicit指定子</a></h1>
<p>
explicit指定子は、クラス定義内のコンストラクターと変換関数に指定することができる。詳しくは、<a href="#class.conv.ctor">コンストラクターによる型変換</a>と、<a href="#class.conv.fct">変換関数（Conversion functions）</a>を参照。
</p>
</article>

</article>

<article>
<h1 id="dcl.typedef"><a href="#dcl.typedef">typedef指定子（The typedef specifier）</a></h1>

<p>
typedef指定子は、型の別名を宣言するための指定子である。この別名のことを、typedef名（typedef-name）という。typedef名は、型と同じように扱われる。
</p>

<pre>
typedef int integer ;
// これ以降、typedef名integerは、int型とおなじように使える。

integer main()
{
    integer x = 0 ;
    integer y = x ;
}
</pre>

<p>
typedef名は、エイリアス宣言（alias-declaration）で宣言することもできる。
</p>

<pre>
using 識別子 = 型名 ;
</pre>

<pre>
using integer = int ;
</pre>

<p>
エイリアス宣言では、usingキーワードに続く識別子が、typedef名となる。typedef指定子によって宣言されたtypedef名と、エイリアス宣言によって宣言されたtypedef名は、全く同じ意味を持つ。そのため、本書で「typedef名」と記述されている場合、それはtypedef指定子による宣言であろうと、エイリアス宣言による宣言であろうと、等しく適用される。。一方、「typedef指定子」と記述されている場合、エイリアス宣言には当てはまらない。
</p>

<p>
エイリアス宣言の文法は、typedefより分かりやすい。例えば、関数ポインターの別名を宣言したいとする。
</p>

<pre>
// 同じ意味
typedef void (*type)(void) ;
using type = void (*)(void) ;
</pre>

<p>
typedef指定子は、指定子であるので、単純宣言と同じ文法で名前を宣言しなければならない。using宣言は、名前を先に書き、その後に、純粋な型名を書くことができる。
</p>

<p>
エイリアス宣言とテンプレートについては、<a href="#temp.alias">テンプレートエイリアス</a>を参照。
</p>


<p class="editorial-note">
TODO: この部分、規格の文面に問題あり。
</p>
<p>
typedef指定子は、クラス以外の同じスコープ内で、同じ型のtypedef名を再宣言することができる。
</p>

<pre>
typedef int I ;
typedef int I ; // OK、同じ型の再宣言
typedef short I ; // エラー、型が違う

void f()
{
    typedef short I ; // OK、別のスコープなので別の宣言
}

struct Class_Scope
{
    typedef int type ;
    typedef int type ; // エラー、クラススコープ内では、同じ型でも再宣言できない
} ;
</pre>

<p>
typedef名とconstの関係は、一見して分かりにくい。
</p>

<pre>
typedef int * type ;

// aの型はint const *
const int * a ; 
// bの型は、int * const 
const type b ; 
</pre>

<p>
これは、指定子と宣言子との違いによる。
</p>

<pre>
const int // 指定子
* a // 宣言子
;

const type // 指定子、typeの型は int *
b // 宣言子
;
</pre>

<p>
変数aの場合、const intへのポインター型となる。変数bの場合、const type型となる。typeの型は、int *なので、int *へのconst型となる。そのため、違う型となる。
</p>
</article>

<article>
<h1 id="dcl.friend"><a href="#dcl.friend">friend指定子（The friend specifier）</a></h1>
<p>
friend指定子については、<a href="#class.friend">friend</a>を参照
</p>
</article>

<article>
<h1 id="dcl.constexpr"><a href="#dcl.constexpr">constexpr指定子（The constexpr specifier）</a></h1>
<p>
constexpr指定子は、constexprの制約を満たした、変数の定義、関数と関数テンプレートの宣言、staticデータメンバーの宣言に対して指定できる。
</p>

<pre>
constexpr int value = 0 ;
</pre>

<p>
constexpr指定子を使って定義され、定数式で初期化された変数は、定数式として使うことができる。
</p>

<pre>
void f()
{
    constexpr std::size_t size = 10 ;
    int a[size] ;
}
</pre>

<p>
constexpr指定子を使う変数の型は、リテラル型でなければならない。
</p>

<pre>
struct literal
{
    int a ;
} ;

struct non_literal
{
    non_literal() { }
} ;

int main()
{
    constexpr literal a{} ; // OK
    constexpr non_literal b{} ; // エラー
}
</pre>

<p>
コンストラクター以外の関数にconstexpr指定子を記述すると、その関数は、constexpr関数(constexpr function)となる。コンストラクターにconstexpr指定子を記述すると、そのコンストラクターは、constexprコンストラクター(constexpr constructor)となる。constexpr関数とconstexprコンストラクターは暗黙にinlineになる。
</p>

<p>
constexpr関数の定義は、以下の条件を満たさなければならない。
</p>

<ul>
<li>
virtual関数でないこと
</li>

<li>
戻り値の型がリテラル型であること
</li>

<li>
仮引数の型がリテラル型であること
</li>

<li>
<p>
関数の本体は、= deleteか、= defaultか、複合文であること。
</p>

<p>
複合文として使える文は、以下のものだけである。
</p>

<ul>
<li>
null文
</li>

<li>
static_assert宣言
</li>

<li>
typedef宣言とエイリアス宣言で、クラスやenumを定義しないもの
</li>

<li>
using宣言
</li>

<li>
usingディレクティブ
</li>

<li>
return文ひとつ
</li>
</ul>

</li>

<li>
戻り値を初期化する際のコンストラクター呼び出しや、暗黙の型変換は、すべて定数式でなければならない。
</li>
</ul>

<p>
以下は合法なconstexpr関数の例である。
</p>

<pre>
constexpr int f()
{
    return 1 + 1 ;
}

constexpr int g( int x, int y )
{
    return x + y + f() ;
}

constexpr int h( unsigned int n )
{
    return n == 0 ? 0 : h( n - 11 ) ;
}
</pre>

<p>
以下は、constexpr関数の制約を満たさない誤ったコードの例である
</p>
<pre>
// エラー、使えない文の使用
constexpr int f( )
{
    constexpr int x = 0 ;
    return x ;
}

// エラー、使えない文の使用
constexpr int g( bool b )
{
    if ( b )
        return 1 ;
    else
        return 2 ;
}

// エラー、return文がふたつ
constexpr int h()
{
    return 0 ;
    return 0 ;
}

// エラー、戻り値の型がリテラル型ではない
struct S{ S(){ } } ;
constexpr S i()
{
    return S() ;
}
</pre>

<p>
C++11のconstexpr関数の制約はとても厳しい。C++14では、この制約は大幅に緩和される。
</p>

<p>
constexprコンストラクターの定義は、仮引数の型がリテラルでなければならない。関数の本体は、= deleteか、= defaultか、複合文でなければならない。複合文は以下の制約を満たさなければならない。
</p>

<ul>
<li>
クラスはvirtual基本クラスを持たないこと
</li>

<li>
関数の本体は関数tryブロックではないこと
</li>

<li>
<p>
関数の本体の複合文は、以下のいずれかしか含まないこと
</p>

<ul>
<li>
null文
</li>

<li>
static_assert宣言
</li>

<li>
typedef宣言とエイリアス宣言で、クラスやenumを定義しないもの
</li>

<li>
using宣言
</li>

<li>
usingディレクティブ
</li>
</ul>

</li>

<li>
クラスの非staticデータメンバーと、基本クラスのサブオブジェクトは、すべて初期化されること
</li>

<li>
非staticデータメンバーと基本クラスのサブオブジェクトの初期化に関わるコンストラクターは、constexprコンストラクターであること
</li>

<li>
<p>
非staticデータメンバーに指定された初期化句は定数式であること
</p>

<pre>
struct S
{
    int member = 0 ; // 定数式であること

    constexpr S() { }
} ;
</pre>

</li>

<li>
コンストラクターの実引数を仮引数の型に変換する際の型変換は、定数式であること
</li>
</ul>

<p>
constexprコンストラクターは、ユーザー定義の初期化を記述したリテラル型のクラスを書くことができる。
</p>

<pre>
struct point
{
    int x ;
    int y ;

    constexpr S( int x, int y )
        : x(x), y(y)
    { }
} ;
</pre>

<p>
このようなリテラル型のクラスは、constexpr指定子を使った変数で使える。
</p>

<pre>
constexpr S s( 10, 10 ) ;
</pre>

<p>
どのような実引数（無引数関数も含む）を与えても、constexprが定数式にならない場合、エラーとなる。
</p>

<pre>
// OK、定数式になる実引数がある
constexpr int f( bool b )
{
    return b ? throw 0 : 0 ;
}

// エラー、絶対に定数式にならない。
constexpr int g( )
{
    throw ;
}
</pre>

<p>
constexpr関数テンプレートや、クラステンプレートのconstexprメンバー関数のインスタンス化された特殊化が、constexpr関数の制約を満たさない場合、そのような関数やコンストラクターは、constexpr関数、constexprコンストラクターとはみなされない。
</p>

<pre>
template &lt; typename T &gt;
constexpr T f( T x )
{
    return x ;
}

struct non_literal { non_literal(){ } } ;

int main()
{
    f( 0 ) ; // OK、constexpr関数

    non_literal n ;
    f( n ) ; // OK、ただし通常の関数
}
</pre>

<p>
constexpr関数を呼び出した結果の値は、同等だがconstexprではない関数を呼び出した結果の値と等しくなる。
</p>

<p>
コンストラクターを除く非staticメンバー関数にconstexpr指定子を使うと、そのメンバー関数はconst修飾される。
</p>

<pre>
struct S
{
    constexpr int f() ; // constになる
} ;
</pre>

<p>
これは、以下のように書くのと同等である。
</p>

<pre>
constexpr int f() const ;
</pre>

<p>
constexpr指定子は、これ以外には関数の型に影響を与えない。
</p>

<p>
constexpr非staticメンバー関数を持つクラスは、リテラル型でなければならない。
</p>

<pre>
// OK、リテラル型
struct literal
{
    constexpr int f() { return 0 ; }
} ;

// エラー、リテラル型ではない
struct non_literal
{
    non_literal() { }
    constexpr int f() { return 0 ; }   
} ;
</pre>

<p>
constexpr指定子が変数定義に使われた場合、変数はconstになる。変数の型はリテラル型でなければならず、また初期化されなければならない。
</p>

<pre>
constexpr int a = 0 ;

// エラー、初期化されていない
constexpr int b ;


struct non_literal { non_literal() { } } ;
// エラー、リテラル型ではない
constexpr non_literal c{ } ;
</pre>

<p>
初期化にコンストラクター呼び出しが行われる場合、コンストラクター呼び出しは定数式でなければならない
</p>


</article>

<article>
<h1 id="dcl.type"><a href="#dcl.type">型指定子（Type specifiers）</a></h1>
<p>
型指定子（type specifier）には、クラス指定子、enum指定子、単純型指定子（simple-type-specifier）、複雑型指定子（elaborated-type-specifier）、typename指定子、CV修飾子（cv-qualifier）がある。
</p>

<p>
クラス指定子は<a href="#class">クラス</a>で、enum指定子は<a href="#dcl.enum">enumの宣言</a>で、typename指定子は、テンプレートの<a href="#temp.res">名前解決</a>を参照。
</p>

<p>
型指定子は、一部を除いて、宣言の中にひとつだけ書くことができる。組み合わせることのできる型指定子は、以下の通りである。
</p>

<p>
constは、const以外の型指定子と組み合わせることができる。volatileは、volatile以外の型指定子と組み合わせることができる。
</p>

<p>
signedとunsignedは、char, short, int, longを後に書くことができる。
</p>

<p>
shortとlongは、intを後に書くことができる。
</p>

<p>
longは、doubleを後に書くことができる。longは、longを後に書くことができる。
</p>

<pre>
long double a = 0.0l ;
long long int b = 0 ;
</pre>


<article>
<h1 id="dcl.type.cv"><a href="#dcl.type.cv">CV修飾子（The cv-qualifiers）</a></h1>

<p>
CV修飾子（cv-qualifier）は、指定子の他に、ポインターの宣言子にも使うことができる。CV修飾子には、constとvolatileがある。この二つのキーワードの頭文字をとって、CV修飾子と呼ばれている。CV修飾子付きの変数は、必ず初期化子が必要である。CV修飾子がオブジェクトに与える影響については、基本事項の<a href="#basic.type.qualifier">CV修飾子</a>を参照。
</p>

<pre>
const int a = 0 ;
volatile int b = 0 ;
const volatile int c = 0 ;

const int d ; // エラー、初期化子がない
</pre>

<p>
指定子の始めに延べたように、指定子の順番に意味はないので、const intとint constは、同じ意味となる。
</p>

<p>
CV修飾子付きの型へのポインターやリファレンスは、必ずしも、CV修飾子付きのオブジェクトを参照する必要はない。ただし、CV修飾子が付いているように振舞う。
</p>

<pre>
int main()
{
    int x = 0 ; // 非constなオブジェクト
    x = 0 ; // 変更できる

    int const &amp; ref = x ; // 参照する
    ref = 0 ; // エラー、変更できない
}
</pre>
</article>

<article>
<h1 id="dcl.type.simple"><a href="#dcl.type.simple">単純型指定子（Simple type specifiers）</a></h1>

<p>
単純型指定子には、基本型、クラス名、enum名、typedef名、auto指定子、decltype指定子を使うことができる。
</p>

<p>
基本型については、<a href="#basic.fundamental">基本型</a>を参照。
</p>

<p>
注意すべきこととしては、signedやunsignedは、単体で使われると、int型だとみなされる。
</p>

<pre>
// signed int
signed a = 0 ;
// unsigned int
unsigned b = 0 ;
</pre>

<p>
また、shortやlongやlong longは、それぞれintが省略されたものとみなされる
</p>

<pre>
// short int
short a = 0 ;
// long int
long b = 0 ;
// long long int
long long c = 0 ;
</pre>
</article>

<article>
<h1 id="dcl.type.elab"><a href="#dcl.type.elab">複雑型指定子（Elaborated type specifiers）</a></h1>

<p>
複雑型指定子の複雑（Elaborated）というのは、あまりふさわしい訳語ではないが、本書では便宜上、elaboratedに対し、複雑という訳語を使用する。class、struct、union、enumなどのキーワードを使った型指定子を指す。
</p>

<pre>
struct StructName { } ;
class ClassName { } ;
union UnionName { } ;
enum struct EnumName { value } ;

int main()
{
    {
        // 複雑型指定子
        struct StructName a ;
        class ClassName b ;
        union UnionName c ;
        enum EnumName d = EnumName::value ;
    }

    {
        // 単純型指定子
        StructName a ;
        ClassName b ;
        UnionName c ;
        EnumName d = EnumName::value ;
    }
}
</pre>

<p>
識別子に対するキーワードは、すでに行われた宣言と同じでなければならない。
</p>

<pre>
class Name { } ;
struct Name a ; // エラー、Nameはclassキーワードで宣言されている。
</pre>
</article>

<article>
<h1 id="dcl.spec.auto"><a href="#dcl.spec.auto">auto指定子（auto specifier）</a></h1>

<p>
ここでは、変数の宣言に対するauto指定子について説明する。関数の宣言に対するauto指定子については、宣言子の<a href="#dcl.fct">関数</a>を参照。また、<a href="#expr.new">new式</a>にも、似たような機能がある。
</p>

<p>
変数を宣言する際、型指定子にautoキーワードを書くと、変数の型が、初期化子の式から推定される。
</p>

<pre>
auto a = 0 ; // int
auto b = 0l ; // long
auto c = 0.0 ; // double
auto d = 0.0l ; // long double
</pre>

<p>
もちろん、単なるリテラルだけにはとどまらない。およそ初期化子に書ける式ならば、何でも使うことができる。
</p>

<pre>
int f() { return 0 ; }

bool g(int){ return true ; }
char g(double){ return 'a' ; }

int main()
{
    auto a = f() ; // int

    // もちろん、オーバーロード解決もされる
    auto b = g(0) ; // bool
    auto c = g(0.0) ; // char

    auto d = &amp;f ; // int (*)(void)
}
</pre>

<p>
auto指定子は、冗長な変数の型の指定を省くためにある。というのも、初期化子の型は、コンパイル時に決定できるので、わざわざ変数の型を指定するのは、冗長だからだ。また、変数の型を指定するのが、非常に面倒な場合もある。
</p>

<pre>
#include &lt;vector&gt;
#include &lt;string&gt;

int main()
{
    std::vector&lt; std::string &gt; v ;
    // 型名が長くて面倒
    std::vector&lt; std::string &gt;::iterator iter1 = v.begin() ;

    // 簡潔に書ける
    auto iter2 = v.begin() ;
}
</pre>

<p>
この場合では、std::vector&lt; std::string &gt;::iterator型の変数を宣言している。auto指定子を使わないと、非常に冗長になってしまう。
</p>

<pre>
template &lt; typename T1, typename T2 &gt; struct Add { } ;
template &lt; typename T1, typename T2 &gt; struct Sub { } ;

template &lt; typename T1, typename T2 &gt;
Add&lt; T1, T2 &gt; operator + ( T1, T2 )
{
    typedef Add&lt; T1, T2 &gt; type ;
    return type() ;    
}

template &lt; typename T1, typename T2 &gt;
Sub&lt; T1, T2 &gt; operator - ( T1, T2 )
{
    typedef Sub&lt; T1, T2 &gt; type ;
    return type() ;    
}

struct A { } ;
struct B { } ;

int main()
{
    A a ; B b ;
    auto result = a + b - b + (b - a) ;
}
</pre>

<p>
この場合、resultの型を明示的に書こうとすると、以下のようになる。これはとてもではないが、まともに書く事はできない。
</p>

<pre>
Add&lt; Sub&lt; Add&lt; A, B&gt;, B&gt;, Sub&lt; B, A&gt; &gt; result = a + b - b + (b - a) ;
</pre>

<p>
auto指定子による変数の宣言では、変数の型は、関数のテンプレート実引数の推定と同じ方法で推定される。
</p>

<pre>
auto u = expr ;
</pre>

<p>
という式があったとすると、変数uの型は、
</p>

<pre>
template &lt; typename U &gt; void f( U u ) ;
</pre>

<p>
このような関数を、f(expr)と呼び出した場合の、テンプレート仮引数Uと同じ型となる。
</p>

<p>
ただし、auto指定子では、初期化子が初期化リストであっても、型を推定できるという違いがある。
</p>

<pre>
// std::initializer_list&lt;int&gt;
auto a = { 1, 2, 3 } ;
// std::initializer_list&lt;double&gt;
auto b = { 1.0, 2.0, 3.0 } ;

// エラー、型を推定できない
auto c = { 1, 2.0 } ;
auto d = { } ;

// OK、明示的なキャスト
auto e = std::initializer_list&lt;int&gt;{ 1, 2.0 } ;
auto f = std::initializer_list&lt;int&gt;{ } ;
</pre>

<p>
テンプレートの実引数推定と同じ方法で型を推定するために、配列型は配列の要素へのポインターに、関数型は関数ポインタ―型になってしまう。これには注意が必要である。
</p>

<pre>
void f() { }

int main()
{
    int a[1] ;
    auto t1 = a ; // int *
    auto t2 = f ; // int (*)(void)
}
</pre>


<p>
auto指定子は、他の指定子や、CV修飾子、宣言子と組み合わせることもできる。
</p>

<pre>
int const expr = 0 ; // exprの型はint const
auto a = expr ; // int
auto const b = expr ; // int const
auto const &amp; c = expr ; // int const &amp;
auto const * d = &amp;expr ; // int const *

static auto e = expr ; // static指定子付きのint型の変数
</pre>

<p>
この際の型の決定も、関数のテンプレート実引数の推定と同じルールになる。
</p>

<p>
宣言子と初期化子の型が合わない場合は、エラーとなる。
</p>

<pre>
auto &amp; x = 0 ; // エラー
</pre>

<p>
この例では、xの型は、リファレンス型であるが、初期化子の型は、リファレンス型ではない。そのため、エラーとなる。
</p>

<p>
宣言子がrvalueリファレンスの場合、注意を要する。auto指定子の型は、テンプレート実引数の推定と同じ方法で決定されるので、lvalueリファレンスになることもある。
</p>

<pre>
int main()
{
    int x = 0 ;

    int &amp;&amp; r1 = x ; // エラー、rvalueリファレンスをlvalueで初期化できない

    auto &amp;&amp; r2 = x ; // OK、ただし、r2の型はint &amp;
    auto &amp;&amp; r3 = std::move(x) ; // OK、r3の型はint &amp;&amp;
}
</pre>

<p>
これは、テンプレート実引数の推定と同じである。
</p>

<pre>
template &lt; typename U &gt;
void f( U &amp;&amp; u ) { }

int main()
{
    int x = 0 ;

    f( x ) ; // Uはint &amp;
    f( std::move(x) ) ; // Uはint &amp;&amp;
}
</pre>

<p>
auto指定子で変数を宣言する場合は、必ず初期化子がなければならない。また、宣言しようとしている変数名が、初期化子の中で使われていてはならない。
</p>

<pre>
auto a ; // エラー、初期化子がない
auto b = b ; // エラー、初期化子の中で宣言しようとしている変数名が使われている
</pre>

<p>
初期化子が要素の型Uの初期化リストの場合、autoの型はstd::initializer_list&lt;U&gt;になる。
</p>

<pre>
// std::initializer_list&lt;int&gt;
auto a = { 1, 2, 3 } ;
</pre>

<p>
宣言子が関数の場合、auto指定子を使った宣言は関数になる。
</p>

<pre>
void f() { }
auto (*p)() -&gt; void = &amp;f ;
</pre>

<p>
auto指定子を使って、ひとつの宣言文で複数の変数を宣言することは可能である。その場合、変数の型は、それぞれの宣言子と初期化子から推定される型になる。
</p>

<pre>
auto a = 0, &amp; b = a, * c = &amp;a ;
</pre>

<p>
この例では、aの型はint、bの型はint &amp;、cの型はint *となる。ただし一般に、コードの可読性の問題から、ひとつの宣言文で複数の変数を宣言するのは、避けたほうがよい。
</p>

<p>
ただし、複数の変数を宣言する場合、autoによって推定される型は、必ず同じでなければならない。
</p>

<pre>
int x = 0 ;
auto a = x, * b = &amp;x ; // OK、autoに対して推定される型は同じ
auto c = 0, d = 0.0 ; // エラー、型が同じではない
</pre>

<p>
従来の、変数が自動ストレージの有効期間を持つということを明示的に指定する意味でのauto指定子は、廃止された。C++11では、autoキーワードを昔の文法で使用した場合、エラーとなる。
</p>

<pre>
auto int x = 0 ; // エラー、C++11には存在しない昔の機能
</pre>
</article>

<article>
<h1 id="dcl.spec.decltype"><a href="#dcl.spec.decltype">decltype指定子（decltype specifier）</a></h1>

<pre>
decltype ( 式 )
</pre>

<p>
decltypeの型は、オペランドの式の型になる。decltype指定子のオペランドの式は、未評価式である。
</p>

<pre>
int main()
{
    decltype( 0 ) x ; // xの型はint
    decltype( x ) y ; // yの型はint

    int const c = 0 ;
    decltype( c ) z = 0 ; // zの型はint const
}
</pre>

<p>
decltype指定子の型は、以下のような順序で、条件の合うところで、上から優先的に決定される。
</p>

<p>
decltype(e)に対して、
</p>

<p>
もし、eが括弧式で囲まれていない、名前かクラスのメンバーアクセスであれば、decltypeの型は、名前eの型になる。
</p>

<pre>
int x ;
// decltype(x)の型はint
decltype(x) t1 ;

class C { int value ; } ;
C c ;
// decltype(c)の型は、class C
decltype(c) t2 ;
// decltype(c.value)の型は、int
decltype(c.value) t3 ;
</pre>


<p>
もし、eが関数呼び出しかオーバーロード演算子の呼び出しであれば、decltypeの型は、関数の戻り値の型になる。この際、括弧式は無視される。eという名前が見つからない場合や、eの名前がオーバーロード関数のセットであった場合、エラーとなる。
</p>

<p>
decltypeのオペランドは未評価式なので、sizeofなどと同じく、関数が実際に呼ばれることはない。
</p>

<pre>
int f() ;

// decltype( f() )の型は、int
decltype( f() ) t1 ;
// decltype( (f()) )の型は、int
decltype( (f()) ) t2 ;

// エラー、fooという名前は見つからない
decltype( foo ) t3 ;

// エラー、オーバーロード関数のセット
void f(int) ;
void f(short) ;

decltype(f) * ptr ;
</pre>

<p>
もし、eがxvalueであれば、eの型をTとした場合、decltype(e)の型は、T &amp;&amp;となる。
</p>

<pre>
int x ;
// typeの型はint &amp;&amp;
using type = decltype( static_cast&lt; int &amp;&amp; &gt;(x) ) ;
</pre>


<p>
もし、eがlvalueであれば、eの型をTとした場合、decltype(e)の型は、T &amp;となる。
</p>

<pre>
int x ;
// decltype( (x) ) の型は、int &amp;
using type = decltype ( (x) ) ;
</pre>

<p>
上記以外の場合、decltypeの型は、eの型となる。
</p>

<pre>
// decltype(0)の型は、int
decltype(0) t1 ;
// delctype("hello")の型は、char const [6]
decltype("hello") t2 = "hello" ;
</pre>

<p>
eがlvalueで、しかも括弧式で囲まれている場合は、リファレンス型になるということには、注意を要する。
</p>

<pre>
int x = 0 ;

decltype ( x ) t1 = x ; // t1の型はint
decltype( (x) ) t2 = x ; // t2の型はint &amp;
</pre>

<p>
decltypeは、他の型指定子や宣言子と併用できる。
</p>

<pre>
int x ;
decltype ( x ) * ptr ; // int *
decltype ( x ) const &amp; const_ref ; // int const &amp;
</pre>

<p>
decltypeは、ネストされた名前の指定子として使用できる。
</p>

<pre>

struct C
{
    typedef int type ;
} ;

int main()
{
    C c ;
    decltype(c)::type x = 0 ; // int
}
</pre>

<p>
decltypeは、基本クラスの指定子、メンバー初期化子として、として使用できる。
</p>

<pre>
struct Base { } ;
Base base ;

struct Derived
    : decltype(base) // decltypeを基本クラスとして指定
{
    Derived ()
        : decltype(base) () // メンバー初期化子
    { }
} ;
</pre>

<p>
decltypeは、疑似デストラクター名として使用できる。
</p>

<pre>
struct C { } ;

int main()
{
    C c ;
    c.~decltype(c)() ; // 疑似デストラクターの呼び出し
}
</pre>
</article>

</article>

</article>


<article>
<h1 id="dcl.enum"><a href="#dcl.enum">enumの宣言（Enumeration declarations）</a></h1>

<p>
enum指定子は、名前付きの定数と型を宣言、定義する。enum（Enumeration）は、歴史的に列挙型と呼ばれている。enum型の名前は、enum名といい、enumが宣言する定数のことを、列挙子（enumerator）と呼ぶ。
</p>

<pre>
// Eはenum名、valueは列挙子
enum E { value = 0 } ;
</pre>

<p>
本書では、enumの機能を四種類に大別して解説する。unscoped enum、scoped enum、enum基底（enum-base）、enum宣言（opaque-enum-declaration）である。
</p>

<article>
<h1 id="dcl.enum.unscoped"><a href="#dcl.enum.unscoped">unscoped enum</a></h1>

<pre>
enum指定子:
    enum 識別子<sub>opt</sub> enum基底<sub>opt</sub> { 列挙子リスト }
</pre>

<p>
enumというキーワードだけで宣言するenumのことを、unscoped enumという。unscoped enumは、弱い型付けのenumを宣言、定義する。enumの定義は、それぞれ別の型を持つ。列挙子リストとは、コンマで区切られた識別子である。各列挙子には、=に続けて定数を指定することで、値を指定できる。これをenumの初期化子という。ただし、列挙子自体はオブジェクトではない。enumは先頭の列挙子に初期化子がない場合、値は0になる。先頭以外の列挙子に初期化子がない場合、そのひとつ前の列挙子の値に、1を加算した値になる。
</p>

<pre>
// a = 0, b = 1, c = 2
enum E { a, b, c } ;

// a = 3, b = 4, c = 5
enum E { a = 3, b = 4 , c = 5 } ;

// a = -5, b = -4, c = -3
enum E { a = -5, b, c } ;

// a = 0, b = 1, c = 0, d = 1
enum E { a, b, c = 0, d } ;
</pre>

<p>
宣言した列挙子は、次の列挙子から使うことができる。
</p>

<pre>
// a = 0, b = 0, c = 5, d = 3
enum E { a, b = a, c = a + 5, d = c - 2 } ;
</pre>

<p>
enum名とunscoped enumの列挙子は、enum指定子があるスコープで宣言される。
</p>

<pre>
enum GlobalEnum { a, b } ;

GlobalEnum e1 = a ;
GlobalEnum e2 = b ;

int main()
{
    enum LocalEnum { c, d } ;
    GlobalEnum e1 = c ;
    GlobalEnum e2 = d ;
}
</pre>

<p>
unscoped enumによって宣言された列挙子は、整数のプロモーションによって、暗黙的に整数型に変換できる。整数型は、明示的なキャストによって、enum型に変換できる。整数型の値が、enum型の表現できる範囲を超えていた場合の挙動は、未定義である。
</p>

<pre>
enum E { value = 123 } ;

void f()
{
    int x = value ; // enum Eからintへの暗黙の型変換

    E e1 = 123 ; // エラー、intからenum Eへの暗黙の型変換はできない
    E e2 = static_cast&lt;E&gt;(123) ; // intからenum Eへの明示的なキャスト
}

// コマンドの種類を表す定数
enum Command { copy, cut, paste } ;

// コマンドを処理する関数
void process_command( Command id )
{
    switch( id )
    {
        case copy :
            // 処理
            break ;
        case cut :
            // 処理
            break ;
        case paste :
            // 処理
            break ;

        default :
            // エラー処理
            break ;
    }
}
</pre>

<p>
クラスのスコープ内で宣言された列挙子の名前は、クラスのメンバーアクセス演算子（::, ., -&gt;）を使うことによって、参照することができる。
</p>

<pre>
struct C
{
    enum { value } ;
    // クラススコープのなかでは名前のまま参照できる
    void f() { value ; }
} ;

int main()
{
    C::value ; // ::による参照
    C c ;
    c.value ; // .による参照
    C * p = &amp;c ;
    p-&gt;value ; // -&gt;による参照
}
</pre>

<p>
unscoped enumは、識別子を省略することができる。
</p>

<pre>
// 識別子あり
enum E { a } ;

// 識別子なし
enum { b } ;
</pre>
</article>

<article>
<h1 id="dcl.enum.scoped"><a href="#dcl.enum.scoped">scoped enum</a></h1>
<p>
scoped enumは、強い型付けをするenumである。
</p>

<pre>
enum struct 識別子 enum基底<sub>opt</sub> { 列挙子リスト } ;
enum class 識別子 enum基底<sub>opt</sub> { 列挙子リスト } ;
</pre>

<p>
scoped enumは、enum structかenum classという連続した二つのキーワードによって宣言する。enum structとenum classは、全く同じ意味である。どちらを使ってもよい。enumには、クラスのようなアクセス指定はない。scoped enumの識別子は省略できない。列挙子リストの文法は、unscoped enumと変わらない。
</p>

<pre>
enum struct scoped_enum_1 { a, b, c } ;
enum classs scoped_enum_2 { a, b, c } ;
</pre>

<p>
scoped enumは、非常に強い型付けを持っている。列挙子は、scoped enumが宣言されているスコープに導入されることはない。かならず、enum名に::演算子をつけて参照しなければならない。
</p>

<pre>
enum struct E { value } ;

value ; // エラー、scoped enumの列挙子は、このように参照できない
E::value ; // OK
</pre>

<p>
このため、同じスコープ内で、同じ名前の列挙子を持つ、複数のscoped enumを宣言することもできる。
</p>

<pre>
void f()
{
    // scoped enumの場合
    enum struct Foo { value } ;
    enum struct Bar { value } ; // OK

    Foo::value ; // enum struct Fooのvalue
    Bar::value ; // enum struct Barのvalue
}

void g()
{
    // unscoped enumの場合
    enum Foo { value } ;
    enum Bar { value } ; // エラー、すでにvalueは宣言されている。
}
</pre>

<p>
scoped enumの列挙子は、暗黙的に整数型に変換することはできない。明示的にキャストすることはできる。整数型からenumへの変換は、unscoped enumと変わらない。つまり、明示的なキャストが必要である。
</p>

<pre>
enum struct E { value = 123 } ;

int x = E::value ; // エラー、scoped enumの列挙子は暗黙的に変換できない
int y = static_cast&lt;int&gt;( E::value ) ; // OK、明示的なキャスト

E e = static_cast&lt;E&gt;( 123 ) ; // OK、unscoped enumと同じ
</pre>

<p>
ただし、switch文の中のcaseラベルや、非型テンプレート実引数では、scoped enumも使うことができる。
</p>

<pre>
enum struct E { value } ;
template &lt; int N &gt; struct C { } ;

void f( E e )
{
    // switch文のcaseラベル
    switch( e )
    { case E::value : ; }

    // 非型テンプレート実引数
    C&lt; E::value &gt; c ;
}
</pre>

<p>
これが許されている理由は、scoped enumの内部的な値は使わないものの、強い型付けがされた一種のユニークな識別子として、scoped enumを使えるようにするためである。
</p>

<p>
scoped enumは、強い型付けをするenumである。scoped enumは、列挙子の内部的な値は使わないが、単に名前付きの状態を表すことができる変数が欲しい場合。また、たとえ内部的な値を使うにしても、強い型付けによって、些細なバグを未然に防ぎたい場合などに使うことができる。
</p>
</article>

<article>
<h1 id="dcl.enum.base"><a href="#dcl.enum.base">enum基底（enum-base）</a></h1>
<pre>
enum基底:
    : 型指定子
</pre>

<p>
enum型は、内部的には単なる整数型である。この内部的な整数型のことを、内部型（underlying type）という。enum基底（enum-base）は、この内部型を指定するための文法である。enum基底の型は、基本クラスの指定とよく似た文法で指定することができる。enum基底の型指定子は、整数型でなければならない。
</p>

<p>
enum基底が指定されたenum型の内部型は、enum基底の型指定子の型になる。
</p>

<pre>
enum E : int { } ; // 内部型はint

enum struct Foo : int { } ; // 内部型はint
enum struct Bar : unsigned int { } ; // 内部型はunsigned int

enum Error : float { } ; // エラー、enum基底が整数型ではない
</pre>

<p>
enum基底が省略された場合、scoped enumの内部型は、intになる。
</p>

<pre>
enum struct E { } ; // scoped enumのデフォルトの内部型はint
</pre>

<p>
scoped enumで、int型の範囲を超える値の列挙子を使いたい場合は、明示的にenum基底を指定しなければならない。
</p>

<p>
unscoped enumのenum基底が省略された場合、内部型は明確に定められることがない。
</p>

<pre>
enum E { } ; // 内部型は定められない。
</pre>

<p>
enumの内部型が定められていない場合、内部型は、enumの列挙子をすべて表現できる整数型になる。その際、どの整数型が使われるかは、実装依存である。どの整数型でも、すべての列挙子を表現できない場合は、エラーとなる。
</p>
</article>

<article>
<h1 id="dcl.enum.opaque"><a href="#dcl.enum.opaque">enum宣言（opaque-enum-declaration）</a></h1>

<p>
enum宣言は、正式には、opaque-enum-declarationという。これは、定義をしないenumの宣言である。関数や変数が、定義せずに宣言できるように、enumも、定義せずに宣言することができる。
</p>

<pre>
enum 識別子 enum基底 ;
enum struct 識別子 enum基底<sub>opt</sub> ;
enum class 識別子 enum基底<sub>opt</sub> ;
</pre>

<p>
unscoped enumの場合は、必ず定義と一致するenum基底を指定しなければならない。scoped enumの場合は、enum基底を省略した場合、内部型はデフォルトのintになる。ただし、安全のためには、enum宣言と対応するenumの定義には、enum基底を明示的に書いておいたほうがよい。
</p>

<pre>
enum struct Foo : unsigned int ; // 内部型はunsigned int
enum class Bar ; // enum基底が省略された場合、内部型はint

enum E1 : int ; // 内部型はint

enum E2 ; // エラー、unscoped enumの宣言では、enum基底を省略してはならない。
</pre>

<p>
enum宣言によって、宣言のみされたenum名は、通常のenumと同じように使用できる。ただし、列挙子を使うことはできない。なぜならば、列挙子は宣言されていないからだ。
</p>

<p>
列挙子を使うことができないenum宣言に、何の意味があるのか。enum宣言が導入された背景には、ある種の利用方法では、すべての翻訳単位に列挙子が必要ないこともあるのだ
</p>

<h1>無駄な定義を省く</h1>

<pre>
// 翻訳単位 1

enum ID : int { /* 自動的に生成される多数の列挙子 */ } ;
</pre>

<pre>
// 翻訳単位 2

enum ID : int ; // enum宣言
void f( ID id ) // IDを引数にとる関数
{
    int x = id ;
    id = static_cast&lt;ID&gt;(0) ;
}
</pre>

<p>
翻訳単位 1で定義されているenumの列挙子は、外部のツールによって、自動的に生成されるものだとしよう。この定義は、かなり頻繁に更新される。もし、翻訳単位 2では、enumの内部的な値が使われ、列挙子という名前付きの定数には、それほど意味が無い場合、この自動的に生成される多数の列挙子は、無駄である。なぜならば、enumが生成されるたびに、たとえ翻訳単位 2のソースコードに変更がなく、再コンパイルが必要ない場合でも、わざわざコンパイルしなおさなければならないからだ。
</p>

<p>
なぜenumの定義が必要かというと、完全な定義がなければ、enumの内部型を決定できないからである。C++11では、enum基底によって、明示的に内部型を指定できる。これにより、enumを定義せず宣言することができるようになった。
</p>


<h1>型安全なデータの秘匿</h1>

<p>
以下のクラスを考える。
</p>

<pre>
// クラスCのヘッダーファイル
// C.h
enum struct ID { /* 自動的に生成される多数の列挙子 */ } ;

class C
{
public :
    // 外部に公開するメンバー

private :
    ID id ;
} ;
</pre>

<p>
さて、このクラスを、複数の翻訳単位で使いたいとする。このクラスには、データメンバーとしてenum型の変数があるが、これは外部に公開しない。クラスの中の実装の都合上のデータメンバーである。enumの列挙子は、外部ツールで自動的に生成されるものとする。
</p>

<p>
すると、このヘッダーファイルを#includeしているソースファイルは、enumが自動的に生成されるたびに、再コンパイルしなければならない。しかし、このクラスを使うにあたって、enumの定義は必要ないはずである。この場合にも、enum宣言が役に立つ。
</p>

<pre>
// クラスCのヘッダーファイル
// C.h

enum struct ID : int ;

class C { /* メンバー */ } ;
</pre>

<pre>
// クラスCのソースコード
// C.cpp

enum struct ID : int  { /* 自動的に生成される多数の列挙子 */ } ;

// メンバーの実装
</pre>

<p>
このようにしておけば、enumの定義が変更されても、クラスのヘッダーファイルを#includeして、クラスを使うだけのソースコードまで、再コンパイルする必要はなくなる。
</p>]
</article>

</article>

<article>
<h1 id="basic.namespace"><a href="#basic.namespace">名前空間（Namespaces）</a></h1>
<p>
名前空間とは、宣言の集まりに名前をつける機能である。名前空間の名前は、::演算子によって、宣言を参照するために使うことができる。名前空間は、複数定義することができる。グローバルスコープも、一種の名前空間スコープとして扱われる。
</p>

<article>
<h1 id="namespace.def"><a href="#namespace.def">名前空間の定義（Namespace definition）</a></h1>

<pre>
inline<sub>opt</sub> namespace 識別子 { 名前空間の本体 }
</pre>

<p>
名前空間は、別の名前空間スコープの中か、グローバルスコープに書くことができる。名前空間の本体には、あらゆる宣言を、いくつでも書くことができる。これには、名前空間自身も含まれる。
</p>

<pre>
// グローバルスコープ

namespace NS
{ // NSという名前の名前空間のスコープ
    // 宣言の例
    int value = 0 ;
    void f() { }
    class C { } ;
    typedef int type ;
}// NSのスコープ、ここまで 

int main()
{
    // NS名前空間の中の名前を使う
    NS::value = 0 ;
    NS::f() ;
    NS::C c ; 
    NS::type t ;

    value ; // エラー、名前が見つからない
}
</pre>

<p>
名前空間は、名前の衝突を防ぐために使うことができる。
</p>

<pre>
// グローバルスコープ
int value ;
int value ; // エラー、valueという名前はすでに宣言されている

// OK、名前空間Aのvalue
namespace A { int value ; }
// OK、名前空間Bのvalue
namespace B { int value ; }

int main()
{
    value ; // グローバルスコープのvalue
    A::value ; // 名前空間Aのvalue
    B::value ; // 名前空間Bのvalue
}
</pre>

<p>
グローバル変数として、valueような、分かりやすくて誰でも使いたがる名前を使うのは、問題が多い。しかし、名前付きの名前空間スコープの中であれば、名前の衝突を恐れずに、気軽に短くて美しい名前でも使うことができる。
</p>

<p>
名前空間は、何度でも定義することができる。
</p>

<pre>
// 最初の定義
namespace NS { int x ; }

// 二度目の定義
namespace NS { int y ; }
</pre>

<p>
名前空間はネストできる。
</p>

<pre>
namespace A { namespace B { namespace C { int value ; } } }

int main()
{
    A::B::C::value ; // Aの中の、Bの中の、Cの中のvalue
}
</pre>

<article>
<h1 id="namespace.def.inline"><a href="#namespace.def.inline">inline名前空間</a></h1>
<p>
inlineキーワードの書かれた名前空間の定義は、inline名前空間である。inline名前空間スコープの中で宣言された名前は、inline名前空間の外側の名前空間のスコープの中でも使うことができる。
</p>

<pre>
inline namespace NS { int value ; }

namespace Outer
{
    inline namespace Inner
    {
        int value ;
    } 
}

int main()
{
    value ; // NS::value
    NS::value ;

    Outer::value ; // Outer::Inner::value
    Outer::Inner::value ;
}
</pre>
</article>

<article>
<h1 id="namespace.unnamed"><a href="#namespace.unnamed">無名名前空間（Unnamed namespaces）</a></h1>

<p>
TODO:変更されそうなので保留
</p>
</article>

<article>
<h1 id="namespace.memdef"><a href="#namespace.memdef">名前空間のメンバーの定義（Namespace member definitions）</a></h1>

<p>
ある名前空間スコープの中で宣言された名前を、その名前空間のメンバーと呼ぶ。名前空間のメンバーは、名前空間の外側で定義することができる。
</p>

<pre>
namespace NS
{
    void f() ; // 関数fの宣言
    namespace Inner
    {
        void g() ; // 関数gの宣言
        void h() ; // 関数hの宣言
    }
    void Inner::g() { } // 関数gの定義
}

void NS::f() { } // 関数fの定義
void NS::Inner::h() { } // 関数hの定義
</pre>

<p>
ただし、名前空間の外側で定義されているからといって、名前空間の外側のスコープにも、名前が導入されるわけではない。あくまで、名前空間の外側でも、定義ができるだけである。
</p>
</article>

</article>

<article>
<h1 id="namespace.alias"><a href="#namespace.alias">名前空間エイリアス（Namespace alias）</a></h1>

<pre>
namespace 識別子 = 名前空間の名前 ;
</pre>

<p>
名前空間エイリアス（Namespace alias）とは、名前空間の名前の別名を定義する機能である。
</p>

<p>
名前空間は、名前の衝突を防いでくれる。しかし、名前空間の名前自体が衝突してしまうこともある。それを防ぐためには、名前空間の名前には、十分にユニークな名前をつけなければならない。しかし、衝突しない名前をつけようとすると、どうしても、短い名前をつけることはできなくなってしまう。
</p>

<pre>
namespace Perfect_cpp
{
    int x ;
}

int main()
{
   Perfect_cpp::x = 0 ;
}
</pre>

<p>
この例では、十分にユニークな名前、Perfect_cppを使っている。このため、xという名前の変数名でも、衝突を恐れず使うことができる。しかし、このPerfect_cppは長い上に、大文字とアンダースコアを使っており、タイプしづらい。そこで、名前空間エイリアスを使うと、別名を付けることができる。
</p>

<pre>
namespace Perfect_cpp { int x ; }

int main()
{
    namespace p = Perfect_cpp ;
    p::x ; // Perfect_cpp::x
}
</pre>

<p>
ネストされた名前にも、短い別名をつけることができる。
</p>

<pre>
namespace Perfect_cpp { namespace Library { int x ; } }

int main()
{
    namespace pl = Perfect_cpp::Library ;
    pl::x ; // Perfect_cpp::Library::x
}
</pre>

<p>
別名の別名を定義することもできる。
</p>

<pre>
namespace Long_name_is_Looooong { }
namespace long_name = Long_name_is_Looooong ;
namespace ln = long_name ;
</pre>

<p>
同じ宣言領域で、別名と名前空間の名前が衝突してはならない
</p>

<pre>
namespace A { } namespace B { }

// エラー、同じ宣言領域では、別名と名前空間の名前が衝突してはならない
namespace A = B ;

int main()
{
    // OK、別の宣言領域なら可
    namespace A = B ;
}
</pre>
</article>

<article>
<h1 id="namespace.udecl"><a href="#namespace.udecl">using宣言（The using declaration）</a></h1>

<pre>
using 識別子 ;
</pre>

<p>
using宣言は、宣言が書かれている宣言領域に、指定した名前を導入する。これにより、明示的に名前空間名と::演算子を使わなくても、その宣言領域で、名前が使えるようになる。
</p>

<p>
using宣言を、名前空間のメンバーに使う場合、using宣言が書かれているスコープで、::演算子による明示的なスコープの指定なしに、その名前を使うことができる。
</p>

<pre>
namespace NS { int name ; }

int main()
{
    name = 0 ; // エラー、名前nameは宣言されていない

    using NS::name ;
    name = 0 ; // NS::nameと解釈される
    NS::name = 0 ; // 明示的なスコープの指定
}

// ブロックスコープ外でもusing宣言は使える
using NS::name ;
</pre>

<p>
using宣言は、テンプレート識別子を指定することはできない。テンプレート名は指定できる。
</p>

<pre>
namespace NS
{
    template &lt; typename T &gt; class C { } ;
}

int main()
{
    using NS::C ; // OK、テンプレート名は指定できる
    using NS::C&lt;int&gt; ; // エラー、テンプレート識別子は指定できない
}
</pre>


<p>
using宣言は、名前空間の名前を指定することはできない。
</p>

<pre>
namespace NS { }
using NS ; // エラー
</pre>

<p>
using宣言は、scoped enumの列挙子を指定することはできない.
</p>

<pre>
namespace NS
{
    enum struct E { scoped } ;
    enum { unscoped } ;
}

int main()
{
    using NS::unscoped ; // OK、unscoped enumの列挙子
    using NS::E::scoped ; // エラー、scoped enumの列挙子は指定できない
}
</pre>


<p>
using宣言は、その名の通り、宣言である。したがって、通常通り、外側のスコープの名前を隠すこともできる。<a href="#namespace.udir">usingディレクティブ</a>とは、違いがある。
</p>

<pre>
int name  ; // グローバルスコープのname
namespace NS { int name ; } // NS名前空間のname

int main()
{
    // ここではまだ、名前が隠されてはいない
    name = 0 ; // ::nameを意味する

    using NS::name ; // このusing宣言は::nameを隠す
    name = 0 ; // NS::nameを意味する
}
</pre>

<p>
using宣言は、宣言された時点で、すでに宣言されている名前を、スコープに導入する。宣言場所から見えない名前は、導入されない。
</p>

<pre>
namespace NS { void f( int ) { } }
// void NS::f(int)をグローバルスコープに導入する
// void NS::f(double)は、この時点では宣言されていないので、導入されない
using NS::f ; 
namespace NS { void f( double ) { } }

int main()
{
    // この時点で、unqualified名fとして名前探索されるのは
    // void NS::f(int)のみ
    f( 1.23 ) ; // NS::f(int)を呼ぶ。

    using NS::f ; // void NS::f(double) をmain関数のブロックスコープに導入する
    f( 1.23 ) ; // オーバーロード解決により、NS::f(double)を呼ぶ
}
</pre>

<p>
ただし、テンプレートの部分的特殊化は、プライマリークラステンプレートを経由して探すので、たとえusing宣言の後に宣言されていたとしても、発見される。
</p>

<pre>
namespace NS
{
    template &lt; typename T &gt;
    class C { } ;
}

using NS::C ;

namespace NS
{
    template &lt; typename T &gt;
    class C&lt;T * &gt; { } ; // ポインター型への部分的特殊化
}

int main()
{
    C&lt;int * &gt; c ; // 部分的特殊化が使われる。
}
</pre>

<p>
using宣言は、<a href="#class.inhctor">コンストラクターの継承</a>に使うこともできる。詳しくは、該当の項目を参照。ここでは、クラスのメンバー宣言としてusing宣言を使う際の、文法上の注意事項だけを説明する。
</p>

<p>
クラスのメンバー宣言としてusing宣言を使う場合、基本クラスのメンバー名を指定しなければならない。名前空間のメンバーは指定できない。using宣言は、基本クラスのメンバー名を、派生クラスのスコープに導入する。
</p>

<pre>
namespace NS { int value ; }

class Base
{
public :
    void f() { } 
} ;

class Derived : private Base
{
public :
    using Base::f ; // OK、基本クラスのメンバー名
    using NS::value ; // エラー、基本クラスのメンバーではない
} ;
</pre>

<p>
クラスのメンバー宣言としてのusing宣言は、基本クラスのメンバーの名前を、クラスのメンバーの名前探索で発見させることができる。
</p>

<pre>
struct Base { void f( int ) { } } ;
struct Derived1 : Base
{
    void f( double ) { }
} ;
struct Derived2 : Base
{
    using Base::f ;
    void f( double ) { }
} ;

int main()
{
    Derived1 d1 ;
    d1.f( 0 ) ; // Derived::f(double)を呼ぶ
    Derived2 d2 ;
    d2.f( 0 ) ; // Base::f(int)を呼ぶ
}
</pre>

<p>
Derived1::fは、Base::fを隠してしまうので、Base::fはオーバーロード解決の候補関数に上がることはない。Derived2では、using宣言を使って、Base::fをDerived2のスコープに導入しているので、オーバーロード解決の候補関数として考慮される。
</p>

<p>
また、using宣言は、基本クラスのメンバーのアクセス指定を変更する目的でも使える。
</p>

<pre>
class Base
{
    int value ;
public :
    int get() const { return value ; }
    void set( int value ) { this->value = value ; }
} ;

// Baseからprivateで派生
class Derived : private Base
{
public : // Base::getのみpublicにする
    using Base::get ;
} ;
</pre>

<p>
この例では、DerivedはBaseからprivate派生している。ただし、Base::getだけは、publicにしたい。そのような場合に、using宣言が使える。
</p>

<p>
using宣言でクラスのメンバー名を指定する場合、クラスのメンバー宣言でなければならない。クラスのメンバー宣言以外の場所で、using宣言にクラスのメンバー名を指定してはならない。
</p>

<pre>
struct C
{
    int x ;
    static int value ;
} ;

int C::value ;

using C::x ; // エラー、これはクラスのメンバー宣言ではない
using C::value ; // エラー、同上
</pre>
</article>

<article>
<h1 id="namespace.udir"><a href="#namespace.udir">usingディレクティブ（Using directive）</a></h1>

<pre>
using namespace 名前空間名 ;
</pre>

<p>
usingディレクティブ（using directive）は、その記述以降のスコープにおける非修飾名前探索に、指定された名前空間内のメンバーを追加するための指示文である。usingディレクティブを使うと、指定された名前空間内のメンバーを、::演算子を用いないで使用できる。
</p>

<pre>
namespace NS
{
    int a ;
    void f() { }
    class C { } ;
}

int main()
{
    using namespace NS ;

    a = 0 ; // NS::a
    f() ; // NS::f
    C c ; // NS::C
}
</pre>

<p>
usingディレクティブを使えば、指定された名前空間内のすべてのメンバーを、明示的な::演算子を使わずにアクセスできるようになる。
</p>

<p>
usingディレクティブは、名前空間スコープとブロックスコープ内で使用することができる。クラススコープ内では使用できない。
</p>

<pre>
namespace A { typedef int type ; }

void f()
{
    // ブロックスコープ内
    using namespace A ;
    type x ; // A::type
}

namespace B
{
    // 名前空間スコープ
    using namespace A ;
    type x ; // A::type
}

other_namespace::type g1 ; // A::type

// 名前空間スコープ（グローバルスコープ）
using namespace A ;
type g2 ; // A::type

class C
{
    using namespace A ; // エラー、クラススコープ内では使用できない
} ;
</pre>

<p>
グローバルスコープにusingディレクティブを記述するのは推奨できない。特に、ヘッダーファイルのグローバルスコープにusingディレクティブを記述すると、非常に問題が多い。名前空間の本来の目的は、名前の衝突を防ぐためである。usingディレクティブは、名前空間という仕組みに穴を開けるような機能だからだ。
</p>

<p>
しかし、usingディレクティブは必要である。たとえば、非常に長い名前空間名や、深くネストした名前空間内の多数のメンバーを使う場合、いちいち::演算子で明示的にスコープを指定したり、using宣言でひとつひとつ宣言していくのは、非常に面倒である。あるブロックスコープで、名前が衝突しないということが保証できるならば、usingディレクティブを使っても構わない。
</p>

<pre>
namespace really_long_name { namespace yet_another_long_name
{
    int a ; int b ; int c ; int d ;  
} }

void f()
{
    // このスコープでは、a, b, c, dという名前は衝突しないと保証できる
    using namespace really_long_name::yet_another_long_name ;
    a = 0 ; b = 0 ; c = 0 ; d = 0 ;
}
</pre>

<p>
usingディレクティブは、宣言ではない。usingディレクティブは、非修飾名前探索に、名前を探すべき名前空間を、特別に追加するという機能を持っている。したがって、usingディレクティブは、名前を隠さない。以下の例はエラーである。<a href="#namespace.udecl">using宣言</a>と比較すると、違いがある。
</p>

<pre>
int name  ; // グローバルスコープのname
namespace NS { int name ; } // NS名前空間のname

int main()
{
    // ここではまだ、名前が隠されてはいない
    name = 0 ; // ::nameを意味する

    using namespace NS ; // 名前探索にNS名前空間内のメンバーを追加
    name = 0 ; // エラー、::nameとNS::nameとで、どちらを使うべきか曖昧
}
</pre>

<p>
usingディレクティブは、非修飾名前探索にしか影響を与えない。ADLには影響を与えない。
</p>

<p class="editorial-note">
TODO: range-based forで使われているトリックも記述。
</p>

<pre>
namespace NS
{
    struct S { } ;
    namespace inner
    { 
        void f(S) { }
        void g(S) { }
    }

    using inner::f ; // inner::fをNS名前空間に導入する
    using namespace inner ; // 非修飾名前探索に影響をおぼよす
} ;

int main()
{
    NS::S s ;
    f(s) ; // OK
    g(s) ; // エラー、usingディレクティブはADLには影響しない
}
</pre>

<p>
usingディレクティブで探索できるようになった名前は、オーバーロード関数の候補にもなる。
</p>

<pre>
void f( int ) { } 
namespace NS { void f( double ) { } }

int main()
{
    // この時点では、NS::fは名前探索で発見されない
    f( 1.23 ) ; // ::f(int)

    using namespace NS ; // NS名前空間のメンバーがunqualified名前探索で発見されるようになる
    f( 1.23 ) ; // オーバーロード解決により、NS::f( double )
}
</pre>

<p>
usingディレクティブは、unqualified名前探索のルールを変更するという、非常に特殊な機能である。usingディレクティブは、確実に名前が衝突しないブロックスコープ内で使うか、あるいは、オーバーロード解決をさせるので、同じ関数名を複数、意図的に名前探索で発見させる場合にのみ、使うべきである。
</p>
</article>

</article>

<article>
<h1 id="dcl.link"><a href="#dcl.link">リンケージ指定（Linkage specifications）</a></h1>

<p>
関数型、外部リンケージを持つ関数名、外部リンケージを持つ変数名には、言語リンケージ（language linkage）という概念がある。リンケージ指定（Linkage specification）は、言語リンケージを指定するための文法である。リンケージ指定と、<a href="#dcl.stc">ストレージクラス指定子</a>のextern指定子とは、別物である。
</p>

<p>
注意、実装依存の話：言語リンケージは、C++と他のプログラミング言語との間での、関数名や変数名の相互利用のための機能である。異なる言語間で名前を相互利用するには、共通の仕組みが必要である。これには、たとえば名前マングリングを始めとして、レジスターの使い方、引数のスタックへの積み方などの様々な要素がある。しかし、これらはいずれも本書の範疇を超えるので解説しない。
</p>

<pre>
extern 文字列リテラル { 宣言リスト }
extern 文字列リテラル 宣言
</pre>

<p>
標準では、C++言語リンケージと、C言語リンケージを定めている。C++の場合、文字列リテラルは"C++"となり、C言語の場合、文字列リテラルは"C"となる。何も指定しない場合、デフォルトでC++言語リンケージとなる。異なるリンケージ指定がされた名前は、たとえその他のシグネチャーがすべて同じであったとしても、別の型として認識される。その他の文字列がどのような扱いを受けるかは、実装依存である。
</p>

<pre>
// 関数型へのC言語リンケージの指定
extern "C" typedef void function_type() ;
// 関数名へのC言語リンケージの指定
extern "C" int f() ;
// 変数名へのC言語リンケージの指定
extern "C" int value ;
</pre>


<p>
{ }を使う方のリンケージ指定子は、複数の宣言に対して、一括して言語リンケージを指定するための文法である。
</p>


<pre>
// 関数名f, g, hは、すべてC言語リンケージを持つ
extern "C"
{
    void f() ;
    void g() ;
    void h() ;
}

// C_functions.hというヘッダーファイルで宣言されているすべての関数型、関数名、変数名は、C言語リンケージを持つ
extern "C"
{
    #include "C_functions.h"
}
</pre>

<p>
リンケージ指定をしない場合、デフォルトでC++言語リンケージだとみなされる。通常、C++言語リンケージを指定する必要はない。
</p>

<pre>
// デフォルトのC++言語リンケージ
void g() ;
// 明示的な指定
extern "C++" void g() ;
</pre>

<p>
リンケージ指定はネストすることができる。その場合、一番内側のリンケージ指定が使われる。言語リンケージは、スコープをつくらない。
</p>

<pre>
extern "C"
{
    void f() ; // C言語リンケージ
    extern "C++"
    {
        void g() ; // C++言語リンケージ
    }
}
</pre>

<p>
リンケージ指定は、名前空間スコープの中でのみ、使うことができる。ブロックスコープ内などでは使えない
</p>

<p>
C言語リンケージは、クラスのメンバーに適用しても無視される。
</p>

<pre>
extern "C"
{
    class C
    {
        void f() ; // C++言語リンケージ
    } ;
}
</pre>

<p>
C言語リンケージを持つ同名の関数が、複数あってはならない。これにより、C言語リンケージを持つ関数は、オーバーロードできない。
</p>

<pre>
extern "C"
{
// エラー、C言語リンケージを持つ同名の関数が複数ある
    void f(int) ;
    void f(double) ;
}

// OK、互いに異なる言語リンケージを持つ
void g() ;
extern "C" void g() ;
</pre>

<p>
このルールは、たとえ関数が名前付きの名前空間の中で宣言されていても、同様である。
</p>

<pre>
namespace A
{
    extern "C" void f() ;
}

namespace B
{
    extern "C" void f() ; // エラー、A::fとB::fは同じ関数を参照する
    void f() ; // OK、C++言語リンケージを持つ
}
</pre>

<p>
このように、たとえ名前空間が違ったとしても、C言語リンケージを持つ関数は、名前が衝突してはならない。これは、名前空間という仕組みが存在しないC言語からでも使えるようにするための仕様である。ただし、C言語リンケージを持つ関数を、C++側から、名前空間の中で宣言して、通常通り使うことはできる。
</p>

<pre>
namespace NS
{
    extern "C" void f() { }
}

int main()
{

    NS::f() ; // OK
}
</pre>

<p>
これにより、C言語で書かれた関数を、何らかの名前空間の中にいれて、C++側から使うこともできる。
</p>

<pre>
// ヘッダーファイル、C_functions.hは、C言語で書かれているものとする
namespace obsolate_C_lib
{
    extern "C"
    {
        #include "C_functions.h"
    }
}
</pre>
</article>

<article>
<h1 id="dcl.attr"><a href="#dcl.attr">アトリビュート（Attributes）</a></h1>

<p class="editorial-note">
TODO:attributeは変更される動きが見られるので保留。
</p>
</article>

</article>

<article class="toplevel">
<h1 id="dcl.decl"><a href="#dcl.decl">宣言子（Declarators）</a></h1>

<p>
<a href="#dcl.dcl">宣言</a>は、指定子と宣言子に分けることができる。宣言子は、変数、関数、型を宣言する。また、指定子によって指定された型を変更することもある。
</p>

<pre>
// 変数の例
int // 指定子、int型
x ; // 宣言子、xという名前のint型の変数

// 関数の例
int // 指定子
f(void) ; // 宣言子、fという名前のint (void)型の関数の宣言

// 型の例
typedef int // 指定子
type ; // 宣言子、typeという名前のint型の別名の宣言

// 指定子の型を変更する例
int // 指定子
* p ; // 宣言子（ポインター型の変数）
</pre>

<p>
宣言子をコンマで区切ることによって、ひとつの宣言の中で、複数の宣言子を書くことができる。ただし、ひとつの宣言の中で複数の宣言子を書くコードは、非常に分かりにくくなるので、やめたほうがよい。
</p>

<pre>
int         // 指定子
a,          // 宣言子、aという名前のint型の変数
* b,        // 宣言子、bという名前のint *型の変数
c(void) ;   // 宣言子、cという名前のint (void)型の関数
</pre>

<article>
<h1 id="dcl.name"><a href="#dcl.name">型名（Type names）</a></h1>

<p>
キャスト、sizeof、alignof、new、typeidでは、型の名前を指定する。これには、型名が用いられる。型名とは、変数や関数を宣言する場合と同じ指定子と宣言子だが、名前を省略したものである。
</p>

<pre>
int value ;         // int型の変数
int                 // 型名
int array[10] ;     // 配列型の変数
int [10]            // 型名
int (*p)(void) ;    // 関数ポインター型の変数
int (*)(void)       // 型名
</pre>

<p>
ただし、あまりにも複雑な型名は、typedefやエイリアス宣言でtypedef名を定義した方が分かりやすい。
</p>
</article>

<article>
<h1><a href="#dcl.ambig.res">曖昧解決（Ambiguity resolution）</a></h1>

<p>
宣言文は、文法上、曖昧になる場合がある。これは、通常気にする必要はない。ただし、まれにこの曖昧性に引っかかり、不可解なコンパイルエラーを引き起こす可能性がある。
</p>

<p>
仮引数名に無駄な括弧のある関数の宣言と、初期化式に関数形式のキャストを用いた変数の宣言は曖昧である。その場合、=が使われていると、初期化であるとみなされる。また、仮引数の周りの不必要な括弧は取り除かれる。その結果、変数の宣言のつもりで書いたコードが、関数の宣言とみなされてしまうことがある。
</p>

<pre>
struct S { S(int) { } } ;

int main()
{
    double d = 0.0 ;

    S w( int(d) ); // S(int)型の関数の宣言、dは仮引数名、無駄な括弧
    S x( int() ); // S(int)型の関数の宣言、仮引数名の省略、無駄な括弧

    S y( static_cast&lt;&gt;(d) ); // S型の変数yの宣言
    S z = int(d); // S型の変数zの宣言
}
</pre>

<p>
一般に、この曖昧解決の結果、変数を宣言したいのに、関数の宣言とみなされてしまい、コンパイルエラーになることがある。この文法上の曖昧性を避けるためには、static_castなどの他のキャストを使うか、=を使った初期化に書き換える必要がある。
</p>

<p>
関数形式のキャストと型名は、曖昧になることがある。例えば、int()というコードは、関数形式のキャストにも、int(void)型の関数の型名にも解釈できる。この場合、型名が期待される場所では、常に型名として解釈される。
</p>

<pre>
template &lt; int N &gt; struct C { } ;

int main()
{
    int x = int() ; // OK、intは関数形式のキャスト
    C&lt;int()&gt; ; // エラー、int()は型名
    C&lt;int(0)&gt; ; // OK
    
    sizeof(int()) ; // エラー、int()は型名
    sizeof(int(0)) ; // OK
}
</pre>
</article>

<article>
<h1 id="dcl.meaning"><a href="#dcl.meaning">宣言子の意味（Meaning of declarators）</a></h1>

<p>
<a href="#dcl.simple-declaration">単純宣言</a>は、指定子と宣言子で構成される。
</p>

<pre>
指定子 宣言子 ;
</pre>

<p>
宣言子は、必ず、識別子を持たなければならない。この識別子を、規格上では、宣言識別子（declarator-id）と名付けている。この識別子は、宣言される名前となる。
</p>

<pre>
int name1 ; // name1はint型の変数の名前
int * name2 ; // name2 はint *型の変数の名前
int name3(void) ; // name3 はint (void)型の関数の名前
</pre>

<p>
static, thread_local, extern, register, mutable, friend, inline, virtual, typedefといった指定子は、この宣言子の識別子に適用される。
</p>

<p>
宣言子の識別子の意味は、指定子と宣言子の組み合わせによって決定される。
</p>

<pre>
// 識別子aはint型の変数
int     // 指定子
a ;     // 宣言子、
// 識別子bはint型のtypedef名
typedef int // 指定子
c ;         // 宣言子
</pre>

<p>
変数、関数、型は、すべてこの指定子と宣言子の組み合わせによって宣言される。宣言子は、識別子の他にも、様々な文法があり、それによって、指定子の型を変更する。これには、ポインター、リファレンス、メンバーへのポインター、配列、関数、デフォルト実引数がある。
</p>

<article>
<h1 id="dcl.ptr"><a href="#dcl.ptr">ポインター（Pointers）</a></h1>

<p>
宣言子が以下のように記述されている場合、ポインターを意味する。
</p>

<pre>
* CV修飾子<sub>opt</sub> 識別子
</pre>

<pre>
int * a ; // intへのポインター型
</pre>

<p>
*に続くCV修飾子は、ポインター型に対するCV修飾子として解釈される。
</p>

<p>
int * constは、指定子intへのポインターに対するconstである。intに対するconstではない。const int *とint const *はどちらも同じ型である。const intもint constも指定子だからだ。
</p>

<pre>
typedef const int * type1 ;
typedef int const * type2 ;
typedef int * const type3 ;
</pre>

<p>
このように宣言されている場合、type1とtype2は同じ型である。type3は、type1やtype2とは別の型である。
</p>

<p>
宣言子の中に、ポインターは複数書くことができる。
</p>

<pre>
int obj ;
int * p = &amp;obj ;
int * * pp = &amp;p ;
int * * * ppp = &amp;pp ;

int const * * a ; // int const *へのポインター
int * const * b ; // int * constへのポインター
int * * const c = nullptr ; // int *へのconstなポインター
</pre>

<p>
T * *という型は、T *へのポインターということになる。
</p>

<p>
リファレンスへのポインターは存在しない。
</p>

<pre>
int &amp; * ptr_to_ref ; // エラー、リファレンスへのポインターは存在しない
</pre>

<p>
ビットフィールドのアドレスを取得することは禁止されているので、ビットフィールドへのポインターも存在しない。
</p>

<p>
関数へのポインターや、配列へのポインターは存在する。ただし、記述がやや難しい。コードの可読性を挙げるために、これらの型や変数を宣言するには、typedefやエイリアス宣言、autoなどを使うという手もある。
</p>

<pre>
void func( void ) { } // 型はvoid (void)

void g()
{
    void (*ptr_func)( void ) = &amp;func ;
    ref_func() ; // 関数呼び出し

    int array[5] ; // 型はint [5]
    int (*ptr_array)[5] = &amp;array ;
}
</pre>
</article>

<article>
<h1 id="dcl.ref"><a href="#dcl.ref">リファレンス（References）</a></h1>

<p>
宣言子が以下のように記述されている場合、リファレンスを意味する。
</p>

<pre>
&amp; 識別子
&amp;&amp; 識別子
</pre>

<p>
&amp;の場合、lvalueリファレンスとなり、&amp;&amp;の場合、rvalueリファレンスとなる。lvalueリファレンスとrvalueリファレンスは、ほとんど同じ働きをする。単にリファレンスといった場合、lvalueリファレンスとrvalueリファレンスの両方を指す。
</p>

<pre>
void f( int obj )
{
    int &amp; lvalue_reference = obj ;
    int &amp;&amp; rvalue_reference = static_cast&lt; int &amp;&amp; &gt;( obj ) ;

    lvalue_reference = 0 ; // objに0を代入
    rvalue_reference = 0 ; // objに0を代入
}
</pre>

<p>
リファレンスは、CV修飾できない。
</p>

<pre>
void f( int obj )
{
    int const &amp; a = obj ; // OK、int constへのリファレンス
    int &amp; const b = obj ; // エラー、リファレンスへのCV修飾はできない
}
</pre>

<p>
ただし、typedefやテンプレート実引数にCV修飾子が使われた場合は、単に無視される。
</p>

<pre>
// typedefの例
void f( void )
{
    int const &amp; a = 3 ; // OK、int constへのリファレンス
    typedef int &amp; type ;
    typedef const type type2 ; // type2の型はint &amp;
    const type b = 3 ; // エラー、bの型はint &amp;
}

// テンプレート実引数の例
template &lt; typename T &gt;
struct S
{
    typedef const T type ; 
} ;

void g()
{
    typedef S&lt; int &amp; &gt;::type type ; // type はint &amp;
}
</pre>

<p>
typedefの例では、typeというtypedef名にconst修飾子が使われているが、これは単に無視される。したがって、bの型は、int &amp;である。int &amp; constとはならないし、int const &amp;ともならない。
</p>

<p>
テンプレートの例では、テンプレート仮引数Tの実際の型が決定されるのは、テンプレート実引数が渡されて、インスタンス化されたときである。
</p>

<p>
void型へのリファレンスは存在しない。
</p>

<pre>
typedef void &amp; type ; // エラー
</pre>

<p>
リファレンスへのリファレンス、リファレンスの配列、リファレンスへのポインターは存在しない。
</p>

<pre>
typedef int &amp; &amp; type1 ; // エラー、リファレンスへのリファレンス
typedef int &amp; type2[5] ;   // エラー、リファレンスの配列
typedef int &amp; * type3 ;     // エラー、リファレンスへのポインター
</pre>

<p>
その他の型へのリファレンスは存在する。例えば、配列へのリファレンスや、関数へのリファレンスは存在する。ただし、ポインターと同じく、記述がやや難しい。
</p>

<pre>
void func( void ) { } // 型はvoid (void)

void g()
{
    void (&amp;ref_func)( void ) = func ;
    ref_func() ; // 関数呼び出し

    int array[5] ; // 型はint [5]
    int (&amp;ref_array)[5] = array ;
}
</pre>

<p>
リファレンスの宣言には、<a href="#dcl.init">初期化子</a>が必要である。
</p>

<pre>
void f()
{
    int obj ;

    int &amp; ref1 ; // エラー、初期化子がない
    int &amp; ref2 = obj ; // OK
}
</pre>

<p>
ただし、宣言がextern指定子を含む場合、クラスのメンバーの宣言である場合、関数の仮引数や戻り値の型の宣言である場合は、初期化子は必要ない。
</p>

<pre>
int obj ;

// クラスの例
struct S
{
    int &amp; ref ;
    S() : ref(obj) { }
} ;

// extern指定子の例
// このリファレンスは単なる宣言。
// 実態はどこか別の場所で定義されている
extern int &amp; external_ref ;

// 関数の仮引数と戻り値の型の例
int &amp; f( int &amp; ref ) { return ref ; }
</pre>

<p>
リファレンスは必ず、有効なオブジェクトか関数を参照していなければならない。nullリファレンスというものはあり得ない。なぜならば、nullリファレンスを作る方法というのは、nullポインターを参照することである。nullポインターを参照することは、それ自体が未定義動作となるので、規格の上では、合法にnullリファレンスを作ることはできない。
</p>

<pre>
void f()
{
    int * ptr = nullptr ;
    int &amp; ref = *ptr ; // エラー、nullポインターを参照している
}
</pre>

<p>
リファレンスのリファレンスは存在しないということはすでに延べた。ただし、見かけ上、リファレンスが重なるという場合が存在する。
</p>

<p>
typedef、テンプレート仮引数の型、decltype指定子が、Tへのリファレンス型であるとする。リファレンスというのは単なるリファレンスであり、lvalueリファレンスとrvalueリファレンスの両方を含む。その場合、この型に対するlvalueリファレンスを宣言した場合、Tへのlvalueリファレンスになる。一方、この型に対するrvalueリファレンスを宣言した場合、Tへのリファレンス型になる。
</p>

<p>
これはどういうことかというと、すでにリファレンス型であるtypedef、テンプレート仮引数、decltype指定子に対して、さらにリファレンスの宣言子を付け加えるという意味である。もし、この型に対して、lvalueリファレンスを宣言しようとした場合、元のリファレンス型の如何に関わらず、lvalueリファレンスとなる。rvalueリファレンスを宣言しようとした場合、元のリファレンス型になる。
</p>

<pre>
int main()
{
    typedef int &amp; lvalue_ref ; // lvalueリファレンス
    typedef int &amp;&amp; rvalue_ref ; // rvalueリファレンス

    // lvalueリファレンスを宣言しようとした場合
    // 元のリファレンス型が、lvalueリファレンスでもrvalueリファレンスでも、lvalueリファレンスになる
    typedef lvalue_ref &amp; type1 ; // int &amp;
    typedef rvalue_ref &amp; type2 ; // int &amp;

    // rvalueリファレンスを宣言しようとした場合
    // 元のリファレンス型になる
    typedef lvalue_ref &amp;&amp; type3 ; // int &amp;
    typedef rvalue_ref &amp;&amp; type4 ; // int &amp;&amp;
}
</pre>

<p>
換言すれば、lvalueリファレンスは優先され、rvalueリファレンスは無視されるということである。
</p>

<p>
リファレンスが、内部的にストレージを確保するかどうかは規定されていない。したがって、memcpyなどをつかい、リファレンスを他のストレージの上にコピーすることはできない。
</p>
</article>

<article>
<h1 id="dcl.mptr"><a href="#dcl.mptr">メンバーへのポインター（Pointers to members）</a></h1>

<p>
宣言子が以下のように記述されている場合、メンバーへのポインターを意味する。
</p>

<pre>
::<sub>opt</sub> ネストされたクラス名 * CV修飾子<sub>opt</sub> 識別子
</pre>

<pre>
struct S
{
    void func(void) { }
    int value ;
} ;

void ( S:: * ptr_func )( void ) = &amp;S::func ;
int S:: * ptr_value = &amp;S::value ;
</pre>

<p>
メンバーへのポインターは、クラスのstaticなメンバーを参照することはできない。また、リファレンス型のメンバーを参照することもできない
</p>

<pre>
struct S
{
    static void func(void) { }
    static int value ;
    int &amp; ref ;
} ;
int S::value ;

void ( S:: * p1 )( void ) = &amp;S::func ; // エラー
void ( *p2 ) (void) = &amp;S::func ; // OK
int S:: * p3 = &amp;S::value ; // エラー
</pre>

<p>
メンバーへのポインターは、ポインターとは異なる型である。staticメンバー関数へのポインターは、メンバー関数ポインターではなく、通常の関数ポインターである。
</p>
</article>

<article>
<h1><a href="#dcl.array">配列（Arrays）</a></h1>

<p>
宣言子が以下のように記述されている場合、配列を意味する。
</p>

<pre>
識別子 [ 定数式<sub>opt</sub> ] 
</pre>

<pre>
int a[5] ; // 要素数5のint型の配列
float b[123] ; // 要素数123のfloat型の配列
</pre>

<p>
型指定子と、配列以前の宣言子を合わせた型を、配列の要素型（element type）という。要素型は、void以外の基本型、ポインター型、メンバーへのポインター型、クラス、enum型、配列型でなければならない。要素型には、リファレンス型、void型、関数型、<a href="#class.abstract">抽象クラス</a>は使えない。
</p>

<pre>
int a[5] ; // void以外の基本型

int * b[5] ; // ポインター型

struct S { int value ; } ;
int S::*c[5] ; // メンバーへのポインター型

S d[5] ; // クラス

enum struct E{ value } ;
E e[5] ; // enum型
</pre>

<p>
配列に対する配列を作ることができる。これを、多次元配列（multidimensional array）という。
</p>

<pre>
int a[3][5][7] ;
</pre>

<p>
ここでは、aは3 × 5 × 7の配列である。詳しく言うと、aは要素数3の配列である。その各要素は、要素数5の配列である。その各要素は、要素数7のint型の配列である。
</p>

<p>
配列の定数式は、整数の定数式でなければならない。また、その値は、0より大きくなければならない。
</p>

<pre>
int a[0] ; // エラー
int b[-1] ; // エラー
</pre>

<p>
定数式は、配列の要素数を表す。今、定数式の値がNであるとすると、配列の要素数はN個であり、0からN-1までの数字を持って表される。その配列のオブジェクトは、連続したストレージ上に、N個の要素型のサブオブジェクトを持っていることになる。
</p>

<pre>
int main()
{
    constexpr int N = 5 ;
    int a[N] ; // 要素数5の配列
    a[0] = 0 ; // 最初要素
    a[4] = 0 ; // 最後の要素
}
</pre>

<p>
配列の定数式が省略された場合、要素数の不明な配列となる。これは不完全なオブジェクト型である。多次元配列の場合は、最初の配列の定数式のみ省略できる。
</p>

<p>
定数式の省略された配列は、不完全なオブジェクト型なので、不完全なオブジェクト型の使用が許可されている場所で使うことができる。
</p>

<pre>
typedef int a[] ; 
typedef int b[][5][7] ; // 最初の定数式のみ省略可
</pre>

<p>
また、関数の仮引数の型として使うことができる。
</p>

<pre>
void f( int parameter[] ) { }
</pre>

<p>
ただし、関数の仮引数の場合、型は、要素型への配列ではなく、要素型へのポインターに置き換えられる。詳しくは、宣言子の<a href="#dcl.fct">関数</a>を参照。
</p>

<p>
宣言に初期化子がある場合、配列の定数式を省略できる。この場合、要素数は、初期化子から決定される。
</p>

<pre>
int a[] = { 1, 2, 3 } ; // 型はint [3]
</pre>

<p>
詳しくは、初期化子の<a href="#dcl.init.aggr">アグリゲート</a>を参照
</p>
</article>

<article>
<h1 id="dcl.fct"><a href="#dcl.fct">関数（Functions）</a></h1>

<p class="editorial-note">
TODO: さらに詳しく説明する可能性あり。
</p>

<section>
<h1>関数の宣言方法</h1>

<p>
関数の宣言子には、文法が二つある。指定子がautoではない場合、以下の文法となる。
</p>

<pre>
識別子 ( 仮引数リスト ) CV修飾子<sub>opt</sub> リファレンス修飾子<sub>opt</sub> 例外指定<sub>opt</sub>
</pre>

<p>
この場合、指定子と、指定子に続く識別子以前の宣言子が、戻り値の型になる。
</p>

<pre>
int f( int ) ; // int型の引数を取り、int型の戻り値を返す関数
int * f( int, int ) ; // int型の引数とint型の引数を取り、int *型の戻り値を返す関数
</pre>

<p>
この例では指定子のint型は、戻り値の型を意味する。
</p>

<p>
指定子がautoの場合、以下の文法で関数を宣言できる。
</p>

<pre>
識別子 ( 仮引数リスト ) CV修飾子<sub>opt</sub> リファレンス修飾子<sub>opt</sub> 例外指定<sub>opt</sub> -&gt; 戻り値の型
</pre>

<p>
この場合、戻り値の型は、指定子ではなく、宣言子の中に記述される。
</p>

<pre>
auto f( int ) -&gt; int ; // int型の引数を取り、int型の戻り値を返す関数
auto f( int, int ) -&gt; int * ; // int型の引数とint型の引数を取り、int *型の戻り値を返す関数
</pre>

<p>
違いは、戻り値の型を指定子で指定するか、宣言子の最後で指定するかである。同じ名前と型の関数は、どちらの文法で宣言されたとしても、同じ関数となる。
</p>

<pre>
// 関数fの宣言
int f( int ) ;
// 同じ関数fの再宣言
auto f( int ) -> int ;
</pre>

<p>
指定子にautoを書く、新しい関数の宣言子では、戻り値の型を後置できる。この新しい関数の宣言子によって、戻り値の型名の記述に、仮引数名を使うことができる。例えば、今、二つの引数に、operator *を適用する関数を考える。
</p>

<pre>
template &lt; typename T1, typename T2 &gt;
??? multiply( T1 t1, T2 t2 )
{
    return t1 * t2 ;
}
</pre>

<p>
ここで、???という部分で、戻り値の型を指定したい。ところが、T1とT2に対してoperator +を適用した結果の型は、テンプレートをインスタンス化するまで分からない。
</p>

<pre>
struct Mass { } ;
struct Acceleration { } ;
struct Force { } ;
// ニュートンの運動方程式、F=ma
Force operator *( Mass, Acceleration ) { return Force() ; }

int main()
{
    Mass m ; Acceleration a ;
    Force f = multiply( m, a ) ;
}
</pre>

<p>
この例では、Massクラス型とAccelerationクラス型同士をかけ合わせると、結果はForceクラス型となる。すると、関数multiplyの戻り値の型は、式の結果の型でなければならない。一体どうするか。これには、decltypeが使える。decltypeは、式の結果の型を得る指定子である。
</p>

<pre>
int main()
{
    Mass m ; Acceleration a ;
    typedef decltype( m * a ) type ; // Force
}
</pre>

<p>
ところが問題は、従来の関数の文法では、戻り値を記述する場所では、まだ仮引数名が宣言されていないということである。
</p>

<pre>
template &lt; typename T1, typename T2 &gt;
decltype( t1 * t2 ) // エラー、t1とt2は宣言されていない
multiply( T1 t1, T2 t2 )
{
    return t1 * t2 ;
}
</pre>

<p>
これを解決するには、やや不自然なメタプログラミングの手法を用いるか、引数を後置できる文法を用いるしかない。新しい関数宣言の文法を用いれば、以下のように書ける。
</p>

<pre>
template &lt; typename T1, typename T2 &gt;
auto multiply( T1 t1, T2 t2 ) -&gt; decltype( t1 * t2 )
{
    return t1 * t2 ;
}
</pre>
</section>

<section>
<h1>仮引数リスト</h1>

<p>
仮引数リストは、コンマで区切られた0個以上の仮引数の宣言である。仮引数リストは、関数を呼び出す際に、実引数の型や数を指定する。
</p>

<pre>
void f( int i, float f, double d, char const * c ) ;
</pre>

<p>
仮引数リストが空である場合、引数を取らないことを意味する。仮引数が(void)の場合は特別なケースで、仮引数リストが空であることと同義である。
</p>

<pre>
// 引数を取らない関数
void f( ) ;
// 同じ意味
void f( void ) ;
</pre>

<p>
仮引数の名前は省略できる。<a href="#dcl.fct.def">関数の定義</a>に、仮引数の名前が書かれている場合、その名前が仮引数を表す。
</p>

<pre>
// OK、関数fの宣言、仮引数の名前がない
void f( int ) ;
// OK、同じ関数fの宣言、仮引数に名前がある
void f( int x ) ; 

// OK、同じ関数fの定義
void f( int x )
{
    x ; // 仮引数を表す
}
</pre>

<p>
関数の定義で、仮引数に名前が与えられていない場合、関数の本体から、実引数を使えない。ただし、実引数としては、渡されている。
</p>

<pre>
void f( int ) { /* 実引数を使えない */ }

int main()
{
    f( 0 ) ; // 実引数を渡すことには変わりない。
}
</pre>

<p>
仮引数の名前は、関数の型には影響を及ぼさない。以下はすべて、同じ関数である。型も同じである。オーバーロードではない。
</p>

<pre>
// 型はvoid (int, int)
void f( int foo, int bar ) ;
// 同じ関数fの宣言
void f( int bar, int foo ) ; 

// 同じ関数fの定義
void f( int hoge, int /*名前の省略*/ ) { }
</pre>
</section>

<section>
<h1>関数の型</h1>

<p>
関数の型として意味のあるものは、戻り値の型、仮引数の型リスト、リファレンス修飾子、CV修飾子である。関数の型は、以下のように決定される。
</p>

<p>
まず、仮引数リストの中のそれぞれの仮引数に対して、指定子と宣言子から、型を決定する。
</p>

<pre>
// 仮引数リスト：int
void f( int ) ;
// 仮引数リスト：int *, int *
void f( int *, int * ) ;
</pre>

<p>
このようにして得られた仮引数リストの型に対して、以下の変換を行う。
</p>

<p>
「T型への配列型」は、「T型へのポインター型」に置き換えられる。「関数型」は、「関数ポインター型」に置き換えられる。
</p>

<pre>
// void ( int * )
void f( int [3] ) ;
// void ( int * )
void g( int [] ) ;

// void ( void (*)(int) )
void h( void ( int ) ) ;
</pre>

<p>
この変換は、関数の本体の中でも有効である。
</p>

<pre>
void f( int array[5] )
{
// arrayの型は int *である。int [5]ではない
}

void g( void func( int ) )
{
// funcの型は、void (*)(int)である。void (int)ではない
}
</pre>

<p>
このようにして得られた仮引数の型のリストに対し、さらに変換が行われる。これ以降の変換は、関数の型を決定するための変換であり、関数本体の中の引数の型には影響しない。
</p>

<p>
トップレベルのCV修飾子を消す。
</p>

<pre>
// void (int)
void f( const volatile int ) ;
// void (int const *)
void g( int const * const ) ;

// void (int)
void h( const int x )
{
// 関数の本体では、xの型はconst int
}
</pre>

<p>
関数の本体の中では、引数の型には、トップレベルのCV修飾子も含まれる。しかし、関数の型としては、仮引数に指定されたトップレベルのCV指定子は影響しない。
</p>

<p>
仮引数の名前がdecltypeに使われている場合、型は、配列からポインター、関数から関数ポインターへの変換が行われた後の型となる。トップレベルのCV修飾子は残る。
</p>

<pre>
// void ( int *, int * )
void f( int a[10], decltype(a) b)  ;
// void ( int, int const * ) ;
void g( int const a, decltype(a) * b)  ;
</pre>

<p>
仮引数の型に影響を与える<a href="#dcl.stc">ストレージクラス指定子</a>を消す。
</p>

<pre>
// void (int)
void f( regisiter int ) ; 
</pre>

<p>
ただし、現行のC++には、仮引数の型に影響を与えるストレージクラス指定子は、regisiterだけである。regisiterの使用は推奨されていない。
</p>

<p>
上記の変換の結果を、仮引数の型リスト（parameter-type-list）という。
</p>

<p>
関数が非staticなメンバー関数の場合、CV修飾子があるかどうかが、型として考慮される。
</p>

<pre>
struct S
{
    // void S::f(void)
    void f() ;
    // void S::f(void) const
    void f() const ;
} ;
</pre>

<p>
関数が非staticなメンバー関数の場合、リファレンス修飾子があるかどうかが、型として考慮される。
</p>

<pre>
struct S
{
    // void S::f(void) &amp;
    void f() &amp; ; 
    // void S::f(void) &amp;&amp;
    void f() &amp;&amp; ;

    // リファレンス修飾子が省略された関数
    void g() ;
} ;
</pre>

<p>
メンバー関数に対するCV修飾子とリファレンス修飾子については、<a href="#class.mfct.non-static">非staticメンバー関数</a>を参照。リファレンス修飾子については、<a href="#over.match.funcs">オーバーロード解決の候補関数と実引数リスト</a>も参照。
</p>

<p>
この他の記述、仮引数名やデフォルト実引数や例外指定は、関数の型には影響しない。
</p>

<pre>
// void f(int)
void f( int param = 0 ) noexcept ;
</pre>

<p>
関数の戻り値の型には、関数や配列を使うことはできない。
</p>

<pre>
// エラー
auto f() -&gt; void (void);
auto f() -&gt; int [5] ;
</pre>

<p>
ただし、関数や配列へのポインターやリファレンスは、戻り値の型として使うことができる。
</p>

<pre>
// OK、ポインター
auto f() -&gt; void (*)(void);
auto f() -&gt; int (*)[5] 
// OK、リファレンス
auto f() -&gt; void (&amp;)(void);
auto f() -&gt; int (&amp;)[5]
</pre>


<p>
同じ名前で、型の違う関数を、同じスコープ内で複数宣言して使うことができる。これを、関数のオーバーロードという。詳しくは<a href="#over">オーバーロード</a>項目を参照。
</p>
</section>

</article>

<article>
<h1 id="dcl.fct.default"><a href="#dcl.fct.default">デフォルト実引数（Default arguments）</a></h1>

<p>
仮引数に対して、=に続けて式が書かれていた場合、その式は、デフォルト実引数として用いられる。デフォルト実引数は、関数呼び出しの際に、実引数が省略された場合、かわりに引数として渡される。
</p>

<pre>
void f( int x = 123, int y = 456 ) { }

int main()
{
    f( ) ; // f( 123, 456 )と同じ
    f( 0 ) ; // f( 0, 456 )と同じ
    f( 1, 2 ) ; // デフォルト実引数を使用しない
}
</pre>

<p>
式は、単にリテラルでなくてもよい。
</p>

<pre>
int f() { return 0 ; }
void g( int x = f() ) { }
</pre>

<p>
関数の呼び出しの再に、前の実引数を省略して、あとの実引数を指定することはできない。
</p>

<pre>
void f( int x = 123, int y = 456 ) { }
int main()
{
    f( , 0 ) ; // エラー
}
</pre>

<p>
デフォルト実引数は、関数のパラメーターパックに指定することはできない。
</p>

<pre>
template &lt; typename ... Types &gt;
void f( Types .. args = 0 ) ; // エラー
</pre>

<p>
デフォルト実引数は、後から付け加えることも出来る。ただし、再宣言してはいけない。たとえ同じ式であったとしても、再宣言はできない。
</p>

<pre>
void f( int ) ;
// OK、デフォルト実引数を付け加える
void f( int x = 0 ) ;
// エラー、デフォルト実引数の再宣言
void f( int x = 0 ) ; 
// 定義
void f( int x ) { }
</pre>

<p>
可読性のためには、デフォルト実引数は、関数の最初の宣言に記述すべきである。
</p>

<pre>
void f( int = 0 ) ; // 宣言
void f( int ) { } // 定義
</pre>

<p>
デフォルト実引数が使われる場合、式は、関数呼び出しの際に、毎回評価される。評価の順序は規定されていない。
</p>
</article>

</article>

<article>
<h1 id="dcl.fct.def"><a href="#dcl.fct.def">関数の定義（Function definitions）</a></h1>

<p class="editorial-note">
TODO: FDIS後のdefault化とdelete定義の関数の本体への移行に対応すること。
</p>

<pre>
関数の定義:
    関数の宣言 関数の本体
    関数の宣言 = default ;
    関数の宣言 = delete ;

関数の本体:
    コンストラクター初期化子<sub>opt</sub> 複合文
    関数tryブロック
</pre>

<p>
関数の定義とは、関数の宣言に続けて、関数の本体の書かれている関数宣言である。
</p>

<pre>
void f() ; // 宣言
void f() {} // 定義

void // 指定子
g () // 宣言子
{ } // 関数の本体
</pre>

<p>
関数は、名前空間スコープか、クラススコープの中でのみ、定義できる。
</p>

<pre>
// グローバル名前空間スコープ
void f() {}
// クラススコープ
struct S { void f() {} } ;

void g()
{
    void h(){} ; // エラー、関数のブロックスコープの中では定義できない
}
</pre>

<p>
コンストラクター初期化子は、クラスのコンストラクターで用いる。詳しくは、クラスの<a href="#class.ctor">コンストラクター</a>と、クラスの<a href="#class.init">初期化</a>を参照。
</p>

<p>
関数の定義には、複合文の他に、関数tryブロックを使うこともできる。
</p>

<pre>
void f()
try
{
// 関数の本体
}
catch(...)
{
// 例外ハンドラー
} 
</pre>

<p>
関数tryブロックについて詳しくは、<a href="#except">例外</a>を参照。
</p>

<p>
関数の本体では、__func__（ダブルアンダースコアであることに注意）という名前の変数が、以下のようにあらかじめ定義されている。
</p>

<pre>
static const char __func__[] = "関数名" ;
</pre>

<p>
「関数名」とは、実装依存の文字列である。C++規格では、この実装依存の文字列の意味は、何も規定されていない。この機能はC言語から取り入れられたものである。C99規格では、関数本体の属する関数の名前を表す、実装依存の文字列とされている。いずれにせよ、具体的な文字列については、何も規定されていない。
</p>


<article>
<h1 id="dcl.fct.def.default"><a href="#dcl.fct.def.default">default定義（Explicitly-defaulted functions）</a></h1>

<pre>
関数の宣言 = default ;
</pre>

<p>
関数の宣言に続けて、= default ;と書く関数の定義を、明示的にデフォルト化された関数（Explicitly-defaulted functions）という。本書では、default定義と呼ぶ。
</p>

<p>
明示的にデフォルト化された関数は、<a href="#special">特別なメンバー関数</a>でなければならない。また、暗黙的に定義された場合と同等の型でなければならない。デフォルト実引数と例外指定は使えない。
</p>

<p>
明示的なデフォルト化は、暗黙の定義と同等の定義を、明示的に定義するための機能である。
</p>

<pre>
struct S
{
    S() = default ; // default定義
    S(int){ } 
} ;
</pre>

<p>
この例では、もし、明示的なデフォルト化が書かれていない場合、Sのデフォルトコンストラクターは、暗黙的に定義されない。
</p>

<p>
明示的にデフォルト化された関数を、暗黙的に定義される関数をあわせて、デフォルト化された関数（defaulted function）という。
</p>
</article>

<article>
<h1 id="dcl.fct.def.delete"><a href="#dcl.fct.def.delete">delete定義（Deleted definitions）</a></h1>

<pre>
関数の宣言 = delete ;
</pre>

<p>
関数の宣言に続けて、= delete ; と書く関数の定義を、削除された定義（Deleted definitions）という。また、本書では、分かりやすさのため、delete定義と呼ぶ。
</p>

<p>
削除された関数定義は、宣言として存在しているが、定義のない関数である。宣言としては存在しているので、名前解決やオーバーロード解決、テンプレートのインスタンス化の際には、通常通り考慮される。
</p>

<p>
ただし、削除された関数定義を、宣言以外の方法で参照した場合、エラーとなる。参照というのは、明示的、暗黙的に関数を呼び出すことや、関数へのポインター、メンバーポインター、リファレンスを得ることなどである。また、たとえ未評価式の中であっても、参照した場合エラーとなる。
</p>

<pre>
// 削除された関数の定義
void f() = delete ;

void f() ; // OK、宣言はできる

int main()
{
    f() ; // エラー、削除された関数の呼び出し
    &amp;f ; // エラー、削除された関数のポインターを得ようとしている
    void (&amp; ref )(void) = f ; // エラー、削除された関数のリファレンスを得ようとしている
    typdef decltype(f) type ; // エラー、未評価式の中で、削除された関数を参照している
}
</pre>

<p>
削除された関数の定義は、関数の最初の宣言でなければならない。
</p>

<pre>
void f() ; // 削除された定義ではない
void f() = delete ; // エラー、最初の宣言でなければならない

void g() = delete ; // OK、最初の宣言
void f() ; // OK、再宣言
</pre>

<p>
ただし、関数テンプレートの特殊化の場合、最初の特殊化の宣言となる。
</p>

<pre>
template &lt; typename T &gt;
void f( T ) { } // primary template

// 特殊化
template &lt; &gt;
void f&lt;int&gt;(int) = delete ;

int main()
{
    f(0) ; // エラー
    f(0.0) ; // OK
}
</pre>

<p>
関数がオーバーロードされている場合、オーバーロード解決によって、削除された関数定義が参照される場合のみ、エラーとなる。
</p>

<pre>
void f( int ) {} // 削除されていない関数
void f( double ) = delete ; // 削除された関数定義

int main()
{
    f( 0 ) ; // OK、void f(int)は削除されていない
    f( 0.0 ) ; // エラー、削除された関数の参照
}
</pre>

<p>
関数のオーバーロード、関数テンプレート、削除された定義を組み合わせると、非常に面白い事ができる。
</p>

<pre>
template &lt; typename T &gt;
void f( T ) { }

// 特殊化でdoubleでインスタンス化された場合の定義を削除
template &lt; &gt;
void f&lt;double&gt;(double) = delete ;

void call_f()
{
// doubleでインスタンス化した場合、エラーになる
    f( 0 ) ; // OK
    f( true ) ; // OK
    f( 0.0 ) ; // エラー
}

// あらゆるインスタンス化を削除
template &lt; typename T &gt;
void g( T ) = delete ;

// 削除されていない定義
template &lt; &gt;
void g&lt; double &gt;( double ) { }

void call_g()
{
// double以外でインスタンス化した場合、エラーになる
    g( 0 ) ; // エラー
    g( true ) ; // エラー
    g( 0.0 ) ; // OK   
}

// 非テンプレートな関数
void h( int ) { }

// 関数テンプレートの定義を削除
template &lt; typename T &gt;
void h( T ) = delete ;

void call_h()
{
// intへの標準型変換を禁止
    h( 0 ) ; // OK、非テンプレートな関数を呼び出す
    h( true ) ; // エラー、関数テンプレート
    h( 0.0 ) ; // エラー、関数テンプレート
}

void i( int ) = delete ;
void i( double ) { }

void call_i()
{
// intからdoubleへの標準変換をエラーにする
    i( 0 ) ; // エラー、
    i( true ) ; // OK
    i( 0.0 ) ; // OK
}
</pre>


<p>
このように、削除された定義を使うことで、意図しない標準型変換やインスタンス化を阻害できる。
</p>

<p>
削除された関数定義の具体的な使い方は、実に様々な例が考えられる。ここでは、その一部を挙げる。
</p>

<p>
クラスのコンストラクターを制御する。
</p>

<pre>
struct Boolen
{
    Boolen( ) = delete ;
    Boolen( bool ) { }

    template &lt; typename T &gt;
    Boolen( T ) = delete ;
} ;

int main()
{
    Boolen a = true ; // OK
    Boolen b = 123 ; // エラー
    Boolen c = &amp;a ; // エラー
}
</pre>

<p>
Boolenクラスは、必ず、ひとつのbool型の引数で初期化しなければならない。このクラスの初期化の際に、bool以外の型を渡すと、テンプレートのインスタンス化とオーバーロード解決により、関数テンプレート版のコンストラクターが優先される。しかし、定義は削除されているため、エラーとなる。結果的に、暗黙の型変換を禁止しているのと同じ意味となる。そのため、意図しない数値やポインターでの初期化という、つまらないバグを防げる。
</p>

<p>
クラスのオブジェクトをnewで生成することを禁止する。
</p>

<pre>
struct Do_not_new
{
    void *operator new(std::size_t) = delete;
    void *operator new[](std::size_t) = delete;
} ;

int main()
{
    Do_not_new a ; // OK
    Do_not_new * ptr = new Do_not_new ; // エラー
    Do_not_new * array_ptr = new Do_not_new[10] ; // エラー
}
</pre>

<p>
何らかの理由で、あるクラスのオブジェクトを、newで生成してほしくないとする。削除された定義を使えば、あるクラスに対して、newを禁止できる。
</p>

<p>
クラスのコピーを禁止する。
</p>

<pre>
struct move_only
{
    move_only() = default ;
    ~move_only() = default ;

    move_only( const move_only &amp; ) = delete ;
    move_only( move_only &amp;&amp; ) = default ;
    move_only &amp; operator = ( const move_only &amp; ) = delete ;
    move_only &amp; operator = ( move_only &amp;&amp; ) = default ;
} ;

int main()
{
    move_only m ;
    move_only n ;

    n = m ; // エラー、コピーは禁止されている
    n = std::move(m) ; // OK、ムーブはできる
}
</pre>

<p>
クラスmove_onlyは、ムーブができるが、コピーはできないクラスになる。
</p>
</article>

</article>


<article>
<h1 id="dcl.init"><a href="#dcl.init">初期化子（Initializers）</a></h1>

<p>
宣言子の宣言する変数に対して、初期値を指定することができる。この初期値を指定するための文法を、初期化子（Initializer）という。この初期化子の項目で解説している初期化は、宣言文以外にも、関数の仮引数を実引数で初期化することや、関数の戻り値の初期化、new式やクラスのメンバー初期化子などにも適用される。
</p>

<p>
初期化子の文法と意味について解説する前に、まず基本的な三つの初期化について解説しなければならない。ゼロ初期化、デフォルト初期化、値初期化である。
</p>

<article>
<h1 id="dcl.init.zero-initialize"><a href="#dcl.init.zero-initialize">ゼロ初期化（zero-initialize）</a></h1>
<p>
ゼロ初期化（zero-initialize）とは、T型のオブジェクトやリファレンスに対して、
</p>

<p>
Tがスカラー型の場合、整数の定数、0を、T型に変換して初期化する。
</p>

<pre>
static int x ; // 0で初期化される
static float f ; // 0がfloat型に変換されて初期化される
static int * ptr ; // 0がnullポインターに変換されて初期化される
</pre>

<p>
Tがunionではないクラス型の場合、非staticなデータメンバーと基本クラスのサブオブジェクトが、それぞれゼロ初期化される。また、アライメント調整などのための、オブジェクト内のパディングも、ゼロビットで初期化される。
</p>

<pre>
struct Base { int x ; } ;
struct Derived : Base
{
    int y ;
} ;

// 非staticなデータメンバー、基本クラスのサブオブジェクトが、それぞれゼロ初期化される
static Derived d ;
</pre>

<p>
この例では、Derivedのデータメンバーであるyと、基本クラスであるBaseのオブジェクトがゼロ初期化される。Baseをゼロ初期化するということは、Baseのデータメンバーであるxもゼロ初期化される。
</p>

<p>
Tがunion型の場合、オブジェクトの最初の、非staticな名前のつけられているデータメンバーが、ゼロ初期化される。また、アライメント調整などのための、オブジェクト内のパディングも、ゼロビットで初期化される。
</p>

<pre>
union U
{
    int x ;
    double d ; 
} ;
</pre>

<p>
このunionのオブジェクトをゼロ初期化した場合、U::xがゼロ初期化される。
</p>

<p>
Tが配列型の場合、各要素がそれぞれゼロ初期化される。
</p>

<p>
Tがリファレンス型の場合、初期化は行われない。
</p>
</article>

<article>
<h1 id="dcl.init.default-initialize"><a href="#dcl.init.default-initialize">デフォルト初期化（default-initialize）</a></h1>

<p>
デフォルト初期化（default-initialize）とは、T型のオブジェクトに対して、
</p>

<p>
Tがクラス型の場合、Tのデフォルトコンストラクターが呼ばれる。デフォルトコンストラクターにアクセス出来ない場合は、エラーである。
</p>

<pre>
class A
{
public :
    A() { }
} ;

class B
{
private :
    A() { }
} ;

int main()
{
    A a ; // デフォルトコンストラクターが呼ばれる
    B b ; // エラー、デフォルトコンストラクターにアクセスできない
}
</pre>

<p>
Tが配列型の場合、各要素がそれぞれデフォルト初期化される。
</p>

<p>
上記以外の場合、初期化は行われない。
</p>

<pre>
int main()
{
    int x ; // 初期化は行われない
}
</pre>

<p>
const修飾された型をデフォルト初期化する場合、型はユーザー定義コンストラクターを持つクラス型でなければならない。
</p>

<pre>
struct X { } ;
struct Y { Y() { } } ;

int main ()
{
    int const a ; // エラー、intはユーザー定義コンストラクターを持つクラス型ではない
    X const b ; // エラー、Xはユーザー定義コンストラクターを持つクラス型ではない

    Y const c ; // OK
}
</pre>

<p>
リファレンス型をデフォルト初期化しようとした場合、エラーになる。
</p>

</article>

<article>
<h1 id="dcl.init.value-initialize"><a href="#dcl.init.value-initialize">値初期化（value-initialize）</a></h1>

<p>
値初期化（value-initialize）とは、T型のオブジェクトに対して、
</p>

<p>
Tがクラス型で、ユーザー提供のコンストラクターを持つ場合、Tのデフォルトコンストラクターが呼ばれる。デフォルトコンストラクターにアクセス出来ない場合は、エラーである。
</p>

<pre>
struct S
{
    S() { }
    int x ; 
} ;
</pre>

<p>
クラスSのオブジェクトを値初期化した場合、Sのデフォルトコンストラクターが呼ばれる。xの値は不定である。
</p>

<p>
Tが、unionではないクラス型で、ユーザー提供のコンストラクターを持たない場合、オブジェクトはゼロ初期化される。もし、暗黙的に定義されたコンストラクターが、トリビアルではない場合、コンストラクターが呼ばれる。
</p>

<pre>
struct A
{
    A() {  }
} ;

struct B
{
// ユーザー提供のコンストラクターがない
// 暗黙に定義されたコンストラクターはトリビアルではない
    A a ;
    int x ;
} ;
</pre>

<p>
クラスBのオブジェクトを値初期化した場合、Aのデフォルトコンストラクターが呼ばれる。また、xはゼロ初期化される。
</p>

<p>
Tが配列型の場合、各要素がそれぞれ値初期化される。
</p>

<p>
上記以外の場合、オブジェクトはゼロ初期化される。
</p>

<p>
リファレンス型をゼロ初期化しようとした場合、エラーとなる。
</p>

<h1><a>初期化の文法と方法</a></h1>
<p>
staticストレージの期間を持つオブジェクトは、プログラムの開始時に、必ずゼロ初期化される。その後、必要であれば、初期化される。
</p>

<pre>
struct S
{
    S() : x(1) { }
    int x ;
} ;

S s ;// staticストレージの期間を持つオブジェクト
</pre>

<p>
ここでは、Sのデフォルトコンストラクターが実行される前に、データメンバーのxはゼロ初期化されている。
</p>

<p>
初期化子が空の括弧、()、であるとき、オブジェクトは値初期化される。ただし、通常の宣言文では、初期化子として空の括弧を書く事はできない。なぜならば、空の括弧は、関数の宣言であるとみなされるからだ。
</p>

<pre>
int main()
{
    int x() ; // int (void)型の関数xの宣言
}
</pre>

<p>
初期化子としての空の括弧は、<a href="#expr.new">new</a>、<a href="#expr.type.conv">関数形式の明示的型変換</a>、<a href="#class.base.init">基本クラスとデータメンバーの初期化子</a>で使うことができる。
</p>

<pre>
struct S
{
    S()
    : x() // メンバー初期化子
    { }
    int x ;
}

int main()
{
    new int() ; // new、初期化子として空の括弧
    int() ; // 関数形式のキャスト
}
</pre>


<p>
初期化子が指定されていない場合、オブジェクトはデフォルト初期化される。
</p>

<pre>
struct S { } ;

int main()
{
    S s ; // デフォルト初期化される
}
</pre>

<p>
デフォルト初期化では、すでに説明したように、クラス以外の型は、初期化が行われない。初期化が行われないオブジェクトの値は、不定である。
</p>

<pre>
int main()
{
    int i ; // 値は不定
    double d ; // 値は不定
}
</pre>

<p>
ただし、staticやthreadストレージの有効期間を持つオブジェクトは、ゼロ初期化されることが保証されている。
</p>

<pre>
// グローバル名前空間
int x ; // staticストレージ、ゼロ初期化される
thread_local int y ; // threadストレージ、ゼロ初期化される
</pre>

<p>
以下のような文法の初期化子を、コピー初期化（copy-initialization）という。
</p>

<pre>
T x = a ;
</pre>

<p>
これに加えて、関数の実引数を渡す、関数のreturn文、例外のthrow文、例外を受ける、アグリゲートのメンバーの初期化も、コピー初期化という。この「コピー」という言葉は、コピーコンストラクターやコピー代入演算子とは関係がない。コピー初期化でも、コピーではなく、ムーブされることもある。
</p>

<p>
以下のような文法の初期化子を、直接初期化（direct-initialization）という。
</p>

<pre>
T x(a) ;
T x{a} ;
</pre>

<p>
これに加えて、<a href="#expr.new">new</a>、<a href="#expr.static.cast">static_cast</a>、<a href="#expr.type.conv">関数形式のキャスト</a>、<a href="#class.base.init">基本クラスとデータメンバーの初期化子</a>も、直接初期化という。
</p>

<p>
初期化子の意味は、以下のように決定される。オブジェクトの型を、目的の型（destination type）とし、初期化子の型を、元の型（source type）とする。元の型は、初期化子が、ひとつの初期化リストか、括弧で囲まれた式リストの場合は、存在しない。
</p>

<pre>
// 目的の型はT
// 元の型はint
T x = 0 ;

// 目的の型はT
// 元の型は存在しない（ひとつの初期化リスト）
T x = { } ;
T x({ }) ;
T x{ } ;

// 目的の型はT
// 元の型は存在しない（括弧で囲まれた式リスト）
T x(1, 2, 3)
</pre>

<p>
初期化子が、ひとつの初期化リストの場合、<a href="#dcl.init.list">リスト初期化</a>される。
</p>

<pre>
// リスト初期化される
T x = { } ;
T x({ }) ;
T x{ } ;
</pre>

<p>
目的の型がリファレンスの場合、<a href="#dcl.init.ref">リファレンス</a>を参照。
</p>

<p>
目的の型が、char、signed char、unsigned char、char16_t、char32_t、wchar_tの配列で、初期化子が文字列リテラルの場合、<a href="#dcl.init.string">文字配列</a>を参照。
</p>

<p>
初期化子が空の()の場合、オブジェクトは値初期化される。
</p>

<p>
ただし、通常の変数の宣言では、空の()を書く事はできない。なぜならば、空の括弧は、関数の宣言とみなされるからだ。
</p>

<pre>
// int (void)型の関数xの宣言
// int x(void) ; と同じ
int x() ; 
</pre>

<p>
空の()を書く事ができる初期化子には、<a href="#expr.type.conv">関数形式のキャスト</a>、<a href="#expr.new">new</a>、<a href="#class.base.init">メンバー初期化</a>がある。
</p>

<pre>
 // 関数形式のキャスト
int x = int() ;
// new
new int() ;

// メンバー初期化
class C
{
    int member ;
    C() : member()
    { }
} ;
</pre>

<p>
{}や、空の初期化リストを含む({})は、文法上曖昧とならないので、宣言文でも書ける。詳しくは<a href="#dcl.init.list">リスト初期化</a>で解説するが、この場合も、オブジェクトは値初期化される。
</p>

<pre>
int x{} ; // int型の変数xの宣言と定義と初期化子
int y({}) ; // int型の変数yの宣言と定義と初期化子
</pre>

<p>
それ以外の場合で、目的の型が配列型の場合、エラーとなる。これは、初期化子がある場合で、上記のいずれにも該当しない場合を指す。
</p>

<pre>
int a[5] = 0 ; // エラー、int [5]型は、int型で初期化できない
</pre>

<p>
目的の型がクラス型で、初期化子が直接初期化である場合、最も最適なコンストラクターが、オーバーロード解決によって選ばれる。
</p>

<pre>
struct Elem { } ;

struct S
{
    S( int ) { }
    S( Elem ) { }
} ;

int main()
{
    S s1( 0 ) ; // S::S(int)
    S s2( 0.0 ) ; // S::S(int)、標準型変換による

    Elem elem ;
    S s3( elem ) ; // S::S(Elem)
}
</pre>

<p>
コンストラクターが適用できなかったり、曖昧である場合は、エラーとなる。
</p>

<pre>
struct S
{
    S( long ) { }
    S( long long ) { }
} ;

struct Elem { } ;

int main()
{
    S s1 ( 0 ) ; // エラー、コンストラクターが曖昧
    Elem elem ;
    S s2( elem ) ; // エラー、適切なコンストラクターが見つからない
}
</pre>

<p>
目的の型がクラス型で、初期化子がコピー初期化で、初期化子の型が目的の型か、その派生クラス型である場合、直接初期化と同じ方法で初期化される。初期化子の型が目的の型か、その派生クラス型でない場合は、後述。
</p>

<pre>
struct Base { } ;
struct Derived : Base { } ;

int main()
{
    Base b1 = Base() ; 
    Base b2 = Derived() ;
}
</pre>

<p>
目的の型がクラス型で、初期化子がコピー初期化の場合（ただし上記を除く）、ユーザー定義の型変換が試みられ、最適な候補が、オーバーロード解決によって選ばれる。
</p>

<pre>
struct Elem { } ;
struct Integer
{
    operator int () const { return 0 ; }
} ;

struct S
{
    S( int ) { }
    S( Elem ) { }
} ;

int main()
{
    S s1 = 0 ; // コンストラクターによる変換、S::S(int)
    S s2 = 0.0 ; // 標準型変換の結果、S::S(int)
    S s3 = Elem() ; // コンストラクターによる変換、S::S(Elem)
    S s4 = Integer() ; // Integer::operator int()が呼ばれ、次にS::S(int)
}
</pre>

<p>
型変換できなかったり、型変換が曖昧である場合は、エラーとなる。
</p>

<pre>
struct A { } ;
struct B { } ;

struct C
{
    C( long ) { }
    C( long long ) { }
} ;

int main()
{
    A a ;
    B b = a ; // エラー、変換関数が見つからない
    C c = 0 ; // エラー、変換関数が曖昧
}
</pre>

<p>
それ以外の場合、つまり、目的の型がクラス型ではない場合で、初期化子の型がクラスであった場合、目的の型に型変換が試みられ、最適な候補がオーバーロード解決によって選択される。型変換ができない場合や、曖昧な場合は、エラーとなる。
</p>

<pre>
struct S
{
    operator int() { return 0 ; }
} ;

int main()
{
    S s ;
    int x = s ; // OK、S::operator int()が呼ばれる
}
</pre>

<p>
それ以外の場合、つまり、目的の型も初期化子の型も、クラスではない場合、標準型変換が試みられる。ユーザー定義の変換関数は考慮されない。型変換ができない場合、エラーとなる。
</p>

<pre>
int main()
{
    int i = 0 ;
    float f = i ; // OK、整数から浮動小数点数へ型変換される
    int * p = f ; // エラー、floatはint *に変換できない
}
</pre>
</article>

<article>
<h1 id="dcl.init.aggr"><a href="#dcl.init.aggr">アグリゲート（Aggregates）</a></h1>

<p>
アグリゲート（aggregate）とは、配列か、いくつかの制約を満たしたクラスである。クラスの場合、ユーザー定義のコンストラクター、非staticデータメンバーの初期化子、privateおよびprotectedな非staticデータメンバー、基本クラス、virtual関数が存在しないものだけを、アグリゲートという。
</p>

<p>
以下は、アグリゲートの例である。
</p>

<pre>
struct Aggregate
{
// 非staticデータメンバーはすべてpublic
    int x ;
    float y ;

// 非virtualなメンバー関数
    void f() { }
// staticデータメンバーはpublicでなくてもよい
private :
    int data ;
} ;
int Aggregate::data ;

int a[10] ;
Aggregate b ;
Aggregate c[10] ;
</pre>


<p>
以下はアグリゲートの条件を満たさないクラスの例である。
</p>

<pre>
struct Base { } ;

struct NonAggregate
    : Base // 基本クラス
{
// ユーザー定義のコンストラクター
    NonAggregate() { }
// 非staticデータメンバーの初期化子
    int x = 0 ;
// privateおよびprotectedな非staticデータメンバー
private:
    int y ;
protected ;
    int z ;
// virtual関数
    virtual void f() { }
} ;
</pre>

<p>
配列は必ずアグリゲートである。たとえアグリゲートではないクラス型であっても、そのクラスの配列型は、アグリゲートとなる。
</p>

<pre>
// アグリゲートではないクラス
struct NonAggregate
{
    NonAggregate() { }
} ;

NonAggregate a[3] ; // アグリゲート
</pre>

<p>
アグリゲートが初期化リストで初期化される場合、初期化リストの対応する順番の要素が、それぞれアグリゲートのメンバーの初期化に用いられる。メンバーはコピー初期化される。
</p>

<pre>
// 配列の例
int a[3] = { 1, 2, 3 } ;
// 各要素の初期化、a[0] = 1, a[1] = 2, a[2] = 3

// クラスの例
struct S
{
    int x ; int y ;
    double d ;
} ;

S s = { 1, 2, 3.0 } ;
// 各メンバーの初期化は、s.x = 1, s.y = 2, s.d = 3.0

// クラスの配列の例
S sa[3] =
{
    { 1, 2, 3.0 },
    s, s
} ;

// アグリゲートではないクラスの配列の例
class C
{
    int value ;
public :
    C(int value) : value(value) { }
} ;

C obj( 3 ) ; // クラスのオブジェクト

// 配列はアグリゲート
C ca[3] = { 1, 2, obj } ;
// コピー初期化を適用した結果、C::C(int)が呼び出される
// ca[0]は1、ca[1]は2、ca[2]はobjで、それぞれ初期化される
</pre>

<p>
初期化の際に、縮小変換が必要な場合、エラーである。
</p>

<pre>
int a( 0.0 ) ; // OK
int b{ 0.0 } ; // エラー、縮小変換が必要

struct S { int x ; } ;
S s = { 0.0 } ; // エラー、縮小変換が必要
</pre>

<p>
初期化リストが、内部に初期化リストを含む場合、アグリゲートの対応するメンバーは、初期化リストによって初期化される。
</p>

<pre>
struct Inner { int x ; int y ;  } ;
struct Outer
{
    int x ;
    Inner obj ;
} ;

Outer a = { 1, { 1, 2 } } ;
// a.x = 1, a.obj = { 1, 2 }
// a.obj.x = 1, a.obj.y = 2
</pre>

<p>
要素数不定の配列のアグリゲートが、初期化リストで初期化される場合、配列の要素数は、初期化リストの要素数になる。
</p>

<pre>
int a[] = { 1 } ; // int [1] 
int b[] = { 1, 2, 3 } ; // int [3]
int c[] = { 1, 2, 3, 4, 5 } ; // int [5]
</pre>

<p>
staticデータメンバーと無名ビットフィールドは、アグリゲートのリスト初期化の際には、メンバーとして考慮されない。つまり、初期化リストの要素の順番などにも影響しない。
</p>

<pre>
struct S
{
    int x ;
    static int static_data_member ;// staticデータメンバー
    int y ;
    int : 8 ; // 無名ビットフィールド
    int z ;
} ;
static int S::static_data_member ;

S s = { 1, 2, 3 } ;
// s.x = 1, s.y = 2, s.z = 3
</pre>

<p>
この例では、static_data_memberと、yとzとの間にある無名ビットフィールドは、リスト初期化の際には、メンバーとして考慮されない。
</p>

<p>
もし、アグリゲートのメンバーよりも、初期化リストの要素の方が多い場合は、エラーとなる。
</p>

<pre>
int a[3] = { 1, 2, 3, 4 } ; // エラー

struct S
{
    int x, int y, int z ;
} ;

S s = { 1, 2, 3, 4 } ; // エラー
</pre>

<p>
もし、アグリゲートのメンバーよりも、初期化リストの要素の方が少ない場合、明示的に初期化されていないアグリゲートのメンバーは、すべて値初期化される。値初期化では、アグリゲートの条件を満たす型はすべて、ゼロ初期化される。したがって、単にゼロで初期化されると考えても差し支えない。
</p>

<pre>
int a[5] = { 1, 2, 3 } ;
// a[0] = 1, a[1] = 2, a[2] = 3
// a[4]とa[5]は、値初期化される

struct S { int x ; int y ; } ;

S s { 1 } ;
// s.x = 1
// s.yは値初期化される
</pre>

<p>
空の初期化リストでは、値初期化される。
</p>

<pre>
// メンバーはすべて値初期化される
int a[5] = { } ;
struct S
{
    int x ; int y ;
} ;

S s = { } ;
</pre>

<p>
既存のコードでは、アグリゲートのすべてのメンバーをゼロ初期化するために、{0}という初期化リストが使われていることがある。
</p>

<pre>
int x[100] = {0} ; // すべてゼロで初期化
</pre>

<p>
これは、C++ではなく、C言語に由来するコードである。C言語では、空の初期化リストを書く事ができない。そのため、Cプログラマは、{0}と書くのである。多くのC++プログラマは、C言語もよく知っているので、既存のコードでは、慣習的に{0}が使われている。しかし、C++では、{0}と書く必要はない。{}で十分である。
</p>

<p>
アグリゲートが、内部に別のアグリゲートを持っている場合、初期化リストは、その内部のアグリゲートを無視することはできない。
</p>

<pre>
struct SubAggregate { } ;

struct Aggregate
{
    int m1 ;
    SubAggregate s1 ;
    int m2 ;
    SubAggregate m2 ;    
    int m3 ;
    SubAggregate m3 ;    
} ;

SubAggregate s ;

Aggregate a =
{
    1,
    { },// 空の初期化リスト
    2,
    s,// オブジェクトの変数
    3,
    SubAggregate() // 関数形式のキャスト
} ;
</pre>

<p>
このように、内部のアグリゲートに続くメンバーを初期化したい場合は、たとえ空の初期化リストでも、必ず書かなければならない。もちろん、その内部のアグリゲートをコピー初期化できる型の値ならば、なんでも使える。
</p>

<p>
アグリゲート内のリファレンスのメンバーが、明示的に初期化されなかった場合、エラーとなる。
</p>

<pre>
struct S
{
    int &amp; ref ; // リファレンスのメンバー
} ;

int x ;
S s1 = { x } ; // OK、リファレンスを初期化している
S s2 = { } ; // エラー、リファレンスが初期化されていない
</pre>

<p>
多次元配列は、初期化リストのネストによって初期化することができる。
</p>

<pre>
int a[2][2] = { { 1, 2 }, { 1, 2 } } ;

int b[3][3][3] =
{
    { 1, 2, 3 },
    { 1, 2, 3 },
    { 1, 2, 3 }
} ;
</pre>
</article>

<article>
<h1 id="dcl.init.string"><a href="#dcl.init.string">文字配列（Character arrays）</a></h1>

<p>
char（signed charとunsigned charも含む）, wchar_t, char16_t, char32_tの配列は、それぞれ、対応する文字列リテラルで初期化できる。
</p>

<pre>
char str[6] = "hello" ;
char utf8_str[6] = u8"hello" ;
wchar_t wide_str[6] = L"hello" ;
char16_t utf16_str[6] = u"hello" ;
char32_t utf32_str[6] = U"hello" ;
</pre>

<p>
文字列リテラルは、null文字を含むということに注意しなければならない。文字列リテラル、"hello"の型は、char const [6]である。
</p>

<p>
文字配列の要素数が指定されていない場合、初期化子の文字列リテラルの要素数になる
</p>

<pre>
// 要素数は6
char str[] = "hello" ;
</pre>

<p>
配列の要素数より、文字列リテラルの要素数の方が多い場合、エラーとなる。
</p>

<pre>
char str[5] = "hello" ; // エラー
</pre>

<p>
配列の要素数より、文字列リテラルの要素数の方が少ない場合、明示的に初期化されない要素は、ゼロ初期化される。
</p>

<pre>
// 以下の二行は同等
char str[10] = "hello" ;
char str[10] = { 'h', 'e', 'l', 'l', 'o', '\0', 0, 0, 0, 0 } ;
</pre>
</article>

<article>
<h1 id="dcl.init.ref"><a href="#dcl.init.ref">リファレンス（References）</a></h1>

<p class="editorial-note">
TODO: FDIS後に見直し。core issue 1058.If the initializer expression is a string literal (2.14.5 [lex.string]), the program is ill-formed.
</p>

<p>
T &amp;を、「T型へのlvalueリファレンス」という。T &amp;&amp;を、「T型へのrvalueリファレンス」という。これらを二つまとめて、「T型へのリファレンス」という。lvalueリファレンスは、lvalueへのリファレンスであり、lvalueで初期化する。rvalueリファレンスは、rvalueへのリファレンスであり、rvalueで初期化する。そのため、このような名前になっている。
</p>

<p>
T型へのリファレンスは、T型のオブジェクトか関数、あるいは、T型に変換可能なオブジェクトで初期化できる。
</p>

<pre>
struct Integer
{
    int object ;
    operator int &amp; () { return object ; }
} ;

void f(void) { }

int main()
{
// オブジェクトによる初期化
    int int_object ;
    int &amp; ref_int = int_object ;

// 関数による初期化の例
    void ( &amp;ref_function )(void) = f ;

// int型に変換可能なオブジェクトによる初期化
    Integer integer_object ;
    int &amp; ref_integer = integer_object ;
}
</pre>

<p>
リファレンスは、必ず初期化されなければならない。リファレンスの参照先を変更することはできない。リファレンスは、参照先のオブジェクトと同じように振舞う。
</p>

<pre>
int main()
{
    int x ;
    int &amp; ref = x ;
    ref = 0 ; // x = 0 と同じ
    int y = 0 ;
    ref = y ; // x = y と同じ、参照先は変わらない
}
</pre>

<p>
関数の仮引数、関数の戻り値の型、クラス定義の中のクラスメンバー宣言、extern指定子が明示的に使われている宣言では、リファレンスの初期化子を省略できる。
</p>

<pre>
// 関数の仮引数
void f( int &amp; ) ;

// 関数の戻り値の型
int &amp; g() ;
auto g() -&gt; int &amp; ;

// クラス定義のクラスメンバーの宣言
struct S { int &amp; ; } ;

// extern指定子（refは別の場所で定義されている）
extern int &amp; ref ;
</pre>

<p>
もちろん、これらのリファレンスも、使うときには、初期化されていなければならない。
</p>

<p>
リファレンスの具体的な初期化について説明する前に、リファレンス互換（reference-compatible）を説明しなければならない。ある型、T1とT2があるとする。もし、T1が、T2と同じ型か、T2の基本クラス型であり、T1のCV修飾子が、T2のCV修飾子と同等か、それ以上の場合、T1はT2に対してリファレンス互換である。
</p>

<p>
一般に、T1がT2に対してリファレンス互換である場合、T1へのリファレンスは、T2へのリファレンスで初期化できる。
</p>

<pre>
// AとBとは、お互いにリファレンス互換ではない
struct A { } ;
struct B { } ;

A a ;
B &amp; r1 = a ; // エラー、リファレンス互換ではない

// BaseはDerivedに対して、リファレンス互換である
// DerivedはBaseに対して、リファレンス互換ではない
// 基本クラスは派生クラスに対してリファレンス互換であるが、
// 派生クラスは基本クラスに対してリファレンス互換ではない
struct Base { } ;
struct Derived : Base { } ;

Base base ;
Derived derived ;

Base &amp; r2 = derived ; // OK
Derived &amp; r3 = base ; // エラー

// Non_const_intはConst_intに対して、リファレンス互換ではない
// Const_intはNon_const_intに対して、リファレンス互換である
// CV修飾子が同じか、それ以上である場合、リファレンス互換である
// CV修飾子が少ない場合、リファレンス互換ではない
typedef int Non_const_int ;
typedef int const Const_int ;

Non_const_int nci ;
Const_int ci ;

Non_const_int &amp; r4 = ci ; // エラー
Const_int &amp; r5 = nci ; // OK
</pre>


<p>
T型へのlvalueリファレンスは、リファレンス互換なlvalueで初期化できる。
</p>

<pre>
struct Base { } ;
struct Derived : Base { } ;

int main()
{
    int object ;
    int &amp; r1 = object ;

    Base base ;
    Base &amp; r2 = base ;
// 派生クラスのlvalueでも初期化できる
    Derived derived ;
    Base &amp; r3 = derived ;

    int const const_object ;
    // OK
    int const &amp; r5 = const_object ;
    int const volatile &amp; r6 = const_object;
}
</pre>

<p>
基本的に、lvalueリファレンスはlvalueでしか初期化できない。xvalueやprvalueで初期化することはできない。また、CV修飾子を取り除くことはできない。以下はエラーの例である。
</p>

<pre>
#include &lt;utility&gt;

struct A { } ;
struct B { } ;

struct Base { } ;
struct Derived : Base { } ;

int main()
{
// エラー、BはAに対してリファレンス互換ではない
    A a ;
    B &amp; b = a ; 

    int &amp; r1 = 0 ; // エラー、prvalueでは初期化できない
    int x ;
    int &amp; r2 = std::move( x ) ; // エラー、xvalueでは初期化できない

    Base base ;
    Derived &amp; r3 = base ; // エラー、派生クラスは基本クラスに対してリファレンス互換ではない

    int const ci ;
    int &amp; r4 = ci ; // エラー、CV修飾子が少ないので、リファレンス互換ではない
} ;
</pre>

<p>
T型へのlvalueリファレンスは、リファレンス互換な型のlvalueに暗黙的に変換できるクラス型のオブジェクトで初期化できる。
</p>

<pre>
// int &amp;に暗黙的に変換できるクラス
struct Integer
{
    int object ;
    operator int &amp; () { return object ; }
} ;

int main()
{
    Integer object ;
    int &amp; ref = object ; // OK、暗黙的にリファレンス互換なlvalueに変換できる
} ;
</pre>

<p>
volatileではない、const T型へのlvalueリファレンスは、rvalueでも初期化できる。rvalueとは、prvalueとxvalueである。
</p>

<pre>
#include &lt;utility&gt;

int f() { return 0 ; }

int main()
{
    // OK、prvalueで初期化できる
    int const &amp; r1 = f() ;
    // OK、xvalueで初期化できる
    int object ;
    int const &amp; r2 = std::move( object ) ;

    // エラー、たとえconstでも、volatileであってはならない
    int volatile const &amp; r3 = f() ;
}
</pre>

<p>
volatileではない、const T型へのlvalueリファレンスが、rvalueでも初期化できるというのは、非常に異質なルールである。これは、C++にまだrvalueリファレンスがなかった時代に、リファレンスでrvalueをも参照する必要があったために導入されたルールである。
</p>

<p>
T型へのrvalueリファレンスは、リファレンス互換なrvalueで初期化できる。rvalueとは、xvalueとprvalueのことである。
</p>

<pre>
#include &lt;utility&gt;

int f() { return 0 ; }

int main()
{
    // OK、prvalueで初期化できる
    int &amp;&amp; prvalue_ref = f() ;

    // OK、xvalueで初期化できる
    int object ;
    int &amp;&amp; xvalue_ref = std::move( object ) ;
}
</pre>

<p>
rvalueリファレンスは、必ずrvalueで初期化しなければならない。lvalueでは初期化できない。
</p>

<pre>
int object ;
int &amp;&amp; ref = object ; // エラー、lvalueでは初期化できない
</pre>

<p>
rvalueリファレンス自体はlvalueであるということに、注意しなければならない。もし、rvalueリファレンスをrvalueリファレンスで初期化したいのならば、明示的にrvalueにしなければならない。
</p>

<pre>
#include &lt;utility&gt;

int f() { return 0 ; }

int main()
{
    int &amp;&amp; rvalue_ref = f() ;
    int &amp;&amp; r1 = rvalue_ref ; // エラー、rvalue_ref自体はlvalueである。
    int &amp;&amp; r2 = std::move( rvalue_ref ) ; // OK、xvalueでの初期化
}
</pre>

<p>
T型へのrvalueリファレンスは、リファレンス互換な型のrvalueに暗黙的に変換できるクラス型のオブジェクトで初期化できる。
</p>

<pre>
#include &lt;utility&gt;

// int &amp;&amp;に暗黙的に変換できるクラス
struct Integer
{
    int object ;
    operator int &amp;&amp; () { return std::move(object) ; }
} ;

int main()
{
    Integer object ;
    int &amp;&amp; ref = object ; // OK、暗黙的にリファレンス互換なrvalueに変換できる
}
</pre>

<p>
rvalueリファレンスの初期化子が、リテラルの場合、一時オブジェクトが生成され、参照される。
</p>

<pre>
int main()
{
    int &amp;&amp; ref = 0 ; // 一時オブジェクトが生成される
}
</pre>
</article>

<article>
<h1 id="dcl.init.list"><a href="#dcl.init.list">リスト初期化（List-initialization）</a></h1>

<p>
リスト初期化（List-initialization）とは、ひとつの{}で囲まれた初期化子を使ってオブジェクトやリファレンスを初期化することである。このような初期化子を、初期化リスト（Initializer list）という。初期化リストの中の、コンマで区切られた式のことを、初期化リストの要素という。
</p>

<p>
リスト初期化は、直接初期化でも、コピー初期化でも使える。
</p>

<pre>
T x( { } ) ; // 直接初期化
T x{ } ; // 直接初期化
T x = { } ; // コピー初期化
</pre>

<p>
直接初期化のリスト初期化を、直接リスト初期化（direct-list-initialization）といい、コピー初期化のリスト初期化を、コピーリスト初期化（copy-list-initialization）という。
</p>

<section>
<h1>初期化リストの使える場所</h1>
<p>
初期化リストは、以下の場所で使うことができる。
</p>

<p>
変数定義の初期化子
</p>

<pre>
T x( { } ) ;
T x{ } ;
T x = { } ;
</pre>

<p>
new式の初期化子
</p>

<pre>
new T{ } ;
</pre>

<p>
return文
</p>

<pre>
#include &lt;initializer_list&gt;

auto f() -&gt; std::initializer_list&lt;int&gt;
{
    return { 1, 2, 3 } ;
}
</pre>

<p>
関数の実引数
</p>

<pre>
#include &lt;initializer_list&gt;

void f( std::initializer_list&lt;int&gt; ) { }

int main()
{
    f( { 1, 2, 3 } ) ;
}
</pre>

<p>
<a href="#expr.sub">添字</a>
</p>

<pre>
#include &lt;initializer_list&gt;

struct S
{
    void operator [] ( std::initiazlier_list&lt;int&gt; ) { }
} ;

int main()
{
    S s ;
    s[ { 1, 2, 3 } ] ;
}
</pre>

<p>
コンストラクター呼び出しの実引数
</p>

<pre>
#include &lt;initializer_list&gt;

struct S
{
    S( std::initializer_list&lt;int&gt; ) { }
} ;

int main()
{
    S s1( { 1, 2, 3 } ) ;
    S s2{ 1, 2, 3 } ;
    S({ 1, 2, 3 }) ; // 関数形式のキャスト
    S{ 1, 2, 3 } ; // 関数形式のキャスト
}
</pre>

<p>
非staticデータメンバーの初期化子
</p>

<pre>
struct S
{
    int m1[3] = { 1, 2, 3 } ;
    int m2[3]( { 1, 2, 3 } ) ;
    int m3[3]{ 1, 2, 3 } ;
} ;
</pre>

<p>
メンバー初期化子
</p>

<pre>
struct S
{
    int data[3] ;
    // 以下二行は同じ意味
    S() : data{ 1, 2, 3 } { }
    S() : data( { 1, 2, 3 } ) { }
} ;
</pre>

<p>
代入演算子の右側
</p>

<pre>
#include &lt;initializer_list&gt;

struct S
{
    S &amp; operator = ( std::initializer_list&lt;int&gt; ) { }
} ;

int main()
{
    S s ;
    s = { 1, 2, 3 } ;
}
</pre>
</section>

<section>
<h1>初期化リストによる初期化の詳細</h1>
<p>
初期化リストによる初期化の詳細について説明する前に、縮小変換と、初期化リストコンストラクターを説明する。
</p>

<section>
<h1>縮小変換（narrowing conversion）</h1>
<p>
縮小変換（narrowing conversion）とは、暗黙の型変換のうち、変換先の型では、変換元の値を表現できない可能性のある変換のことをいう。具体的には、四種類の変換がある。
</p>

<p>
浮動小数点数型から整数型への変換。
</p>

<pre>
// 変換の一例
int x = double(0.0) ; // 縮小変換、doubleからint
</pre>

<p>
浮動小数点数型の間の変換のうち、long doubleからdoubleかflaotへの変換、doubleからfloatへの変換。
</p>

<pre>
// 縮小変換の例
long double ld = 0.0l ;
double d = ld ; // 縮小変換、long doubleからdouble
float f = ld ; // 縮小変換、long doubleからfloat
f = d ; // 縮小変換、doubleからfloat
</pre>


<p>
整数型、もしくはunscoped enum型か、浮動小数点数型への変換。
</p>

<pre>
// 縮小変換の例
int i = 0 ;
double d = i ; // 縮小変換、intからdouble
enum { e } ;
d = e ; // 縮小変換、unscoped enumからdouble
</pre>

<p>
ある整数型、もしくはunscoped enum型から、別の整数型かunscoped enum型への変換において、変換先の型が、変換元の型の値を、すべて表現できない場合。
</p>

<pre>
// short型はint型の値をすべて表現できないとする
int i = 0 ;
short s = i ; // 縮小変換
</pre>

<p>
ただし、最初の浮動小数点数型から整数型の変換を除く、三つの変換（浮動小数点間の変換、整数から浮動小数点数への変換、整数型間の変換）には、ひとつ例外がある。もし、変換元が定数式で、その値が変換先の型で表現可能な場合、縮小変換とはみなされない。
</p>

<pre>
const double cd = 0.0 ; // cdは定数式
float f = cd ; // 縮小変換ではない

const int ci = 0 ; // ciは定数式
double d = ci ; // 縮小変換ではない
short s = ci ; // 縮小変換ではない
</pre>

<p>
これは、ソースコード中に定数式を書いた場合の、煩わしいエラーを防ぐための、例外的なルールである。
</p>

<p>
この場合、浮動小数点数では、変換元の定数式の値が、変換元の型では、正確に表現できなくてもよい。これは、浮動小数点数の特性に基づくものである。
</p>

<p>
初期化リストでは、縮小変換は禁止されている。
</p>

<pre>
int main()
{
    int a =  0.0 ; // OK
    int b = { 0.0 } ; // エラー、縮小変換
    int c{ 0.0 } ; // エラー、縮小変換
    int d( { 0.0 } ) ; // エラー、縮小変換

    // OK、明示的な型変換
    int d{ static_cast&lt;int&gt;(0.0) }  ;
}
</pre>
</section>

<section>
<h1>初期化リストコンストラクター（initializer-list constructor）</h1>

<p>
ある型をTとして、ひとつのstd::initializer_list&lt;T&gt;を仮引数に取るコンストラクターか、あるいは、最初の仮引数がstd::initializer_list&lt;T&gt;であり、続く仮引数すべてに、デフォルト実引数が指定されている場合、そのコンストラクターを、初期化リストコンストラクター（initializer-list constructor）という。
</p>

<p>
初期化リストコンストラクターの仮引数の型は、ある型Tに対する、std::initializer_list&lt;T&gt;か、そのリファレンスでなければならない。
</p>

<pre>
#include&lt;initializer_list&gt;

struct S
{
    // 初期化リストコンストラクター
    S( std::initializer_list&lt;int&gt; list ) ;
    // リファレンスでもよい
    S( std::initializer_list&lt;int&gt; &amp; list ) ;
    // CV修飾子付きの型に対するリファレンスでもよい
    S( std::initializer_list&lt;int&gt; const &amp; list ) ;

    // これも初期化リストコンストラクター
    // デフォルト実引数のため
    S( std::initializer_list&lt;int&gt; list, int value = 0 ) ;
    
    // これらは初期化リストコンストラクターではない
    S( int value = 0, std::initializer_list&lt;int&gt;, short value ) ;
    S( std::initializer_list&lt;int&gt;, short value ) ;
} ;
</pre>

<p>
初期化リストコンストラクターは、リスト初期化の際に、他のコンストラクターより優先して考慮される。
</p>
</section>

</section>

<section>
<h1>リスト初期化の方法</h1>
<p>
リスト初期化は、以下のような優先順位で初期化される。先に書いてある条件に一致した場合、その初期化が選ばれ、その条件に対する初期化が行われる。後の条件は、先の条件に一致しなかった場合にのみ、考慮される。最後の条件にも当てはまらない場合は、エラーとなる。
</p>

<p>
T型のオブジェクト、あるいはT型へのリファレンスに対して――
</p>

<section>
<h1>初期化リストに要素がなく、Tはデフォルトコンストラクターを持つクラス型の場合</h1>

<p>
オブジェクトは値初期化される。
</p>

<pre>
// デフォルトコンストラクターを持つクラス
struct A { } ;

int main()
{
// すべて、値初期化される
    A a1 = { } ;
    A a2{ } ;
    A a3( { } ) ;
}
</pre>
</section>

<section>
<h1>Tがアグリゲートの場合</h1>

<p>
<a href="#dcl.init.aggr">アグリゲート</a>として初期化される。
</p>

<pre>
struct Aggregate
{
    int x ;
    double d ;
    char str[10] ;
} ;
// アグリゲートとして初期化
Aggregate a = { 123, 3.14, "hello" } ;
</pre>

<p>
縮小変換が必要な場合、エラーとなる。
</p>

<pre>
// エラー、縮小変換が必要。
int a[1] = { 1.0 } ;
</pre>

<h1>Tがstd::initializer_list&lt;E&gt;の場合</h1>

<p>
initializer_listのオブジェクトが構築される。この時、initializer_listの各要素は、初期化リストの各要素によって、初期化される。縮小変換が必要な場合は、エラーになる。
</p>

<pre>
// 空のinitializer_list
std::initializer_list&lt;int&gt; a = { } ;
// 要素数3のinitializer_list
std::initializer_list&lt;int&gt; b = { 1, 2, 3 } ;

// std::stringを要素に持つinitializer_list
std::initializer_list&lt; std::string &gt; c = { "hello", "C++", "world" } ;

// エラー、縮小変換が必要
std::initializer_list&lt;int&gt; d = { 0.0 } ;
</pre>
</section>

<section>
<h1>Tがクラス型の場合</h1>

<p>
適切なコンストラクターが選ばれる。縮小変換が必要な場合は、エラーとなる。まず、初期化リストコンストラクターが優先して選ばれる。
</p>

<pre>
struct S
{
    S( std::initializer_list&lt;int&gt; ) { }
    S( std::initializer_list&lt;double&gt; ) { }
} ;

int main()
{
    // S::S( std::initializer_list&lt;int&gt; )
    S s1 = { 1, 2, 3 } ;
    S s2{ 1, 2, 3 } ;
    S s3( { 1, 2, 3 } ) ;

    // S::S( std::initializer_list&lt;double&gt; )
    S s4 = { 1.0, 2.0, 3.0 } ;
    S s5{ 1.0, 2.0, 3.0 } ;
    S s6( { 1.0, 2.0, 3.0 } ) ;
}
</pre>

<p>
Tが初期化リストコンストラクターを持たない場合、初期化リストの要素が、実引数リストとみなされ、通常のコンストラクターが、オーバーロード解決によって選ばれる。縮小変換が必要な場合はエラーとなる。
</p>

<pre>
struct S
{
    S( int, int ) { }
    S( int, double ) { }
} ;

int main()
{
    // S::S( int, int )
    S s1 = { 1, 2 } ;
    // S::S( int, double )
    S s2 = { 1, 2.0 } ;

    // エラー、S::S( int, double )が選ばれるが、縮小変換が必要
    S s3 = { 1.0, 2.0 } ;
}
</pre>

<p>
リスト初期化の優先順位に注意すること。初期化リストが空の場合は、すでに挙げた一番最初のリスト初期化の条件が選ばれ、値初期化されるので、ここでの条件による初期化が行われることはない。初期化リストコンストラクターは、通常のコンストラクターより、常に優先される。
</p>

<pre>
struct S
{
    S( std::initializer_list&lt;int&gt; ) { }
    S( double ) { }
} ;

int main()
{
    // OK、値初期化される
    S s1 = { } ;
    // エラー、S( std::initializer_list&lt;int&gt; )が選ばれる
    // しかし、縮小変換が必要
    S s2 = { 0.0 } ; 
}
</pre>

<p>
この例では、s1はリスト初期化の最初の条件である、空の初期化リストを満たすので、値初期化される。s2では、初期化リストコンストラクターが優先される。S::S( double )が考慮されることはない。しかし、この場合、縮小変換が必要なので、エラーとなる。
</p>
</section>

<section>
<h1>Tがリファレンス型の場合</h1>

<p>
正確には、Tがクラス型へのリファレンスか、リファレンス型で、初期化リストが空の場合。
</p>

<pre>
// 条件に一致する例
class C { } ;

C &amp;&amp; r1 = { } ; // OK、Tがクラス型へのリファレンス
int &amp;&amp; r2 = { } ; // OK、リファレンス型で初期化子が空

// これは条件に一致しない。後の条件を参照
int &amp;&amp; r3 = { 0 } ;
</pre>

<p>
リファレンスされている型に対するprvalueの一時オブジェクトが生成され、初期化リストでリスト初期化される。リファレンスは、その一時オブジェクトを参照する。
</p>

<pre>
struct A
{
    int x ;
} ;

struct B
{
    B( std::initializer_list&lt;int&gt; ) { }
} ;

int main()
{
    A &amp;&amp; r1 = { } ;
    A &amp;&amp; r2 = { 1 } ;
    B &amp;&amp; r3 = { 1, 2, 3 } ;
    int &amp;&amp; ref = { } ;
}
</pre>

<p>
prvalueの一時オブジェクトが生成されることに注意しなければならない。prvalueを参照できるリファレンスは、rvalueリファレンスか、constかつ非volatileなlvalueリファレンスだけである。
</p>

<pre>
// 以下はOK
int &amp;&amp; r1 = { } ; // OK、rvalueリファレンス
int const &amp; r2 = { } ; // OK、constかつ非vloatileなlvalueリファレンス

// 以下はエラー
int &amp; r3 = { } ; // エラー、非constなlvalueリファレンス
int const volatile &amp; r4 = { } ; // エラー、constではあるが、volatileでもある
</pre>
</section>

<section>
<h1>初期化リストの要素がひとつの場合</h1>

<p>
オブジェクトは、初期化リストの要素で初期化される。縮小変換が必要な場合はエラーとなる。
</p>

<pre>
int a{ 0 } ;
int b( { 0 } ) ;
int c = { 0 } ;

// 通常のリファレンスの初期化と同じ
// リファレンスの初期化は、<a href="#dcl.init.ref">リファレンス</a>を参照。
int &amp;&amp; ref = { 0 } ;

// エラー、縮小変換が必要
int d{ 0.0 } ;
</pre>

<h1>初期化リストに要素がない場合</h1>

<p>
オブジェクトは値初期化される。この条件に当てはまるのは、ポインターがある。クラスは、すでに先の条件に一致しているので、この条件には当てはまらない。
</p>

<pre>
// pは値初期化される。つまり、nullポインターとなる。
int * p{ } ;
</pre>
</section>


<section>
<h1>std::initializer_listの実装</h1>
<p>
std::initializer_listがどのように実装されるかは、規格では具体的に規定されていない。ただし、いくつかの保証はある。
</p>


<p>
std::initializer_list&lt;E&gt;型のオブジェクトは、{}で囲まれた初期化リストによって生成される。このとき、Eの配列が生成され、初期化リストによって初期化される。たとえば、以下のようなコードがあるとき、
</p>

<pre>
std::intitializer_list&lt;int&gt; list = { 1, 2, 3 } ;
</pre>

<p>
以下のように、ユーザー側からは見えない配列が生成される。
</p>

<pre>
int __array[3] = { 1, 2, 3 } ;
// 実装依存のstd::initializer_list&lt;int&gt;の初期化の実装例
// 配列の先頭要素へのポインターと、最後からひとつ後ろのポインターを格納する
std::intitializer_list&lt;int&gt; list( array, array + 3 ) ;
</pre>

<p>
実際には、std::initializer_listには、このようなコンストラクターはない。あくまで参考のための、実装の一例である。
</p>

<p>
初期化リストにより生成される配列の寿命は、std::initializer_listのオブジェクトの寿命と同じである。
</p>

<p>
配列は、staticストレージか自動ストレージ上に構築される。動的ストレージの確保が起こることはない。というのも、動的にストレージを確保しなければならない技術的な理由はないからだ。
</p>
</section>


</section>

</article>

</article>

</article>


<article class="toplevel">
<h1 id="class"><a href="#class">クラス（Classes）</a></h1>

<p>
クラスとは、ユーザーが定義できる型である。クラスは、クラス指定子（class-specifier）によって定義する。クラス指定子は指定子なので、宣言文の中で使うことができる。したがって、クラスの定義とは、宣言文である。
</p>



<pre>
クラス指定子:
    class-key 識別子<sub>opt</sub> 基本クラス指定<sub>opt</sub> final<sub>opt</sub> { メンバー指定<sub>opt</sub> }

clas-key:
    class
    struct
    union
</pre>

<pre>
class A { } ;
struct B { } ;
union C { } ;

// クラスの定義は宣言文なので、変数やポインターなどを同時に宣言できる。
class C { } obj, *ptr ;
</pre>

<p>
クラスの定義は、宣言文である。したがって、終端には必ず、セミコロンを書かなければならない。
</p>

<pre>
struct A { } ; // 宣言文の終端にはセミコロンが必要
struct B { } // エラー、セミコロンがない
</pre>

<p>
クラス指定子は、識別子をクラス名として、宣言されたスコープに導入する。クラス指定子の識別子は省略することができる。その場合、無名クラスの定義となる。
</p>

<pre>
// 無名クラス
class { } a ;
</pre>

<p>
クラス指定子のキーワードには、class、struct、unionがある。このうち、classとstructは、デフォルトのアクセス指定の違い以外は、全く同じである。詳しくは、<a href="#class.access">メンバーのアクセス指定</a>を参照。unionキーワードによって定義されたクラスは、unionとなる。詳しくは、<a href="#class.union">union</a>を参照。
</p>

<p>
クラス名は、現れた場所の直後から、スコープに導入される。
</p>

<pre>
// クラス名は直後から使える
struct A { } * ptr = static_cast&lt;A *&gt;( nullptr ) ;
</pre>

<p>
また、クラス名は、そのクラスのスコープ内にも導入される。
</p>

<pre>
struct A
{
    // クラス名はクラスのスコープ内にも導入される
    typedef A type ;
} ;
</pre>

<p>
クラスは、'}' 記号が現れた場所以降、完全に定義されたものとみなされる。たとえ、メンバー関数が定義されていなくても、クラス自体は、その場所で定義されている。
</p>

<pre>
class A ; // クラスAは不完全型
class A { void f(void) ; } ; // クラスAは定義された
</pre>

<p>
この例では、A::f(void)は定義されていないが、クラスAは、}が現れた場所以降、すでに定義されている。
</p>


<p>
クラスの宣言で、クラス名の後、基本クラスの前にfinalを記述できる
</p>

<pre>
struct base_class { } ;
struct class_name final : base_class
{ } ;
</pre>

<p>
finalが指定されたクラスが基本クラス指定子に現れた場合、エラーとなる。つまり、finalが指定されたクラスから派生することはできない。
</p>

<pre>
class non_final_class { } ;
// OK、finalの指定されていないクラスは基本クラスに指定できる
class ok : non_final_class { } ;

class final_class final { } ;
// エラー、finalの指定されているクラスは基本クラスに指定できない
class error : final_class { } ;
</pre>


<p>
完全型のクラスとそのメンバーのオブジェクトは、ゼロではないサイズを持つ。つまり、sizeof演算子は、少なくとも、1以上を返す。
</p>

<pre>
struct Subobject { } ;
struct Object
{
    Subobject sub ;
} ;

int main()
{
    Object obj ;
    sizeof( obj ) ; // 値は実装依存だが、少なくとも1以上
    sizeof( obj.sub ) ; // 同上
}
</pre>

<p>
ただし、基本クラスのサブオブジェクトは、内部的にはサイズを持たないかもしれない。これは最適化のために許されている。
</p>

<pre>
struct Base { } ;
struct Derived : Base { } ;
</pre>

<p>
この場合、sizoef(Base)とsizeof(Derived)は、同じ値を返すかもしれない。
</p>

<article>
<h1 id="trivially_copyable_class"><a href="#trivially_copyable_class">トリビアルにコピー可能なクラス（trivially copyable class）</a></h1>

<p>
トリビアルにコピー可能なクラス（trivially copyable class）とは、クラスのオブジェクトを構成するバイト列の値を、そのままコピーできるクラスのことである。詳しくは、<a href="#basic.types">型</a>を参照。
</p>

<p>
あるクラスがtrivially copyable classとなるには、以下の条件をすべて満たさなければならない。
</p>

<p>
非trivialな、コピーコンストラクター、ムーブコンストラクター、コピー代入演算子、ムーブ代入演算子を持たないこと。trivialなデストラクターを持っていること。
</p>

<p>
つまり、これらの特別なメンバー関数を、ユーザー定義してはならない。また、virtual関数やvirtual基本クラスも持つことはできない。trivialの詳しい定義については、<a href="#class.copy">クラスオブジェクトのコピーとムーブ</a>を参照。
</p>

<p>
ここで、「持たない」ということは、delete定義によって削除しても構わないということである。
</p>

<pre>
struct A
{
    A( A const &amp; ) =delete ;
    A( A &amp;&amp; ) = delete ;
    A &amp; operator = ( A const &amp; ) = delete ;
    A &amp; operator = ( A &amp;&amp; ) = delete ;

    // trivialなデストラクターは、「持って」いなければならない

    int x ;
} ;
</pre>

<p>
また、アクセス指定子が異なるメンバーを持っていても構わない。
</p>

<p>
上記のクラスAは、コピーもムーブもできないクラスであるが、trivially copyable classである。
</p>
</article>

<article>
<h1 id="trivial_class"><a href="#trivial_class">トリビアルクラス（trivial class）</a></h1>
<p>
トリビアるクラス（trivial class）とは、trivially copyable classの条件に加えて、trivialなデストラクターを持っているクラスである。
</p>
</article>

<article>
<h1 id="standard_layout_class"><a href="#standard_layout_class">標準レイアウトクラス（standard-layout class）</a></h1>

<p>
標準レイアウトクラス（standard-layout class）の詳しい説明については、<a href="#class.mem">クラスのメンバー</a>を参照。
</p>

<p>
あるクラスが標準レイアウトクラスとなるためには、以下の条件をすべて満たさなければならない。
</p>

<p>
標準レイアウトクラスではない非staticメンバーをもたない。また、そのようなクラスへの配列やリファレンスも持たない。
</p>

<p>
virtual関数とvirtual基本クラスを持たない。
</p>

<p>
非staticデータメンバーは、すべて同じアクセス指定子である。
</p>

<pre>
// 標準レイアウトクラス
struct S
{
// すべて同じアクセス指定子
    int x ;
    int y ;
    int z ;

// staticデータメンバーは、別のアクセス指定子でもよい
private :
    int data ;
} ;
int S:data ;
</pre>

<p>
標準レイアウトクラスではないクラスを基本クラスに持たない。
</p>

<p>
基本クラスに非staticデータメンバーがある場合は、クラスは非staticデータメンバーを持たない。クラスが非staticデータメンバーを持つ場合は、基本クラスは非staticデータメンバーを持たない。つまり、クラスとその基本クラス（複数可）の集合の中で、どれかひとつのクラスだけが、非staticなデータメンバーを持つことが許される。
</p>

<pre>
struct Empty { } ;
struct Non_empty { int member ; } ;

// 以下は標準レイアウトクラス
struct A
// 基本クラスに非staticデータメンバーがある場合
    : Non_empty
{
// 非staticデータメンバーを持たない
} ;

struct B
// 基本クラスは非staticデータメンバーを持たない
    : Empty
{
// 非staticデータメンバーを持つ場合
    int data ;
} ;

// 以下は標準レイアウトクラスではない
// 基本クラスもクラスCも非staticデータメンバーを持っている
struct C
    : Non_empty
{
    int data ;
} ;
</pre>

<p>
最初の非staticデータメンバーと、基本クラスとで、同じ型を使わない。
</p>

<pre>
// 標準レイアウトクラスではない例
struct A { } ;
struct B
// 基本クラス
    : A
{
    A a ; // 最初の非staticデータメンバー
    int data ;
} ;

// 最初の非staticデータメンバーでなければよい
struct C : A
{
    int data ;
    A a ;
} ;
</pre>

<p>
この制限は、基本クラスとデータメンバーとの間で、アドレスが重複するのを防ぐためである。
</p>

<pre>
struct A { } ;
struct B : A { A a ; } ;

B obj ;

A * p1 = &amp;obj ; // 基本クラスのサブオブジェクトへのアドレス
A * p2 = &amp;obj.a ; // データメンバーへのアドレス

// p1 != p2が保証される
</pre>

<p>
このような場合、もし、クラスBが標準レイアウトクラスであれば、基本クラスのサブオブジェクトへのアドレスと、データメンバーのサブオブジェクトへのアドレスが重複してしまう。つまり、p1とp2が同じ値になってしまう。異なるアドレスを得られるためには、このようなクラスを標準レイアウトクラスにすることはできない。
</p>

<p>
標準レイアウトクラスのうち、structとclassのキーワードで定義されるクラスを、特に標準レイアウトstructと言う。unionキーワードで定義されるクラスを、特に標準レイアウトunionという。
</p>
</article>

<article>
<h1 id="POD_struct"><a href="#POD_struct">POD構造体（POD struct）</a></h1>

<p>
PODとは、Plain Old Dataの略である。これは、C言語の構造体に相当するクラスである。C++11では、クラスがPODの条件を満たした際に保証される動作を、trivially copyable classと、標準レイアウトクラスの二つの動作に細分化した。そのため、C++11では、特にPODにこだわる必要はない。
</p>

<p>
クラスがPODとなるためには、trivial classと標準レイアウトクラスの条件を満たし、さらに、PODではないクラスを非staticデータメンバーに持たないという条件が必要になる。
</p>
</article>

<article>
<h1 id="class.name"><a href="#class.name">クラス名（Class names）</a></h1>
<p>
TODO:あまり深く解説しなくてもいい気がする。
</p>
</article>

<article>
<h1 id="class.mem"><a href="#class.mem">クラスのメンバー（Class members）</a></h1>

<p>
クラスのメンバー指定には、宣言文、関数の定義、using宣言、static_assert宣言、テンプレート宣言、エイリアス宣言を書くことができる。
</p>

<pre>
struct Base { int value ; } ;

struct S : Base
{
    int data_member ; // 宣言文
    void member_function() { } // 関数の定義
    using Base::value ; // using宣言
    static_assert( true, "this must not be an error." ) ; // static_assert宣言
    template &lt; typename T &gt; struct Inner { } ; // テンプレート宣言
    using type = int ; // エイリアス宣言
} ;
</pre>

<p>
このうち、クラスのメンバーとなるのは、データメンバーとメンバー関数、ネストされた型名、列挙子である。
</p>

<pre>
struct S
{
    int x ; // データメンバー
    void f() { } ; // メンバー関数
    using type = int ; // ネストされた型名
    enum { id } ; // 列挙子
} ;
</pre>

<p>
データメンバーは、俗にメンバー変数とも呼ばれている。クラス定義内で、変数の宣言文を書くと、データメンバーとなる。
</p>

<p>
クラスのメンバーを、クラスの定義内で複数回宣言することはできない。ただし、クラス内のクラスとenumに関しては、前方宣言することができる。
</p>

<pre>
class Outer
{
    void f() ;
    void f() ; // エラー、複数回の宣言

    class Inner ; // クラス内クラスの宣言
    class Inner { } ; // OK、クラス内クラスの定義

    enum struct E : int ; // クラス内enumの宣言
    enum struct E : int { id } ; // OK、クラス内enumの定義
} ;
</pre>

<p>
クラスは、}で閉じた所をもって、完全に定義されたとみなされる。たとえ、メンバー関数が定義されていなくても、クラス自体は完全に定義された型となる。
</p>

<p class="editorial-note">
TODO: クラス定義内で完全型になる例外も書くべきか？
</p>

<p>
メンバーはコンストラクターで初期化できる。詳しくは<a href="#class.ctor">コンストラクター</a>を参照。メンバーは初期化子で初期化できる。詳しくは、<a href="#class.static.data">staticデータメンバー</a>と、<a href="#class.base.init">基本クラスとデータメンバーの初期化</a>を参照。
</p>

<pre>
struct S
{
    S() : x(0) { } // コンストラクター
    int x = 0 ; // 初期化子
    static int data ;
} ;

int S::data = 0 ; // 初期化子
</pre>

<p>
メンバーは、externやregister指定子と共に宣言することはできない。メンバーをthread_local指定子と共に宣言する場合は、static指定子も指定しなければならない。
</p>

<pre>
struct S
{
    extern int a ; // エラー
    register int b ; // エラー
    thread_local int c ; // エラー

    // OK、staticと共に宣言している
    static thread_local int d ;
} ;

thread_local int S::d ; // 定義
</pre>

<p>
基本的に、クラス名と同じ名前のメンバーを持つことはできない。これには、一部の例外が存在するが、本書では解説しない。
</p>

<pre>
struct name
{
    static int name ;       // エラー
    void name() ;           // エラー
    static void name() ;    // エラー
    using name = int ;      // エラー
    enum { name } ;         // エラー    
    union { int name } ;    // エラー
} ;
</pre>

<p>
unionではないクラスにおいて、同じアクセス指定下にある非staticデータメンバーは、クラスのオブジェクト上で、宣言された順番に確保される。つまり、先に宣言されたデータメンバーは、後に宣言されたデータメンバーよりも、上位のアドレスに配置される。ただし、実装は必要なパディングを差し挟むかもしれないので、後のデータメンバーが、先のデータメンバーの直後に配置されるという保証はない。
</p>

<pre>
struct S
{
public :
// 同じアクセス指定下にある非staticデータメンバー
    int x ;
    int y ;
} ;

int main()
{
    S s ;
    int * p1 = &amp;s.x ;
    int * p2 = &amp;s.y ;

    // この式は、必ずtrueとなる
    p1 &lt; p2 ;
    // この式がtrueとなる保証はない
    p1 + 1 == p2 ;
}
</pre>

<p>
アクセス指定子が異なる非staticデータメンバーの配置に関しては、未規定である。
</p>

<p>
標準レイアウトstructのオブジェクトへのポインターは、reinterpret_castによって変換された場合、クラスの最初のメンバーへのポインターに変換できる。また、その逆も可能である。
</p>

<pre>
struct S { int x ; } ;

int main()
{
    S s ;
    S * p1 = &amp;s ;
    int * p2 = &amp;s.x ;

    // 以下の2式は、trueとなることが保証されている
    p1 == reinterpret_cast&lt; S * &gt;( p2 ) ;
    p2 == reinterpret_cast&lt; int * &gt;( p1 ) ;
}
</pre>

<article>
<h1 id="layout_compatible"><a href="#layout_compatible">レイアウト互換（layout-compatible）</a></h1>
<p>
レイアウト互換（layout-compatible）という概念がある。まず、同じ型は、レイアウト互換である。
</p>

<p>
もし、二つの標準レイアウトstructが、同じ数の非staticデータメンバーを持ち、対応する非staticデータメンバーが、それぞれレイアウト互換であったならば、そのクラスは、お互いにレイアウト互換structである。
</p>

<p>
もし、二つの標準レイアウトunionが、同じ数の非staticデータメンバーを持ち、対応する非staticデータメンバーが、それぞれレイアウト互換であったならば、そのクラスは、お互いにレイアウト互換unionである。
</p>

<p>
二つの標準レイアウトstructは、レイアウト互換structのメンバーが続く限り、オブジェクト上で共通の表現をしていると保証される。
</p>

<pre>
// A、Bは、2番目のメンバーまで、お互いにレイアウト互換
struct A
{
    int x ;
    int y ;
    float z ;
} ;

struct B
{
    int x ;
    int y ;
    double z ;
} ;

int main()
{
    A a ;

    B * ptr = reinterpret_cast&lt; B * &gt;( &amp;a ) ;
    // OK、aのオブジェクトの、対応するレイアウト互換なメンバーが変更される
    ptr-&gt;x = 1 ;
    ptr-&gt;y = 2 ;
   
    // エラー、3番目のメンバーは、レイアウト互換ではない
    ptr-&gt;z = 0.0 ;
}
</pre>

<p>
ただし、メンバーがビットフィールドの場合、お互いに同じビット数でなければならない。
</p>

<pre>
// AとBはお互いにレイアウト互換
struct A
{
    int x:8 ;
} ;
struct B
{
    int x:8 ;
} ;
</pre>

<p>
標準レイアウトunionが、お互いにレイアウト互換な複数の標準レイアウトstructを持つとき、先頭から共通のメンバーについては、一方を変更して、他方で使うこともできる。
</p>

<pre>
struct A
{
    int x ;
    int y ;
    float z ;
} ;

struct B
{
    int x ;
    int y ;
    double z ;
} ;

union U
{
    A a ;
    B b ; 
} ;

int main()
{
    U u ;
    u.a.x = 1 ;
    u.a.y = 2 ;

    // 以下の2式はtrueとなることが保証されている
    u.b.x == 1 ;
    u.b.y == 2 ;

    // 3番目のメンバーは、レイアウト互換ではない
}
</pre>
</article>

</article>

<article>
<h1 id="class.mfct"><a href="#class.mfct">メンバー関数（Member functions）</a></h1>

<p>
クラスの定義内で宣言される関数を、クラスのメンバー関数（member function)という。メンバー関数はstatic指定子と共に宣言することができる。その場合、関数はstaticメンバー関数となる。staticメンバー関数ではないメンバー関数のことを、非staticメンバー関数という。ただし、friend指定子と共に宣言された関数は、メンバー関数ではない。
</p>

<pre>
struct S
{
    void non_static_member_function() ; // 非staticメンバー関数
    static void static_member_function() ; // staticメンバー関数

    friend void friend_function() ; // これはメンバー関数ではない
} ;

</pre>

<p>
メンバー関数は、クラス定義の内側でも外側でも定義することができる。クラス定義の内側で定義されたメンバー関数を、inlineメンバー関数という。これは、暗黙的にinline関数となる。クラス定義の外側でメンバー関数を定義する場合、クラスと同じ名前空間スコープ内で定義しなければならない。
</p>

<pre>
struct S
{
    // inlineメンバー関数
    void inline_member_function()
    { /*定義*/ }

    void member_function() ; // メンバー関数の宣言
} ;

// クラスSと同じ名前空間スコープ
void S::member_function()
{ /*定義*/ }
</pre>

<p>
クラス定義の外側でinlineメンバー関数の定義をすることもできる。それには、関数宣言か関数定義で、inline指定子を使えばよい。
</p>

<pre>
struct S
{
    inline void f() ; 
    void g() ;
} ;

void S::f(){ }
inline void S::g() { }
</pre>

<p>
クラス定義の外側でメンバー関数を定義するためには、メンバー関数の名前を、::演算子によって、クラス名で修飾しなければならない。
</p>

<pre>
struct S
{
    void member() ;
} ;

void S::member(){ }
</pre>

<p>
<a href="#class.local">ローカルクラス</a>では、メンバー関数をクラス定義の外側で宣言する方法はない。
</p>

<article>
<h1 id="class.mfct.non-static"><a href="#class.mfct.non-static">非staticメンバー関数（Nonstatic member functions）</a></h1>

<p>
非staticメンバー関数は、そのメンバー関数が属するクラスや、そのクラスから派生されたクラスのオブジェクトに対して、<a href="#expr.ref">クラスメンバーアクセス演算子</a>を使うことで、呼び出すことができる。同じクラスや、そのクラスから派生されたクラスのメンバー関数からは、他のメンバー関数を、通常の関数の呼び出しと同じように呼ぶことができる。
</p>

<pre>
struct Object
{
    void f(){ }
    void g()
    {
        // 関数呼び出し
        f() ;
    }
} ;

int main()
{
    Object object ;
    // クラスのメンバーアクセス演算子と、関数呼び出し
    object.f() ;
}
</pre>

<p>
非staticメンバー関数は、CV修飾子と共に宣言することができる。
</p>

<pre>
struct S
{
    void none() ;
    void c() const ; // constメンバー関数
    void v() volatile ; // volatileメンバー関数
    void cv() const volatile ; // const volatileメンバー関数
} ;
</pre>

<p>
このCV修飾子は、thisポインターの型を変える。また、メンバー関数の型も、CV修飾子に影響される。
</p>

<p>
非staticメンバー関数は、リファレンス修飾子と共に宣言することができる。リファレンス修飾子は、オーバーロード解決の際の、暗黙の仮引数の型に影響を与える。詳しくは、<a href="#over.match.funcs">候補関数と実引数リスト</a>を参照。
</p>

<p>
非staticメンバー関数は、virtualやピュアvirtualの文法で宣言することができる。詳しくは、<a href="#class.virtual">virtual関数</a>や、<a href="#class.abstract">抽象クラス</a>を参照。
</p>
</article>

<article>
<h1 id="class.this"><a href="#class.this">thisポインター（The this pointer）</a></h1>

<p>
非staticメンバー関数内では、thisというキーワードが、クラスのオブジェクトへのprvalueのポインターを表す。このクラスのオブジェクトは、メンバー関数を呼び出した際のクラスのオブジェクトである。
</p>

<pre>
struct Object
{
    void f()
    {
        this ;
    }
} ;


int main()
{
    Object a, b, c ;

    a.f() ; // thisは&amp;a
    b.f() ; // thisは&amp;b
    c.f() ; // thisは&amp;c
}
</pre>


<p>
class Xのメンバー関数におけるthisの型は、X *である。もし、constメンバー関数の場合、X const *となり、volatileメンバー関数の場合、X volatile *となり、const volatileメンバー関数の場合は、X const volatile *となる。
</p>

<pre>
class X
{
    // thisの型はX *
    void f() { this ; }
    // thisの型はX const *
    void f() const { this ; }
    // thisの型はX volatile *
    void f() volatile { this ; }
    // thisの型はX const volatile *
    void f() const volatile { this ; }
} ;
</pre>


<p>
constメンバー関数では、メンバー関数に渡されるクラスのオブジェクトがconstであるため、thisの型も、constなクラスへのポインター型となり、非staticデータメンバーを変更することができない。
</p>

<pre>
class X
{
    int value ;

    void f() const
    {
        this-&gt;value = 0 ; // エラー
    }
} ;
</pre>

<p>
これは、thisの型を考えてみると分かりやすい。
</p>

<pre>
class X
{
    int value ;


    void f() const
    {
        X const * ptr = this ;
        ptr-&gt;value = 0 ; // エラー
    }
} ;
</pre>

<p>
thisの型が、constなクラスに対するポインターなので、データメンバーを変更することはできない。
</p>

<p>
同様にして、volatileの場合も、非staticデータメンバーはvolatile指定されたものとみなされる。volatileの具体的な機能ついては、実装に依存する。
</p>

<p>
CV修飾されたメンバー関数は、同等か、より少なくCV修飾されたクラスのオブジェクトに対して呼び出すことができる。
</p>

<pre>
struct X
{
    X() { }
    void f() const { } ;
} ;

int main()
{
    X none ;
    none.f() ; // OK、より少なくCV修飾されている
    X const c ;
    c.f() ; // OK、同じCV修飾

    X const volatile cv ;
    cv.f() ; // エラー、CV修飾子を取り除くことはできない
}
</pre>

<p>
これは、非staticメンバー関数から、他の非staticメンバー関数を、クラスメンバーアクセスなしで呼び出す際にも当てはまる。その場合、クラスのオブジェクトとは、thisである。
</p>

<pre>
struct X
{
    void c() const // constメンバー関数
    {
        // thisの型はX const *
        nc() ; // エラー、CV修飾子を取り除くことはできない
    } ;

    void nc() // 非constメンバー関数
    {
        // thisの型はX *
        c() ; // OK、CV修飾子を付け加えることはできる
    }
} ;
</pre>

<p>
コンストラクターとデストラクターは、CV修飾子と共に宣言することができない。ただし、これらの特別なメンバー関数は、constなクラスのオブジェクトの生成、破棄の際にも、呼び出される。
</p>
</article>

</article>

<article>
<h1 id="class.static"><a href="#class.static">staticメンバー（Static members）</a></h1>

<p>
クラスのデータメンバーやメンバー関数は、クラス定義内で、static指定子と共に宣言することが出来る。そのように宣言されたメンバーを、クラスのstaticメンバーという。
</p>

<pre>
struct S
{
    static int data_member ;
    static void member_function() ; 
} ;
int S::data_member ;
</pre>

<p>
クラスXのstaticメンバーsは、::演算子を用いて、X::sのように参照することで、使うことができる。staticメンバーは、クラスのオブジェクトがなくても参照できるので、クラスのメンバーアクセス演算子を使う必要はない。しかし、クラスのメンバーアクセス演算子を使っても参照できる。
</p>

<pre>
struct X
{
    static int s ;
} ;

int X::s ;

int main()
{
    // ::演算子による参照
    X::s ;

    // クラスのメンバーアクセス演算子でも参照することはできる
    X object ;
    object.s ;
}
</pre>

<p>
クラスのメンバー関数内では、非修飾名を使った場合、クラスのstaticメンバー、enum名、ネストされた型が名前探索される。
</p>

<pre>
struct X
{
    void f()
    {
        s ; // X::s
        value ; // X::value
        type obj ; // X::type
    }

    static int s ;
    enum { value } ;
    typedef int type ;
} ;
int X::s ;
</pre>

<p>
staticメンバーにも、通常通りのアクセス指定が適用される。
</p>

<article>
<h1 id="class.static.mfct"><a href="#class.static.mfct">staticメンバー関数（Static member functions）</a></h1>

<p>
staticメンバー関数は、thisポインターを持たない。virtual指定子を使えない。CV修飾子を使えない。名前と仮引数の同じ、staticメンバー関数と非staticメンバー関数は、両立できない。
</p>

<pre>
struct S
{
    // エラー、同じ名前と仮引数のstatic関数と非static関数が存在する
    void same() ;
    static void same() ; 
} ;
</pre>

<p>
その他は、通常のメンバー関数と同じである。
</p>
</article>

<article>
<h1 id="class.static.data"><a href="#class.static.data">staticデータメンバー（Static data members）</a></h1>

<p>
staticデータメンバーは、クラスのサブオブジェクトには含まれない。staticデータメンバーは、クラスのスコープでアクセス可能なstatic変数だと考えてもよい。クラスのすべてのオブジェクトは、ひとつのstaticデータメンバーのオブジェクトを共有する。ただし、static thread_localなデータメンバーのオブジェクトは、スレッドにつきひとつ存在する。
</p>

<pre>
struct S
{
    static int member ;
} ;
int S::member ;

int main()
{
    S a, b, c, d, e ;
    // すべて同じオブジェクトを参照する
    a.member ; b.member ; c.member ; e.member ;
}
</pre>

<p>
クラス定義内のstaticデータメンバー宣言は、定義ではない。staticデータメンバーの定義は、クラスの定義を含む名前空間スコープの中に書かなければならない。その際、名前に::演算子を用いて、クラス名を指定する必要がある。staticデータメンバーの定義には、初期化子を使うことができる。初期化子は必須ではない。
</p>

<pre>
struct S
{
    static int member ;
} ;

// クラス名 :: メンバー名
void S::member = 0 ;
</pre>

<p>
staticデータメンバーが、constなリテラル型の場合、クラス定義内の宣言に、初期化子を書くことができる。この場合、初期化子は定数式でなければならない。staticデータメンバー自体も、定数式になる。初期化子を書かない場合は、通常通り、クラス定義の外、同じ名前空間スコープ内で、定義を書かなければならない。この場合は、定数式にはならない。
</p>

<pre>
struct S
{
    static const int constant_expression = 123 ; // 定数式
    static const int non_constant_expression ; // 宣言、定数式ではない
} ;
const int S::non_constant_expression = 123 ; // 定義
</pre>

<p>
リテラル型のstaticデータメンバーは、constexpr指定子をつけて宣言することもできる。この場合、初期化子を書かなければならない。初期化子は、定数式でなければならない。このように定義されたstaticデータメンバーは、定数式になる。
</p>

<pre>
struct S
{
    static constexpr int constant_expression = 123 ; // 定数式
} ;
</pre>

<p>
名前空間スコープのクラスのstaticデータメンバーは、外部リンケージを持つ。ローカルクラスのstaticデータメンバーは、リンケージを持たない。
</p>

<p>
staticデータメンバーは、非ローカル変数と同じように、初期化、破棄される。詳しくは、<a href="#basic.start.init">非ローカル変数の初期化</a>、<a href="#basic.start.term">終了</a>を参照。
</p>

<p>
staticデータメンバーには、mutable指定子は使えない。
</p>
</article>

</article>

<article>
<h1 id="class.union"><a href="#class.union">union（Unions）</a></h1>

<p class="editorial-note">
TODO: variant memberに書き換え。
</p>

<p>
unionというクラスは、クラスキーにunionキーワードを用いて宣言する。unionでは、非staticデータメンバーは、どれかひとつのみが有効である。これは、unionのオブジェクト内では、非staticデータメンバーのストレージは、共有されているからである。unionのサイズは、非staticデータメンバーのうち、最も大きな型を格納するのに十分なサイズとなる。
</p>

<pre>
union U
{
    int i ;
    short s ;
    double d ;
} ;

int main()
{
    U u ;
    u.i = 0 ; // U::iが有効
    u.s = 0 ; // U::sが有効、U::iは有効ではなくなる

}
</pre>

<p>
この例では、unionのサイズは、int, short, doubleのうちの、最もサイズが大きな型を格納するのに十分なだけのサイズである。データメンバーであるi, s, dは、同じストレージを共有している。
</p>

<p>
unionと、標準レイアウトクラスについては、<a href="#class">クラス</a>を参照。
</p>

<p>
unionは、通常のクラスに比べて、いくらか制限を受ける。unionはvirtual関数を持つことができない。unionは、基本クラスを持つことができない。unionは基本クラスになれない。unionは、リファレンス型の非staticデータメンバーを持つことができない。unionの非staticデータメンバーのうち、初期化子を持てるのは、ひとつだけである。
</p>

<pre>
// エラーの例

// エラー、virtual関数を持てない
union U1 { virtual void f() { } } ;
// エラー、基本クラスを持てない
struct Base { } ;
union U : Base { } ;
// エラー、基本クラスになれない
union Union_base { } ;
union Derived : Union_base { } ;
// エラー、リファレンス型の非staticデータメンバーを持てない
uion U2 { int &amp; ref ; } ;
// エラー、非staticデータメンバーで、初期化子を持てるのは、ひとつだけ

union U3
{
    int x = 0 ; 
    int y = 0 ; // エラー、複数の初期化子、どちらか一つならエラーではない
} ;
</pre>

<p>
その他は、通常のクラスと変わることがない。unionはメンバー関数を持てる。メンバー関数には、コンストラクターやデストラクター、演算子のオーバーロードも含まれる。アクセス指定も使える。staticデータメンバーならば、リファレンス型でも構わない。ネストされた型も使える。
</p>

<p>
unionの非staticデータメンバーが、非trivialなコンストラクター、コピーコンストラクター、ムーブコンストラクター、コピー代入演算子、ムーブ代入演算子、デストラクターを持っている場合、unionの対応するメンバーが、暗黙的にdeleteされる。そのため、これらのメンバーを使う場合には、union側で、ユーザー定義しなければならない。
</p>

<pre>
union U
{
    std::string str ;
    std::vector&lt;int&gt; vec ;
} ;

int main()
{
    U u ; // エラー、コンストラクターとデストラクターがdelete定義されている。
}
</pre>

<p>
この例では、strやvecは、非trivialなコンストラクターやデストラクターなどを持っているので、union側でも、それらを定義しなければならない。また、この例の場合、unionのコンストラクターやデストラクターは何もしないので、このunionを実際に使う場合には、placement newや、明示的なデストラクター呼び出しが必要になる。
</p>

<pre>
union U
{
    std::string str ;
    std::vector&lt;int&gt; vec ;

    U() { }
    ~U() { }
} ;

int main()
{
    U u ;

    new ( &amp;u.str ) std::string( "hello" ) ;
    u.str.~basic_string() ;

    new ( &amp;u.vec ) std::vector&lt;int&gt; { 1, 2, 3 } ;
    u.vec.~vector() ;
}
</pre>

<p>
もちろん、unionのコンストラクターやデストラクターで、どれかのデータメンバーの初期化、破棄をすることは可能である。しかし、どのデータメンバーが有効なのかということを、union内で把握するのは難しい。
</p>

<article>
<h1 id="anonymous_union"><a href="#anonymous_union">無名union（anonymous union）</a></h1>

<p>
以下のような形式のunionの宣言を、無名union（anonymous union）という。
</p>

<pre>
union { メンバー指定<sub>opt</sub> } ;
</pre>

<p>
無名unionは、無名の型のunionの、無名のオブジェクトを生成する。無名unionのメンバー指定は、非staticデータメンバーだけでなければならない。無名unionのメンバーの名前は、宣言されているスコープの他の名前と衝突してはならない。無名unionでは、staticデータメンバーやメンバー関数、ネストされた型などは使えない。また、privateやprotectedアクセス指定も使えない。
</p>

<pre>
int main()
{
    union { int i ; short s ; } ;
    // iかsのどちらかひとつだけが有効
    i = 0 ;
    s = 0 ;
}
</pre>

<p>
これは、以下のようなコードと同じであると考えることもできる。
</p>

<pre>
int main()
{
    union Anonymous { int i ; short s ; } unnamed ;
    unnamed.i = 0 ;
    unnamed.s = 0 ;
}
</pre>

<p>
名前空間スコープで宣言される無名unionには、必ずstatic指定子をつけなければならない。
</p>

<pre>
// グローバル名前空間スコープ
static union { int x ; int y ; } ;
</pre>

<p>
名前空間スコープで宣言される無名unionは、staticストレージの有効期間と、内部リンケージを持つ。
</p>

<p>
ブロックスコープで宣言される無名unionは、ブロックスコープ内で許されているすべてのストレージ上に構築できる。
</p>

<pre>
int main()
{
    // 自動ストレージ
    union { int a } ;
    // staticストレージ
    static union { int b } ;
    // thread_localストレージ
    thread_local union { int c } ;
}
</pre>

<p>
クラススコープで宣言される無名unionには、ストレージ指定子を付けることはできない。
</p>

<pre>
struct S
{
    union
    {
        int x ;
    } ;
} ;
</pre>

<p>
オブジェクトやポインターを宣言している、クラス名の省略されたunionは、無名unionではない。
</p>

<pre>
// クラス名の省略されたunion
// 無名unionではない
union { int x ; } obj, * ptr ;
</pre>
</article>

<article>
<h1 id="variant_member"><a href="#variant_member">共用メンバー（variant member）</a></h1>
<p>
union、もしくは無名unionを直接のメンバーに持つクラスを、unionのようなクラス（union-like class）という。unionのようなクラスには、共用メンバー（variant member）という概念が存在する。unionの共用メンバーは、unionの非staticデータメンバーである。無名unionを直接のメンバーに持つクラスの場合、無名unionの非staticデータメンバーである。
</p>

<pre>
// xとyは共用メンバー
union U { int x ; int y ; }

// xとyは共用メンバー
struct S
{
    union { int x ; int y ; } ;
} ;
</pre>


</article>

</article>

<article>
<h1 id="class.bit"><a href="#class.bit">ビットフィールド（Bit-fields）</a></h1>

<p>
ビットフィールドは、以下のようなメンバー宣言子の文法で宣言できる。
</p>

<pre>
識別子<sub>opt</sub> : 定数式
</pre>

<p>
定数式は、0よりも大きい整数でなければならない。
</p>

<pre>
struct S
{
    int // 型指定子
    x : 8 ; // ビットフィールドの宣言子
} ;
</pre>

<p>
ビットフィールドの定数式は、データメンバーのサイズをビット数で指定する。ビットフィールドに関しては、ほとんどの挙動が実装依存である。特に、ビットフィールドがクラスオブジェクトのストレージ上でどのように表現されるのかということや、アライメントなどは、すべて実装依存である。また、実装は、ビットフィールドのメンバー同士を詰めて表現することが許されている。
</p>

<pre>
struct S
{
    char x : 1 ;
    char y : 1 ;
} ;
</pre>

<p>
ここで、sizeof(S)は、2以上になるとは限らない。例えば、sizeof(S)が1を返す実装もあり得る。
</p>

<p>
ビットフィールドの定数式は、オブジェクトのビット数を上回ることができる。その場合、上回ったビット数は、パディングとして確保されるが、オブジェクトの内部表現として使われることはない。
</p>

<pre>
struct S
{
    int x : 1000 ;
} ;
</pre>

<p>
ここで、sizeof(S)は、少なくとも1000ビット以上になる値を返す（規格では、1バイトあたりのビット数は定められていない）。ただし、X::sは、本来のint型以上の範囲の値を保持することはできない。int型のオブジェクトのビット数を上回った分は、単にパディングとして確保されているに過ぎない。
</p>

<p>
ビットフィールドの宣言子で、識別子を省略した場合、無名ビットフィールドとなる。無名ビットフィールドはクラスのメンバーではなく、初期化もされない。ただし、実装依存の方法で、クラスのオブジェクト内に存在する。一般的な実装では、無名ビットフィールドは、オブジェクトのレイアウトを調整するためのパディングとして用いられる。
</p>

<pre>
struct S
{
    int x : 4 ;
    char : 3 ; // 無名ビットフィールド
    int y : 1 ;
} ;
</pre>

<p>
あるコンパイラーでは、このような無名ビットフィールドにより、S::xとS::yの間に、3ビット分のパディングを挿入することができる。ただし、すでに述べたように、ビットフィールドの内部表現とアライメントは実装依存なので、これはすべてのコンパイラーに当てはまるわけではない。使用しているコンパイラーが、ビットフィールドをどのように実装しているかは、コンパイラー独自のマニュアルを参照すべきである。
</p>

<p>
無名ビットフィールドでは、特別に、定数式に0を指定することができる。
</p>

<pre>
struct S
{
    int x : 4 ;
    char : 0 ; // 無名ビットフィールド
    int y : 4 ;
} ;
</pre>

<p>
これは、無名ビットフィールドの次のビットフィールドのアライメントを、アロケーション単位の境界に配置させるための指定である。上記の構造体は、ある環境では、S::xとS::yが同一のアロケーション単位に配置されるかもしれないが、無名ビットフィールドを使うことで、X::yを別のアロケーション単位に配置できる。
</p>

<p class="editorial-note">
TODO:構造体のオブジェクトの内部表現を視覚化した図
</p>


<p>
ビットフィールドはstaticメンバーにはできない。ビットフィールの型は、整数型かenum型でなければならない。符号が指定されていない整数型のビットフィールドの符号は実装依存である。
</p>

<pre>
struct S
{
    static int error : 8 ; // エラー、ビットフィールドはstaticメンバーにはできない
    int impl : 8 ; // 符号は実装依存
    signed s : 8 ; // 符号はsigned
    unsigned u : 8 ; // 符号はunsigned
} ;
</pre>

<p>
bool型のビットフィールドは、ビット数に関わらず、bool型の値を表現できる。
</p>

<pre>
struct S
{
    bool a : 1 ;
    bool b : 2 ;
    bool c : 3 ;
} ;

int main()
{
    S s ;
    s.a = true ;
    s.b = false ;
    s.c = true ;
}
</pre>

<p>
ビットフィールドのアドレスを得ることはできない。つまり、&amp;演算子をビットフィールドに適用することはできない。
</p>

<pre>
struct S
{
    int x : 8 ;
} ;

int main()
{
    S s ;
    &amp;s.x ; // エラー
}
</pre>

<p>
リファレンスは、ビットフィールドを参照することはできない。ただし、constなlvalueリファレンスの初期化子が、lvalueのビットフィールドの場合は、一時オブジェクトが生成され、そのオブジェクトを参照する
</p>

<pre>
struct S
{
    int x : 8 ;
} ;

int main()
{
    S s ;
    // エラー
    int &amp; ref = s.x ;
    // OK
    // ただし、crefが参照するのは、生成された一時オブジェクトである
    // s.xではない
    int const &amp; cref = s.x ;
}
</pre>
</article>

<article>
<h1 id="class.nest"><a href="#class.nest">クラス宣言のネスト（Nested class declarations）</a></h1>

<p>
クラスは、他のクラスの内側で宣言することができる。これを、ネストされたクラス（nested class）という。
</p>

<pre>
class Outer
{
    class Inner { } ; // ネストされたクラス
} ;

int main()
{
    Outer::Inner object ;
}
</pre>

<p>
ネストされたクラスのスコープは、外側のクラスのスコープに従う。これは、名前探索の際も、外側のクラスのスコープが影響するということである。
</p>

<pre>
int x ; // グローバル変数

struct Outer
{
    int x ; // Outer::x
    struct Inner
    {
        void f()
        {
            sizeof(x) ; // OK、sizeofのオペランドは未評価式。Outer::xのサイズを返す
            x = 0 ; // エラー、Outer::xはOuterの非staticメンバー

            ::x = 0 ; // OK、グローバル変数
        }
    } ;
} ;
</pre>

<p>
関数Inner::fの中で、xという名前を使うと、Outer::xが見つかる。これは、クラスInnerが、クラスOuterのスコープ内にあるためである。しかし、非staticデータメンバーであるOuter::xを使うためには、Outerのオブジェクトが必要なので、ここではエラーとなる。sizeofのオペランドは未評価式なので、問題はない。ただし、ここでのxは、Outer::xである。グローバル変数のxではない。
</p>

<p>
ネストされたクラスのメンバー関数やstaticデータメンバーは、通常のクラス通り、クラス定義の外側、同じ名前空間内で定義することができる。
</p>

<pre>
// グローバル名前空間
struct Outer
{

    struct Inner
    {
        static int x ;
        void f() ;
    } ;
} ;

// 同じ名前空間内
int Outer::Inner::x = 0 ;
void Outer::Inner::f() { }
</pre>

<p>
また通常通り、クラスの宣言だけをして、定義を後で書くこともできる。
</p>

<pre>
struct Outer
{
    class Inner ; // 宣言
} ;

class Outer::Inner { } ; // 定義
</pre>
</article>

<article>
<h1 id="class.local"><a href="#class.local">ローカルクラス宣言（Local class declarations）</a></h1>

<p>
関数定義の中で、クラスを定義することができる。これをローカルクラス（local class）という。
</p>

<pre>
int main()
{ // 関数定義
    class Local { } ; // ローカルクラス
    Local object ; // ローカルクラスのオブジェクト
}
</pre>

<p>
ローカルクラスのスコープは、クラス定義の外側のスコープである。また、名前探索は、ローカルクラスが定義されている関数と同じとなる。
</p>

<p>
ローカルクラスは、定義されている関数内の自動変数を使うことは出来ない。typedef名やstatic変数などは使える。
</p>

<pre>
int main()
{
    int x ; // ローカル変数

    typedef int type ;
    static int y ;

    class Local
    {
        void f()
        {
            x = 0 ; // エラー

            // typedef名やstatic変数などは使える
            type val ; // OK
            y = 0 ; // OK

            // OK、sizeofのオペランドは未評価式
            sizeof(x) ;
        }
    } ;
}
</pre>

<p>
ローカルクラスは、通常のクラスより制限が多い。ローカルクラスをテンプレート宣言することはできない。メンバーテンプレートを持つこともできない。ローカルクラスのメンバー関数は、クラス定義内で定義されなければならない。ローカルクラスの外側でメンバー関数を定義する方法はない。staticデータメンバーを持つことはできない。
</p>

<pre>
int main()
{
    // エラー、ローカルクラスはテンプレート宣言できない
    template &lt; typename T &gt; 
    class Local
    {
        // エラー、ローカルクラスはメンバーテンプレートを持てない。
        template &lt; typename U &gt; void f() { } 

        // OK、ただし、ローカルクラスの外側でメンバー関数を定義する方法はない
        void f() ;
        // エラー、ローカルクラスはstaticデータメンバーを持つことはできない。 
        static int x ;
    } ;
}
</pre>
</article>

<article>
<h1 id="class.nested.type"><a href="#class.nested.type">型名のネスト（Nested type names）</a></h1>

<p>
クラス内の型名を、ネストされた型名（nested type name）という。ネストされた型名を、クラスの外側で使うには、クラス名による修飾が必要である。
</p>

<pre>
struct X
{
    typedef int I ;
    class Inner { } ;
    I member ;
} ;

X::I object ;
</pre>
</article>

</article>

<article class="toplevel">
<h1 id="class.derived"><a href="#class.derived">派生クラス（Derived classes）</a></h1>

<p>
クラスには、基本クラス指定によって基本クラスを指定することができる。基本クラス指定は、以下のような文法である。
</p>

<p class="editorial-note">
TODO:文法を、Batavia会議後のドラフトに合わせて修正すること。
</p>

<pre>
クラス指定子:
    class-key 識別子<sub>opt</sub> 基本クラス指定<sub>opt</sub> { メンバー指定<sub>opt</sub> }

基本クラス指定:
    : 基本クラス指定子リスト

基本クラス指定子リスト:
    基本クラス指定子 ...<sub>opt</sub>
    基本クラス指定子リスト, 基本クラス指定子 ...<sub>opt</sub>

基本クラス指定子:

</pre>
<p>
基本クラス指定子に指定されたクラスのことを、基本クラス（base class）という。また、基本クラスを指定したクラスを、基本クラスに対する、派生クラス（derived class）という。クラスの基本クラス指定に指定されているクラスを、クラスの直接の基本クラス（direct base class）という。基本クラス指定には指定されていないものの、直接の基本クラスを通じて基本クラスとなっているクラスを、クラスの間接の基本クラス（indirect base class）という。単に基本クラスという場合、直接の基本クラスと関節の基本クラスの両方を意味する。
</p>

<p>
他のプログラミング言語の中には、基本クラスのことをスーパークラスと呼び、派生クラスのことをサブクラスと名付けている言語もある。C++では、そのような名称は用いない。これは、スーパーとサブでは意味が分かりにくいと、他ならぬBjarne Stroustrup自身が考えたためである。そのため、C++では、スーパーのかわりに基本（base）、サブのかわりに派生（derived）という言葉を用いることになった。
</p>

<p class="editorial-note">
TODO:文法を、Batavia会議後のドラフトに合わせて修正すること。
</p>

<p>
基本クラスは、基本指定子に記述する。これは、
</p>

<pre>
struct Base { } ;
struct Derived1 : Base { } ;
struct Derived2 : Derived1 { } ;
</pre>

<p>
ここでは、Derived1の基本クラスはBaseである。Derived2の基本クラスはDerived1とBaseである。Derived2の直接の基本クラスはDerived1、関節の基本クラスはBaseである。
</p>

<p>
派生（derived）と継承（inherited）という言葉には、規格上、明確な違いがある。
</p>

<p>
派生という言葉は、派生クラスと基本クラスの関係を記述するために用いられる。あるクラスが基本クラスを持つ場合、「あるクラスは、基本クラスから、派生される（A class is derived from its base class）」という。「DerivedクラスはBaseクラスから派生されている（The Derived class is derived from the Base class.）」といえば、以下のようなコードを意味する。
</p>

<pre>
struct Base { } ;
struct Derived : Base { } ;
</pre>

<p>
この場合、DerivedクラスはBaseクラスから派生されている、という。クラスの派生関係に、継承という言葉を使うのは誤りである。
</p>

<p>
ただし、継承されている基本クラス（inherited base class）という言い方をすることはある。これは、対象が基本クラスで、これに対して派生という言葉を用いると、派生クラスという意味になってしまうからだ。
</p>

<p>
継承という言葉は、クラスのメンバーに対して用いられる。「基本クラスのメンバーは、派生クラスに継承される（The Base class's member is inherited by the derived class.）」という。例えば、「Baseクラスのメンバー関数fは、Derivedクラスに、継承されている（The Base class's member function f is inherited by the Derived class）」といえば、以下のようなコードを意味する。
</p>

<pre>
struct Base { void f() ; } ;
// DerivedはBase::fを継承
struct Derived : Base { } ; 
</pre>

<p>
クラスのメンバーに対して、派生という言葉は使うのは誤りである。
</p>

<p>
基本クラス指定子に...が使われた場合、パック展開とみなされる。
</p>

<pre>
template &lt; typename ... Types &gt;
struct X : Types ... { } ;
</pre>

<p>
アクセス指定については、<a href="#class.access">メンバーのアクセス指定</a>を参照。
</p>

<article>
<h1 id="class.mi"><a href="#class.mi">複数の基本クラス（Multiple base classes）</a></h1>
<p>
基本クラスは、複数指定することができる。これを、複数の基本クラスという。複数の基本クラスを指定することを、俗に、多重継承（Multiple Inheritance）ということがあるが、これは、C++の規格上、正しい用語ではない。継承は、基本クラスのメンバーを派生クラスも受け継ぐことを意味する用語であって、クラスの派生関係を表すのに使う言葉ではないからだ。
</p>

<p>
ただし、歴史的に言えば、Multiple Inheritanceという言葉を最初に使ったのは、他ならぬBjarne Stroustrupご本人である。当時、Stroustrup氏が複数の基本クラスの設計をしていた時に使った言葉が、多重継承であった。ちなみに、多重継承が初めて使われたコードは、Jerry Schwarzによって書かれたiostreamである。
</p>

<p>
複数の基本クラスは、コンマで区切ることによって指定する。
</p>

<pre>
struct A { } ; struct B { } ; struct C { } ;
struct D
     : A, B, C
{ } ;
</pre>

<p>
この例では、Dは、A、B、Cという3個の基本クラスを持っている。
</p>

<p>
同じクラスを複数、直接の基本クラスとして指定することは出来ない。間接の基本クラスとしては指定できる。
</p>

<pre>
struct Base { } ;

struct Derived
     : Base, Base // エラー、直接の基本クラス
{ } ;

struct Derived1 : Base { } ;
struct Derived2 : Base { } ;
struct Derived3
     : Derived1, Derived2 // OK、間接の基本クラス
    { } ;
</pre>

<p>
この場合、Derived3は、Baseクラスのサブオブジェクトを、2個持つことになる。
</p>

<p>
基本クラスに、virtualが指定されていない場合、非virtual基本クラス（non-virtual base class）となる。非virtual基本クラスには、それぞれ独立したサブオブジェクトが割り当てられる。
</p>

<p class="editorial-note">
TODO: 派生階層を表現する図
</p>

<p>
同じクラスが複数、非virtual基本クラスとして存在することは、基本クラスのメンバーの名前に対するオブジェクトが容易に曖昧になる。このとき、派生クラスから基本クラスのメンバーを使うには、名前を正しく修飾しなければならない。
</p>

<pre>
struct Base { int member ; } ;
struct Derived1 : Base { } ;
struct Derived2 : Base { } ;

// Derived3には、2個のBaseサブオブジェクトが存在する
struct Derived3 : Derived1, Derived2
{
    void f()
    {
        member ; // エラー、曖昧
        Base::member ; // エラー、曖昧
        Derived1::member ; // OK
        Derived2::member ; // OK
    }
} ;

int main()
{
    Derived3 x ;
    x.member ; // エラー、曖昧
    x.Derived1::member ; // OK
    x.Derived2::member ; // OK
}
</pre>

<p>
ただし、staticメンバーの名前は、曖昧にならない。これは、staticメンバーの利用には、クラスのオブジェクトは必要ないからである。
</p>

<pre>
struct Base
{
    static void static_member() { }
    static int static_data_member ;
} ;
int Base::static_data_member = 0 ;

struct Derived1 : Base { } ;
struct Derived2 : Base { } ;

struct Derived3 : Derived1, Derived2
{
    void f()
    {
        static_member() ; // OK
        static_data_member ; // OK
    }
} ;
</pre>

<p>
直接、間接の両方の基本クラスに、同じクラスを持つことは可能である。ただし、そのような派生クラスは、基本クラスの非staticメンバーを使うことができない。なぜなら、基本クラスの名前自体の曖昧性を解決する方法がないからだ。
</p>

<pre>
struct Base
{
    int member() ; // 非staticメンバー
    static void static_member() { } // staticメンバー
} ;
struct Derived1 : Base { } ;

// Baseという名前自体が曖昧になる
struct Derived2 : Base, Derived1
{
    void f()
    {
        // Baseの非staticメンバーを使う方法はない

        static_member() ; // OK、staticメンバーは使える
    }
} ;
</pre>

<p>
このため、直接、間接の両方で同じクラスを基本クラスに持つ派生クラスの利用は、かなり制限される。
</p>

<p>
基本クラスに、virtualが指定されている場合、virtual基本クラス（virtual base class）という。virtual基本クラスには、ひとつしかオブジェクトが割り当てられない。virtual基本クラスのオブジェクトは、派生クラスで共有される。
</p>

<pre>
struct L { } ;
struct A : virtual L { } ;
struct B : virtual L { } ;
struct C : A, B { } ;
</pre>

<p class="editorial-note">
TODO: クラス階層を表す図
</p>

<p>
この例で、Cクラスには、Lのサブオブジェクトは1個存在する。これは、A、Bで共有される。
</p>

<p>
virtual基本クラスでは、サブオブジェクトが共有されているため、virtual基本クラスのメンバーは、曖昧にならない。
</p>

<pre>
struct Base { int member ; } ;
struct Derived1 : virtual Base { } ;
struct Derived2 : virtual Base { } ;
struct Derived3 : Derived1, Derived2
{
    void f()
    {
        member ; // OK
    }
} ;
</pre>

<p>
非virtual基本クラスとvirtual基本クラスは、両方持つことができる。
</p>

<pre>
struct B { } ;
struct X : virtual B { } ;
struct Y : virtual B { } ;
struct Z : B { } ;
struct A : X, Y, Z { } ;
</pre>

<p class="editorial-note">
TODO:クラス階層を表す図
</p>

<p>
この例では、Aクラスには、Bのサブオブジェクトは、2個存在する。X、Yで共有されるサブオブジェクトと、Zのサブオブジェクトである。
</p>
</article>

<article>
<h1 id="class.member.lookup"><a href="#class.member.lookup">メンバーの名前探索（Member name lookup）</a></h1>

<p>
メンバーの名前探索は、すこし難しい。派生クラスのメンバー名は、基本クラスのメンバー名を隠すということだ。あるメンバー名を名前探索する際に、派生クラスで名前が見つかった場合、その時点で名前探索は終了する。基本クラスのメンバーを探すことはない。
</p>

<pre>
struct Base
{
    void f( int ) { }
} ;

struct Derived : Base
{
    void f( double ) { }
} ;

int main()
{
    Derived object;
    object.f( 0 ) ; // Derived::f( double )が呼ばれる
}
</pre>

<p>
ここで、Derivedクラスには、二つのfという名前のメンバーが存在する。Derived::fとBase::fである。もし、名前探索によって両方の名前が発見された場合、オーバーロード解決によって、Base::f(int)が選ばれるはずである。しかし、実際には、Derived::f(double)が選ばれる。これは、Derivedクラスに、fという名前のメンバーが存在するので、その時点で名前探索が終了するからである。Baseのメンバー名は発見されない。名前が発見されない以上、オーバーロード解決によって選ばれることもない。
</p>

<p>
これは、名前探索に対するルールなので、型は関係がない。
</p>

<pre>
// fという名前のint型のデータメンバー
struct Base { int f ; } ;
// fという名前のvoid (void)型のメンバー関数
struct Derived : Base { void f( ) { } } ;

int main()
{
    Derived object;
    object.f = 0 ; // エラー、メンバー関数Derived::fに0を代入することはできない
    object.Base::f = 0 ; // OK、明示的な修飾
}
</pre>

<p>
したがって、基本クラスと同じ名前のメンバーを派生クラスで使う際には、注意が必要である。
</p>

<p>
名前探索という仕組みを考えずに、この挙動を考えた場合、これは、派生クラスのメンバー名が、基本クラスのメンバー名を、隠していると考えることもできる。もし、基本クラスのメンバー名を隠したくない場合、<a href="#namespace.udecl">using宣言</a>を使うことができる。using宣言を使うと、基本クラスのメンバー名を、派生クラスのスコープに導入することができる。
</p>

<pre>
struct Base
{
    void f( int ) { }
} ;

struct Derived : Base
{
    using Base::f ; // using宣言
    void f( double ) { }
} ;

int main()
{
    Derived object;
    object.f( 0 ) ; // Base::f( int )が呼ばれる
}
</pre>

<p>
名前探索で、派生クラスのメンバーが見つからない場合は、直接の基本クラスのメンバーから、名前が探される。
</p>

<pre>
struct Base { int member ; } ;
struct Derived : Base
{
    void f()
    {
        member ; // Base::member
    }
} ;
</pre>

<p>
メンバー名を探す基本クラスは、直接の基本クラスだけである。間接の基本クラスのメンバーは、直接の基本クラスを通じて、探される。
</p>

<pre>
struct A { int member ; } ;
struct B : A { } ;
struct C : B
{
    void f()
    {
        member ; // A::member
    } 
} ;
</pre>

<p>
この例では、C::fでmemberという名前のメンバーを使っている。Cクラスにはmemberという名前のメンバーが見つからないので、名前探索はBクラスに移る。クラスは、基本クラスのメンバー名を継承している。そのため、Bクラスの基本クラスのAクラスのメンバー名は、Bクラスのスコープからも発見することができる。
</p>

<p>
直接の基本クラスが複数ある場合、それぞれの直接の基本クラスから、名前が探される。この際、複数のクラスから同じ名前が発見され、名前の意味が違う場合、名前探索は無効となる。
</p>

<pre>
struct Base1 { void member( int ) { } } ;
struct Base2 { void member( double ) { } } ;
struct Derived : Base1, Base2 // 複数の直接の基本クラス
{
    void f()
    {
        member( 0 ) ; // エラー、名前探索が無効
        Base1::member( 0 ) ; // OK
    } 
} ;
</pre>

<p>
これは、memberという名前に対し、複数の直接の基本クラスで、複数の同じ名前が見つかり、しかも意味が違っているので、名前検索が無効となる。その結果、memberという名前が見つからず、エラーとなる。
</p>

<p>
もし、この例で、Derivedから、明示的な修飾をせずに、両方の基本クラスのメンバー関数を呼び出したい場合、<a href="#namespace.udecl">using宣言</a>が使える。
</p>

<pre>
struct Base1 { void member( int ) { } } ;
struct Base2 { void member( double ) { } } ;
struct Derived : Base1, Base2
{
    // 基本クラスのメンバー名をDerivedスコープで宣言する
    using Base1::member ;
    using Base2::member ;

    void f()
    {
        member( 0 ) ; // OK、オーバーロード解決により、Base1::member(int)が呼ばれる
    } 
} ;
</pre>

<p>
この例は、複数の直接の基本クラスがある場合の制限である。複数の間接の基本クラスでは、名前探索が失敗することはない。ただし、名前探索の結果として、複数の名前が発見され、曖昧になることはある。
</p>
</article>

<article>
<h1 id="class.virtual"><a href="#class.virtual">virtual関数（Virtual functions）</a></h1>

<p>
本書のサンプルコードは、解説する文法のための最小限のコードであり、virtual関数を持つクラスがvirtualデストラクターを持たないことがある。これは現実ではほとんどの場合、不適切である。
</p>

<p>
メンバー関数にvirtual指定子を指定すると、virtual関数となる。virtual関数を宣言しているクラス、あるいはvirtual関数を継承しているクラスは、ポリモーフィッククラス（polymorphic class）となる。
</p>

<pre>
struct Base
{
    virtual void f() { } // virtual関数
} ;
struct Derived : Base { } ;
</pre>

<p>
BaseとDerivedは、ポリモーフィッククラスである。
</p>

<p>
クラスがポリモーフィックであるかどうかということは、dynamic_castやtypeidを使う際に、重要である。
</p>

<p>
基本クラスのvirtual関数は、派生クラスのメンバーに、同じ名前、同じ仮引数リスト、同じCV修飾子、同じリファレンス修飾子という条件を満たすメンバー関数があった場合、オーバーライドされる。この時、派生クラスのメンバー関数は、virtual指定子がなくても、自動的にvirtual関数になる。
</p>

<pre>
struct A { virtual void f() {} } ;
struct B : A { } ; // オーバーライドしない
struct C : A
{
    void f() { } // オーバーライド
} ;
struct D : C
{
    void f(int) { } // オーバーライドしない
    void f() const { } // オーバーライドしない
} ;

// リファレンス修飾子が違う例
struct Base { virtual void f() &amp; { } } ;
struct Derived : Base { void f() &amp;&amp; { } } ;
</pre>

<p>
もちろん、virtualをつけてもよい。
</p>

<pre>
struct Base { virtual f() { } } ;
struct Derived : Bae { virtual f() { } }  ; // オーバーライド
</pre>

<p>
派生クラスで、最後にオーバーライドしたvirtual関数を、ファイナルオーバーライダー（final overrider）と呼ぶ。あるクラスのオブジェクトに対して、virtual関数を呼び出す際は、オブジェクトの実行時の型によって、最後にオーバーライドしたvirtual関数が呼び出される。これは、基本クラスのポインターやリファレンスを経由してオブジェクトを使った場合でも、同様である。通常のメンバー関数は、virtual関数とは違い、実行時の型チェックを行わない。オブジェクトを指しているリファレンスやポインターの型によって、決定される。
</p>

<pre>
// virtual関数と非virtual関数の違いの例
struct A
{
    virtual void virtual_function() { }
    void function() { }
} ;
struct B : A
{
    virtual void virtual_function() { }
    void function() { }
} ;
struct C : B
{
    virtual void virtual_function() { }
    void function() { }
} ;

void call( A &amp; ref )
{
    ref.virtual_function() ;
    ref.function() ;
}

int main()
{
    A a ; B b ; C c ;

    call( a ) ; // A::virtual_function, A::functionが呼び出される
    call( b ) ; // B::virtual_function, A::functionが呼び出される
    call( c ) ; // C::virtual_function, A::functionが呼び出される
}
</pre>

<p>
Aは、virtual_functionとfunctionという名前のvirtual関数を持っており、Aから派生しているB、Bから派生しているCは、オーバーライドしている。call関数の仮引数refは、オブジェクトの型が、実際に何であるかは、実行時にしか分からない。virtual関数であるvirtual_functionは、オブジェクトの型に合わせて正しく呼び出されるが、virtual関数ではないfunctionは、Aのメンバーが呼び出される。
</p>

<p>
virt指定子(final, override)は、virtual関数の宣言子の後、pure指定子の前に記述できる。
</p>

<pre>
// virt指定子の文法の例示のための記述
virtual f() final override = 0 ;
</pre>

<p>
finalが指定されたvirtual関数を持つクラスから派生したクラスが、同virtual関数をオーバーライドした場合はエラーになる。
</p>

<pre>
struct base
{
    virtual void f() { }
} ;

struct derived
{
    virtual void f() final { }
} ;

struct ok : derived
{
// OK
} ;

struct error : derived
{
    // エラー、final指定されているderived::fをオーバーライド
    virtual void f() { }
} ;
</pre>

<p>
virtual関数にfinalを指定すると、それ以上のオーバーライドを禁止できる。
</p>

<p>
overrideが指定されたvirtual関数が、基本クラスのメンバー関数をオーバーライドしていない場合、エラーとなる。
</p>

<pre>
struct base
{
    virtual void virtual_function() { }
} ;

struct ok : base
{
    // OK、ok::virtual_functionはbase::virtual_functionをオーバーライドしている
    virtual void virtual_function() override { }
} ;

struct typo : base
{
    // OK、typo::virtal_functionはbase::virtual_functionとは別のvirtual関数
    virtual void virtal_function() { }
} ;

struct error : base
{
    // エラー、error::virtal_functionはオーバーライドしていない
    virtual void virtal_function() override { }
} ;
</pre>

<p>
これにより、タイプミスによる些細な間違いをコンパイル時に検出できる。
</p>

<p>
オーバーライドであることに注意。以下のコードはエラーである。
</p>

<pre>
struct base
{
    void f() { } // 非virtual関数
} ;

struct error : base
{
    // エラー、オーバーライドしていない
    virtual void f() override { }
} ;
</pre>

<p>
finalとoverrideを両方指定することもできる。
</p>

<p>
virtual関数をオーバーライドする関数は、戻り値の型が同じでなくても構わない。ただし、何でもいいというわけではない。戻り値の型は、まったく同じ型か、相互変換可能（covariant）でなければならない。covariantは、以下のような条件をお互いに満たした型のことである。
</p>

<p>
今、関数D::fが、関数B::fをオーバーライドしているとする。
</p>

<pre>
// D::f、B::fの例
struct B { virtual 戻り値の型 f() ; } ;
struct D : B { virtual 戻り値の型 f() ; } ;
</pre>

<p>
その場合、戻り値の型は、以下の条件を満たさなければならない。
</p>

<h1>
お互いにクラスへのポインター、もしくは、お互いにクラスへのlvalueリファレンス、もしくは、お互いにクラスへのrvalueリファレンスであること。
</h1>

<p>
片方がポインターで片方がリファレンスの場合や、片方がlvalueリファレンスで片方がrvalueリファレンスの場合は、不適である。もちろん、ポインターでもリファレンスでもない型は不適である。また、クラスでもない型へのポインターやリファレンスも不適である。
</p>

<pre>
// ポインター
struct B { virtual B * f() ; } ;
struct D : B { virtual D * f() ; } ;
// lvalueリファレンス
struct B { virtual B &amp; f() ; } ;
struct D : B { virtual D &amp; f() ; } ;
// rvalueリファレンス
struct B { virtual B &amp;&amp; f() ; } ;
struct D : B { virtual D &amp;&amp; f() ; } ;
</pre>

<h1>
B::fの戻り値の型のクラスは、D::fの戻り値の型のクラスと同じか、曖昧がなくアクセスできる基本クラスでなければならない。
</h1>

<p>
オーバーライドしている関数が、基本クラスを戻り値に使っていたり、そもそもクラスの派生関係にない場合は、不適である。private派生していて、派生クラスからはアクセスできない場合や、基本クラスのサブオブジェクトが複数あって曖昧な場合はエラーとなる。
</p>

<pre>
struct Base { } ; // 基本クラス
struct Derived : Base { } ; // 派生クラス
struct Other { } ; // BaseやDerivedとは派生関係にないクラス

// クラスが同じ
struct B { virtual Base &amp; f() ; } ;
struct D : B { virtual Base &amp; f() ; } ;

// B::fのクラスはD::fのクラスの基本クラス
struct B { virtual Base &amp; f() ; } ;
struct D : B { virtual Derived &amp; f() ; } ;

// エラー
struct B { virtual Derived &amp; f() ; } ;
struct D : B { virtual Base &amp; f() ; } ;

// エラー
struct B { virtual Base &amp; f() ; } ;
struct D : B { virtual Other &amp; f() ; } ;
</pre>

<h1>
両方のポインターは同じCV修飾子を持たなければならない。D::fの戻り値の型のクラスは、B::fの戻り値の型のクラスと同じCV修飾子を持つか、あるいは少ないCV修飾子を持たなければならない。
</h1>

<p>
補足：ポインターに対するCV修飾子とは、T cv1 * cv2という型がある場合、cv2である。クラスに対するCV修飾子は、cv1である。
</p>

<pre>
// int *に対するCV修飾子
int * const 
// intに対するCV修飾子
const int *
int const *
</pre>

<pre>
// 両方のポインターは同じCV修飾子を持たなければならない例

// ポインターのCV修飾子はconst
struct B { virtual B * const f() ; } ;
// OK
struct D : B { virtual D * const f() ; } ;

// エラーのDクラスの例、ポインターのCV修飾子が一致していない
struct D : B { virtual D * f() ; } ;
struct D : B { virtual D * volatile const f() ; } ;
struct D : B { virtual D * const volatile f() ; } ;
</pre>

<pre>
// D::fの戻り値の型のクラスは、B::fの戻り値の型のクラスと同じCV修飾子を持つか、
// あるいは少ないCV修飾子を持たなければならない例

// B::fの戻り値の型のクラスのCV修飾子はconst
struct B { virtual B const &amp; f() ; } ;
// 問題ないDクラスの例、CV修飾子が同じか少ない
struct D : B { virtual D const &amp; f() ; } ;
struct D : B { virtual D &amp; f() ; } ;

// エラーのDクラスの例、CV修飾子が多い
struct D : B { virtual D volatile &amp; f() ; } ;
struct D : B { virtual D const volatile &amp; f() ; } ;
</pre>

<p>
明示的な修飾を用いた場合は、virtual関数呼び出しが阻害される。これは、オーバーライドしたvirtual関数から、オーバーライドされたvirtual関数を呼び出すのに使える。
</p>

<pre>
struct Base { virtual void f() { } } ;
struct Derived : Base
{
    virtual void f()
    {
        f() ; // Derived::fの呼び出し
        Base::f() ; // 明示的なBase::fの呼び出し
    }
} ;
</pre>

<p>
virtual関数とdelete定義は併用できる。ただし、delete定義のvirtual関数を、非delete定義のvirtual関数でオーバーライドすることはできない。非delete定義のvirtual関数を、delete定義のvirtual関数でオーバーライドすることはできない。
</p>

<pre>
// OK、delete定義のvirtual関数を、delete定義のvirtual関数でオーバーライドしている
struct Base { virtual void f() = delete ; } ;
struct Derived : Base { virtual void f() = delete ; } ;

// エラー、非delete定義ではないvirtual関数を、delete定義のvirtual関数でオーバーライドしている
struct Base { virtual void f() { } } ;
struct Derived : Base { virtual void f() = delete ; } ;

// エラー、delete定義のvirtual関数を、非delete定義のvirtual関数でオーバーライドしている
struct Base { virtual void f() = delete ; } ;
struct Derived : Base { virtual void f() { } } ;
</pre>
</article>

<article>
<h1 id="class.abstract"><a href="#class.abstract">アブストラクトクラス（Abstract classes）</a></h1>

<pre>
ピュア指定子:
    = 0 
</pre>

<p>
アブストラクトクラス（abstract class）は、抽象的な概念としてのクラスを実現する機能である。これは、例えば図形を表すクラスである、CircleやSquareなどといったクラスの基本クラスであるShapeや、動物を表すDogやCatなどといったクラスの基本クラスであるAnimalなど、異なるクラスに対する共通のインターフェースを提供する目的に使える。
</p>

<pre>
struct Shape
{
    // 図形描画用の関数
    // Shapeクラスは抽象的な概念であり、具体的な描画方法を持たない
    // 単に共通のインターフェースとして提供される
    virtual void draw() = 0 ;
} ;

struct Circle : Shape
{
    virtual void draw() { /* 円を描画 */ }
} ;

struct Square : Shape
{
    virtual void draw() { /* 正方形を描画 */ }
} ;

void f( Shape * ptr )
{
    ptr->draw() ; // 実行時の型に応じて図形を描画する
}
</pre>

<p>
ここでは、Shapeクラスというのは、具体的に描画する方法を持たない。そもそも、Shapeクラス自体のオブジェクトを使うことは想定されていない。このように、そのクラス自体は抽象的な概念であり、実体を持たない場合、ピュアvirtual関数を使うことで、共通のインターフェースとすることができる。
</p>

<p>
他の言語では、この機能を明確にクラスから分離して、「インターフェース」という名前の機能にしているものもある。C++では、抽象クラスも、制限はあるものの、クラスの一種である。
</p>

<p>
少なくともひとつのピュアvirtual関数を持つクラスは、アブストラクトクラスとなる。ピュアvirtual関数は、virtual関数の宣言に、ピュア指定子を書くことで宣言できる。
</p>

<pre>
ピュア指定子:
    = 0 
</pre>

<pre>
struct abstruct_class
{
    virtual void f() = 0 ;
} ;
</pre>

<p>
ピュアvirtual関数には、定義を与えることはできない。
</p>

<pre>
struct X
{
    // エラー
    virtual void f() = 0 { } ; 
}
</pre>

<p>
この、=0という文法は、初期化子や代入式とは、何の関係もない。ただ、C++の文法上、メンバー関数の宣言の中の、=0というトークン列を、特別な意味を持つものとして扱っているだけである。ピュア指定子を記述する位置は、virt-specifierの後である。
</p>

<pre>
struct Base { int f ; }
struct abstruct_class : Base
{
    virtual void f() new = 0 ;// virt-specifierの後
} ;
</pre>

<p class="editorial-note">
TODO: virt-specifierに対する適切な訳語。これは将来のドラフトで変更されるかもしれない。
</p>

<p>
アブストラクトクラスは、他のクラスの基本クラスとして使うことしかできない。アブストラクトクラスのオブジェクトは、派生クラスのサブオブジェクトとしてのみ、存在することができる。
</p>

<pre>
struct abstruct_class
{
    virtual void f() = 0 ;
} ;

struct Derived : abstruct_class
{
    void f() { }
} ;
</pre>

<p>
アブストラクトクラスのオブジェクトを、直接作ることはできない。これには、変数や関数の仮引数、new式などが該当する。
</p>

<pre>
struct abstruct_class
{
    virtual void f() = 0 ;
} ;

// エラー、abstruct_classのオブジェクトは作れない
void f( abstruct_class param )
{
    abstruct_class obj ; // エラー
    new abstruct_class ; // エラー
}
</pre>

<p>
アブストラクトクラスへのポインターやリファレンスは使える。
</p>


<pre>
struct abstruct_class
{
    virtual void f() = 0 ;
} ;

// OK、ポインターとリファレンスはよい
void f( abstruct_class *, abstruct_class &amp; ) ;
</pre>


<p>
ピュアvirtual関数を継承していて、ファイナルオーバーライダーがピュアvirtual関数である場合も、アブストラクトクラスとなる。これは例えば、アブストラクトクラスから派生されているクラスが、ピュアvirtual関数をオーバーロードしていなかった場合などが、該当する。
</p>

<pre>
struct Base { virtual void f() = 0 ; } ;
struct Derived : Base { } ;
</pre>

<p>
この場合、Derivedも、Baseと同じく、アブストラクトクラスになる。
</p>

<p>
派生クラスによって、ピュアvirtual関数ではないvirtual関数をオーバーライドして、ピュアvirtual関数にすることができる。その場合、派生クラスはアブストラクトクラスとなる。
</p>

<pre>
struct Base { virtual void f() { } } ;
struct Derived : Base { virtual void f() = 0 ; } ;

int main()
{
    Base b ; // OK
    Derived d ; // エラー
}
</pre>

<p>
この例では、Baseはアブストラクトクラスではない。Derivedはアブストラクトクラスである。
</p>

<p>
構築中、または破棄中のアブストラクトクラスのコンストラクターやデストラクターの中で、ピュアvirtual関数を呼び出した場合の挙動は、未定義である。
</p>

<pre>
struct Base
{
    virtual void f() = 0 ;

    // この関数を、Baseのコンストラクターやデストラクターから呼ぶとエラー
    void g()
    { f() ; }

    // コンストラクター
    Base() // エラー、未定義の挙動
    { f() ; }

    // デストラクター
    ~Base() // エラー、未定義の挙動
    { f() ; }
} ;

struct Derived : Base
{
    virtual void f() { }

    // Derivedはアブストラクトクラスではないので、問題はない
    Derived() { f() ; }
    ~Derived() { f() ; }
} ;
</pre>
</article>

</article>

<article class="toplevel">
<h1 id="class.access"><a href="#class.access">メンバーのアクセス指定（Member access control）</a></h1>

<p class="editorial-note">
TODO: オブジェクトは関係ないという注釈を入れること。
</p>

<p>
クラスのメンバーは、private、protected、publicのいずれかのアクセス指定を持つ。
</p>

<p>
privateが指定されたメンバーは、同じクラスのメンバーとfriendから使うことができる。
</p>

<p>
protectedが指定されたメンバーは、同じクラスと、そのクラスから派生されているクラスのメンバーとfriendから使うことができる。
</p>

<p>
publicでは、メンバーはどこからでも制限なく使える。
</p>

<pre>
class Base
{
private :
    int private_member ;
protected :
    int protected_member ;
public :
    int public_member ;

    void f()
    {
        // 同じクラスのメンバー
        private_member ; // OK
        protected_member ; // OK
        public_member ; // OK
    }
} ;

void f()
{ // クラス外
    Base base ;
    base.private_member ; // エラー
    base.protected_member ; // エラー
    base.public_member ; // OK
}

class Derived : public Base
{
    void f()
    {
        // 派生クラスのメンバー
        private_member ; // エラー
        protected_member ; // OK
        public_member ; // OK
    }
} ;
</pre>

<p>
classキーワードで定義されたクラスのメンバーは、デフォルトでprivateになる。structキーワードで定義されたクラスのメンバーは、デフォルトでpublicになる。
</p>

<pre>
// nameはprivate
class C { int name ; } ;
// nameはpublic
struct S { int name ; } ;
</pre>

<p>
classとstructキーワードの違いは、デフォルトのアクセス指定子が異なるだけである。アクセス指定子を明示的に記述すると、classとstructキーワードの違いはなくなる。
</p>

<p>
アクセス指定は、メンバーの種類を問わず、名前に対して一律に適用される。アクセス指定は、名前探索に影響をあたえることはない。たとえアクセス指定によって使えない名前であっても、名前は発見される。名前が発見されること自体はエラーではない。アクセス指定によって使えない名前を使おうとするとエラーになる。例えば、名前が関数のオーバーロードのセットであった場合、オーバーロード解決された結果の名前に対し、アクセス指定が適用される。
</p>

<pre>
class X
{
private :
    void f( int ) { }
public :
    void f( double ) { }
} ;

int main()
{
    X x ;
    // エラー、privateメンバーにはアクセス出来ない
    // オーバーロード解決の結果はX::f( int )
    x.f( 0 ) ;
    // OK、X::f( double )が呼ばれる
    x.f( 0.0 ) ;
}
</pre>

<p>
この例では、Xのメンバーfに対して、f(0)という関数呼び出しの式を適用している。アクセス指定は名前探索に影響をあたえることはないので、関数オーバーロードのセットとして、X::f(int)と、X::f(double)という名前が発見される。そして、オーバーロード解決によって、X::f(int)が最適な関数として選ばれる。アクセス指定のチェックは、オーバーロード解決の後に行われる。この場合、X::f(int)はprivateメンバーなので、Xのメンバーでもfriend関数でもないmain関数から呼び出すことはできない。
</p>

<article>
<h1 id="class.access.spec"><a href="#class.access.spec">アクセス指定子（Access specifiers）</a></h1>

<p>
クラスのメンバーのアクセス指定は、ラベルにアクセス指定子（Access specifiers）を記述することで指定する。
</p>

<pre>
アクセス指定子 : メンバー指定<sub>opt</sub>

アクセス指定 :
    private
    protected
    public
</pre>

<p>
アクセス指定子とは、private、protected、publicのいずれかである。アクセス指定子が現れた場所から、次のアクセス指定子か、クラス定義の終了までの間のメンバーが、アクセス指定子の影響を受ける
</p>

<p>
class X
{
    int a ; // デフォルトのprivate
public :
    int b ; // public
    int c ; // public
protected :
    int d ; // protected
private :
    int e ; // private
} ;
</p>

<p>
アクセス指定子には、順番や使用可能な回数の制限はない。好きな順番で、何度でも指定できる。
</p>

<pre>
class X
{
public :
public :
protected :
public :
public :
private :
} ;
</pre>
</article>

<article>
<h1 id="class.access.base"><a href="#class.access.base">基本クラスと、基本クラスのメンバーへのアクセス指定（Accessibility of base classes and base class members）</a></h1>

<p>
あるクラスを、別のクラスの基本クラスとするとき、いずれかのアクセス指定子を指定する。
</p>

<pre>
class Base { } ;

class Derived_by_public : public Base { } ; // public派生
class erived_by_protected : protected Base { } ; // protected派生
class Derived_by_private : private Base { } ; // private派生

</pre>

<p>
アクセス指定子がpublicの場合、基本クラスのpublicメンバーは、派生クラスのpublicメンバーとしてアクセス可能になり、基本クラスのprotectedメンバーは、派生クラスのprotectedメンバーとしてアクセス可能になる。
</p>

<pre>
class Base
{
public :
    int public_member ;
protected :
    int protected_member ;
} ;

class Derived : public Base
{
    void f()
    {
        public_member ; // OK
        protected_member ; // OK
    }
} ;

int main()
{
    Derived d ;
    d.public_member ; // OK
}
</pre>

<p>
アクセス指定子がprotectedの場合、基本クラスのpublicとprotectedメンバーは、派生クラスのprotectedメンバーとしてアクセス可能になる。
</p>

<pre>
class Base
{
public :
    int public_member ;
protected :
    int protected_member ;
} ;

class Derived : protected Base
{
    void f()
    {
        public_member ; // OK、ただしprotectedメンバー
        protected_member ; // OK
    }
} ;

int main()
{
    Derived d ;
    d.public_member ; // エラー、Derivedからは、protectedメンバーである
}
</pre>

<p>
アクセス指定子がprivateの場合、基本クラスのpublicとprotectedメンバーは、派生クラスのprivateメンバーとしてアクセス可能になる。
</p>

<pre>
class Base
{
public :
    int public_member ;
protected :
    int protected_member ;
} ;

class Derived : private Base
{
    void f()
    {
        public_member ; // OK、ただし、privateメンバー
        protected_member ; // OK、ただし、privateメンバー
    }
} ;

class Derived2 : public Derived
{
    void f()
    {
        public_member ; // エラー、基本クラスのprivateメンバーにはアクセスできない
        protected_member ; // エラー、基本クラスのprivateメンバーにはアクセスできない
    }
} ;

int main()
{
    Derived d ;
    d.public_member ; // エラー、Derivedからは、privateメンバーである
}
</pre>

<p>
基本クラスにアクセス指定子を指定しなかった場合、structキーワードで宣言されたクラスは、デフォルトでpublicに、classキーワードで宣言されたクラスは、デフォルトでprivateになる。
</p>

<pre>
struct Base { } ;

// デフォルトのpublic派生
struct D1 : Base { } ; 
// デフォルトのprivate派生
class D2 : Base { } ;
</pre>

<p>
どのアクセス指定子を指定して派生しても、基本クラスのprivateメンバーを派生クラスから使うことはできない。クラスAからprivate派生したクラスBから派生しているクラスCでは、クラスAのメンバーは使えないのも、この理由による。
</p>

<pre>
// classキーワードで宣言されたクラスのメンバーはデフォルトでprivate
class Base { int private_member ; } ;

class Derived : public Base
{
// どのアクセス指定を用いても、基本クラスのprivate_memberは使えない
} ;

struct A { int public_member ; } ;
class B : private A { } ;
class C : public B
{
// クラスBは、クラスAからprivate派生しているため、ここではA::public_memberは使えない。
} ;
</pre>

<p>
クラス名自体も、クラススコープ内の名前として扱われる。クラスAからprivate派生したクラスBから派生しているクラスCでは、クラスAのクラス名自体がprivateメンバーになってしまう。
</p>

<pre>
// グローバル名前空間のスコープ
struct A { } ;
class B : private A { } ;
class C : public B
{
    void f()
    {
        A a1 ; // エラー、名前Aは、基本クラスのprivateメンバーのA
        ::A a2 ; // OK、名前::Aは、グローバル名前空間スコープ内のA
    }
} ;
</pre>

<p>
この例では、クラスCのスコープ内で、非修飾名Aに対して、クラス名Aが発見されてしまうので、エラーになる。クラスCの中でクラスAを使いたい場合、明示的な修飾が必要である。
</p>

<p>
アクセス指定子は、staticメンバーにも適用される。publicなstaticメンバーを持つクラスを、protectedやprivateで派生すると、基本クラスからはアクセスできるが、派生クラスを介してアクセスできなくなってしまうこともある。
</p>

<pre>
// グローバル名前空間のスコープ
struct A { static int data ; } ;
int A::data ; 

class B : private A { } ;
class C : public B
{
    void f()
    {
        data ; // エラー
        ::A::data ; // OK
    }
} ;
</pre>

<p>
クラスCからは、名前dataは、基本クラスAのメンバーdataとして発見されるので、アクセスできない。しかし、クラスA自体は、名前空間に存在するので、明示的な修飾を使えば、アクセスできる。
</p>

<p>
protectedの場合、friendではないクラス外部の関数からアクセスできなくなる。
</p>

<pre>
struct A { static int data ; }
int A::data ;

class B : protected A { } ;

int main()
{
    B::data ; // エラー
    A::data ; // OK
}
</pre>

<p>
ここでは、B::dataとA::dataは、どちらも同じオブジェクトを指しているが、アクセス指定の違いにより、B::dataという修飾名では、クラスBのfriendではないmain関数からアクセスすることができない。
</p>

<p>
基本クラスにアクセス可能である場合、派生クラスへのポインター型から、基本クラスへのポインター型に型変換できる。
</p>

<pre>
class A { } ;
class B : public A { } ;
class C : protected A
{
    void f()
    {
        static_cast&lt; A * &gt;( this ) ; // OK、アクセス可能
    }
} ;

int main()
{
    B b ;  
    static_cast&lt; A * &gt;( &amp;b ) ; // OK、アクセス可能
    C c ;
    static_cast&lt; A * &gt;( &amp;c ) ; // エラー、main関数からは、protectedメンバーにアクセスできない
    
}
</pre>
</article>

<article>
<h1 id="class.friend"><a href="#class.friend">friend（Friends）</a></h1>

<p>
クラスはfriendを宣言することができる。friendを宣言するには、friend指定子を使う。クラスのfriendとして宣言できるものは、関数かクラスである。クラスのfriendは、クラスのprivateとprotectedメンバーにアクセスできる。
</p>

<pre>
class X
{
private :
    typedef int type ; // privateメンバー
    friend void f() ; // friend関数
    friend class Y ; // friendクラス
} ;

void f()
{
    X::type a ; // OK、関数void f(void)はXのfriend
}

class Y
{
    X::type member ; // OK、クラスYはXのfriend
    void f()
    {
        X::type member ; // OK、クラスYはXのfriend        
    }
} ;
</pre>

<p>
friendクラスの宣言は、friend指定子に続けて、<a href="#dcl.type.elab">複雑型指定子</a>、<a href="#dcl.type.simple">単純型指定子</a>、typename指定子（<a href="#temp.res">名前解決</a>を参照）のいずれかを宣言しなければならない。
</p>

<p>
複雑型指定子は、最も分かりやすい。
</p>

<pre>
class X
{
    friend class Y ;
    friend struct Z ;
} ;
</pre>

<p>
複雑型指定子を使う場合、クラスをあらかじめ宣言しておく必要はない。名前がクラスであることが、その時点で宣言されるからだ。
</p>

<p>
単純型指定子に名前を使う場合は、それより以前に、クラスを宣言しておく必要がある。
</p>

<pre>
class Y ; // Yをクラスとして宣言

class X
{
    friend Y ; // OK、Yはクラスである
    friend Z ; // エラー、名前Zは見つからない

    friend class A ; // OK、Aはクラスとして、ここで宣言されている
} ;
</pre>

<p>
あらかじめ名前が宣言されていない場合は、エラーとなる。
</p>

<p>
単純型指定子にテンプレート名を使うこともできる。
</p>

<pre>
template &lt; typename T &gt;
class X
{
    friend T ; // OK
} ;
</pre>

<p>
typename指定子を指定する場合は、以下のようになる。
</p>

<pre>
template &lt; typename T &gt;
class X
{
    friend typename T::type ;
} ;
</pre>

<p>
T::typeは、依存名を型として使っているので、typenameが必要である。
</p>

<p>
もし、型指定子がクラス型ではない場合、単に無視される。これは、テンプレートコードを書くときに便利である。
</p>

<pre>
template &lt; typename T &gt;
class X
{
    friend T ;
} ;

X&lt;int&gt; x ; // OK、friend宣言は無視される

template &lt; typename T &gt;
class Y
{
    friend typename T::type ;
} ;

struct Z { typedef int type ; } ;

Y&lt;Z&gt; y ; // OK、friend宣言は無視される
</pre>

<p>
無視されるのは、あくまで、型指定子がクラス型ではなかった場合である。すでに説明したように、単純型指定子で、名前が見つからなかった場合は、エラーになる。
</p>

<p>
friend関数の宣言は、通常通りの関数の宣言の文法に、friend指定子を記述する。前方宣言は必須ではない。friend関数には、<a href="#dcl.stc">ストレージクラス指定子</a>を記述することはできない。
</p>

<pre>
class X
{
    friend void f() ;
    friend int g( int, int, int ) ;
    friend X operator + ( X const &amp;, X const &amp; ) ;
} ;
</pre>

<p>
friend関数として宣言された関数がオーバーロードされていた場合でも、friend関数として宣言したシグネチャの関数しか、friendにはならない。
</p>

<pre>
void f( int ) ;
void f( double ) ;

class X
{
    friend void f( int ) ;
} ;
</pre>

<p>
この例では、void f(int)のみが、Xのfriend関数になる。void f(double)は、friend関数にはならない。
</p>

<p>
他のクラスのメンバー関数も、friend関数として宣言できる。メンバー関数には、コンストラクターやデストラクターも含まれる。
</p>

<pre>
class X ; // 名前Xをクラス型として宣言

class Y
{
public :
    void f( ) ; // メンバー関数
    Y &amp; operator = ( X const &amp; ) ; // 代入演算子
    Y() ; // コンストラクター
    ~Y() ; // デストラクター
} ;

class X
{
    // 以下4行は、すべて正しいfriend宣言
    friend void Y::f( ) ;
    friend Y &amp; Y::operator = ( X const &amp; ) ;
    friend Y::Y() ;
    friend Y::~Y() ;
} ;
</pre>

<p>
friend宣言自体には、アクセス指定は適用されない。ただし、friend宣言の中でアクセスできない名前を使うことはできない。
</p>

<pre>
class Y
{
private :
    void f( ) ; // privateメンバー
} ;

class X
{
    // エラー、Yのprivateメンバーにはアクセス出来ない
    // friend宣言の中の名前の使用には、アクセス指定が影響する
    friend void Y::g() ;

// アクセス指定は、friend宣言自体に影響を及ぼさない
// 以下3行のfriend宣言に、アクセス指定は何の意味もなさない
private :
    friend void f() ;
protected :
    friend void g() ;
public :
    friend void h() ;
} ;
</pre>

<p>
Y::fはprivateメンバーなので、Xからはアクセスできない。Xのfriend宣言は、関数f, g, hを、Xのfriendとして宣言しているが、この宣言に、Xのアクセス指定は何の効果も与えない。
</p>

<p>
friend宣言は、実は関数を定義することができる。
</p>

<pre>
class X
{
    friend void f() { } // 関数の定義
} ;
</pre>

<p>
friend宣言で定義された関数は、クラスが定義されている名前空間スコープの関数になる。クラスのメンバー関数にはならない。ただし、friend宣言で定義された関数は、ADLを使わなければ、呼び出すことはできない。非修飾名前探索や、修飾名前探索で、関数名を参照する方法はない。
</p>

<pre>
// グローバル名前空間のスコープ

class X
{
    // fはメンバー関数ではない
    // クラスXの定義されているグローバル名前空間のスコープ内の関数
    friend void f( X ) { }
    // gはメンバー関数ではない
    // gを呼び出す方法は存在しない
    friend void g() { }
} ;

int main()
{
    X x ;
    f(x) ; // OK、ADLによる名前探索

    (f)(x) ; // エラー、括弧がADLを阻害する。ADLが働かないので名前fが見つからない
    ::f(x) ; // エラー、名前fが見つからない
    g() ; // エラー、名前gが見つからない
}
</pre>

<p>
このように、通常の名前探索では関数名が見つからないという問題があるため、friend宣言内での関数定義は、行うべきではない。
</p>


<p>
friendによって宣言された関数は、前方宣言されていない場合、外部リンケージを持つ。前方宣言されている場合、リンケージは前方宣言に従う。
</p>

<pre>
inline void g() ; // 前方宣言、関数gは内部リンケージを持つ

class X
{
    friend void f() ; // 関数fは外部リンケージを持つ
    friend void g() ; // 関数gは内部リンケージを持つ
} ;

// 定義
void f() { } // 外部リンケージ
inline void g() { }
</pre>

<p>
friend宣言は、派生されることはない。また、あるクラスのfriendのfriendは、あるクラスのfriendではない。つまり、友達の友達は、友達ではない。
</p>

<pre>
class A
{
private :
    typedef int type ;
    friend class B ;
} ;

class B
{
    // OK、BはAのfriend
    typedef A::type type ;

    friend class C ;
} ;

class C
{
    // エラー、BはAのfriendである。CはBのfriendである。
    // Cは、Aからみて、friendのfriendにあたる。
    // しかし、CはAのfriendではない。
    typedef A::type type ;
} ;

class D : public B
{
    // エラー、DはBから派生している。BはAのfriendである。
    // しかし、DはAのfriendではない
    typedef A::type type ;
} ;
</pre>

<p>
ローカルクラスの中でfriend宣言で、非修飾名を使った場合、名前探索において、ローカルクラスの定義されている関数外のスコープは考慮されない。friend関数を宣言する場合、対象の関数はfriend宣言に先立って宣言されていなければならない。friendクラスを宣言する場合、クラス名はローカルクラスの名前であると解釈される。
</p>

<pre>
class A ; // ::A
void B() ; // ::B

void f()
{
    // 関数の前方宣言は関数内でも可能
    void C( void ) ; // 定義は別の場所

    class Y ; // ローカルクラスYの宣言

    // ローカルクラスXの定義
    class X
    {
        friend class A ; // OK、ただし、::Aではなく、ローカルクラスのA
        friend class ::A ; // OK、::A
        friend class Y ; // OK、ただしローカルクラスY

        friend void B() ; // エラー、Bは宣言されていない。::Bは考慮されない
        friend void C() ; // OK、関数内の前方宣言により名前を発見
    } ;
}
</pre>

<p>
friend宣言とテンプレートの組み合わせについては、<a href="#temp.friend">テンプレート宣言のfriend</a>を参照。
</p>
</article>

<article>
<h1><a href="#class.protected">protectedメンバーアクセス（Protected member access）</a></h1>

<p class="editorial-note">
TODO:保留
</p>
</article>

<article>
<h1 id="class.access.virt"><a href="#class.access.virt">virtual関数へのアクセス（Access to virtual functions）</a></h1>

<p>
virtual関数へのアクセスは、virtual関数の宣言によって決定される。virtual関数のオーバーライドには影響されない。
</p>

<pre>
class Base
{
public :
    virtual void f() { }
} ;

class Derived : public Base
{
private :
    void f() { } // Base::fをオーバーライド
} ;

int main()
{
    Derived d ;
    d.f() ; // エラー、Derived::fはprivateメンバー

    Base &amp; ref = d ;
    ref.f() ; // OK、Derived::fを呼ぶ
}
</pre>

<p>
Derived::fはprivateメンバーなので、関数mainから呼び出すことはできない。しかし、Base::fはpublicメンバーである。Base::fはvirtual関数なので、呼び出す関数は、実行時のオブジェクトの型によって決定される。この時、オーバーライドしたvirtual関数のアクセス指定は、考慮されない。Base::fのアクセス指定のみが考慮される。この例では、関数mainから、Derived::fを直接呼び出すことはできないが、Baseへのリファレンスやポインターを経由すれば、呼び出すことができる。
</p>

<p>
virtual関数呼び出しのアクセスチェックは、呼び出す際の式の型によって、静的に決定される。基本クラスでpublicメンバーとして宣言されているvirtual関数を、派生クラスでprotectedやprivateにしても、基本クラス経由で呼び出すことができる。
</p>
</article>

<article>
<h1 id="class.paths"><a href="#class.paths">複数のアクセス（Multiple access）</a></h1>

<p>
多重派生によって、基本クラスのメンバーに対して、複数のアクセスパスが形成されている場合、アクセス可能なパスを経由してアクセスが許可される。
</p>

<pre>
class Base
{
public :
    void f() { }
} ;

class D1 : private virtual Base { } ;
class D2 : public virtual Base { } ;

class Derived : public D1, public D2
{
    void f()
    {
        Base::f() ; // OK、D2を経由してアクセスする
    }
} ;
</pre>

<p>
D1はBaseをprivate派生しているので、DerivedからD1経由では、Baseにアクセスできない。しかし、D2経由でアクセスできる。
</p>
</article>

<article>
<h1 id="class.access.nest"><a href="#class.access.nest">ネストされたクラス（Nested classes）</a></h1>

<p>
ネストされたクラスも、クラスのメンバーであるので、他のメンバーとアクセス権限を持つ。
</p>

<pre>
class Outer
{
private :
    typedef int type ; // privateメンバー

    class Inner
    {
        Outer::type data ; // OK、InnerはOuterのメンバー
    } ;
} ;
</pre>

<p>
OuterにネストされたクラスInnerは、Outerのメンバーなので、Outerのprivateメンバーにアクセスすることができる。
</p>

<p>
ただし、ネストされたクラスをメンバーとして持つクラスは、ネストされたクラスに対して、特別なアクセス権限は持たない。
</p>

<pre>
class Outer
{
    class Inner
    {
    private :
        typedef int type ; // privateメンバー
    } ;

    void f()
    {
        Inner::type x ; // エラー、Inner::typeはprivateメンバー
    }
} ;
</pre>

<p>
この例では、Outerは、Innerのprivateメンバーにはアクセスできない。
</p>
</article>

</article>

<article class="toplevel">
<h1 id="special"><a href="#special">特別なメンバー関数（Special member functions）</a></h1>

<p>
クラスのメンバー関数の中でも、特別な扱いを受けるメンバー関数が存在する。デフォルトコンストラクター、コピーコンストラクター、コピー代入演算子、ムーブコンストラクター、ムーブ代入演算子、デストラクターは、特別なメンバー関数（special member functions）である。
</p>

<p>
これらのメンバー関数を明示的に定義しない場合、暗黙のメンバー関数が生成される。暗黙に生成された特別なメンバー関数は、明示的に使用することもできる。
</p>

<pre>
#include &lt;utility&gt;

struct X { } ;

int main()
{
    X x1 ; // デフォルトコンストラクター
    X x2( x1 ) ; // コピーコンストラクター
    X x3( std::move(x1) ) ; // ムーブコンストラクター

    x2 = x1 ; // コピー代入演算子
    x2 = std::move( x1 ) ; // ムーブ代入演算子

    x2.operator=( x1 ) ; // メンバー関数の明示的な使用、x2 = x1と同等
}
</pre>

<p>
クラスXは、特別なメンバー関数を一切定義していない。しかし、特別なメンバー関数は、暗黙のうちに生成されるので、クラスXのオブジェクトを初期化、破棄できるし、コピーやムーブもできる。
</p>

<p>
ユーザー定義されていない特別なメンバー関数は、条件次第で、暗黙にdelete定義されることもある。そのようなクラスの特別なメンバー関数を使いたい場合は、ユーザー定義しなければならない。
</p>

<pre>
struct X
{
    int &amp; member ;
// デフォルトコンストラクターは暗黙にdelete定義される
// X() = delete ; が暗黙に宣言される
} ;

int data ; // グローバル変数

struct Y
{
    int &amp; member ;
    Y() : member(data) { }
} ;

int main ()
{
    X x ; // エラー、デフォルトコンストラクターはdelete定義されている
    Y y ; // OK、ユーザー定義のデフォルトコンストラクターがある
}
</pre>

<p>
特別なメンバー関数を明示的に宣言、定義することで、クラスをどのように生成、破棄、コピー、ムーブするかを記述できる。また、これらの操作を、明示的に禁止することもできる。
</p>

<pre>
struct X
{
    // コピー、ムーブコンストラクターをdelete定義
    X( X const &amp; ) = delete ;
    X( X &amp;&amp; ) = delete ;

    // コピー、ムーブ代入演算子をdelete定義
    X &amp; operator = ( X const &amp; ) = delete ;
    X &amp; operator = ( X &amp;&amp; ) = delete ;
} ;
</pre>

<p>
この例では、コピーもムーブもできないクラスを定義している。
</p>

<p>
特別なメンバー関数も、アクセス指定の影響を受ける。
</p>

<pre>
class X
{
public :
    X( int ) { }
private :
    X( double ) { }
} ;

int main ()
{
    X a( 0 ) ; // OK、X::X(int)はpublicメンバー
    X b( 0.0 ) ; // エラー、X::X(double)はprivateメンバー
}
</pre>

<p>
この例では、X::X(int)はpublicメンバーなので、main関数からアクセスできるが、X::X(double)は、privateメンバーなので、main関数からアクセスできない。その結果、変数bの定義はエラーとなる。
</p>

<article>
<h1 id="class.ctor"><a href="#class.ctor">コンストラクター（Constructors）</a></h1>

<p>
コンストラクターは名前を持たない。コンストラクターの宣言には、特別な文法が用いられる。
</p>

<pre>
関数指定子もしくはconstexpr クラス名 仮引数リスト
</pre>

<pre>
struct X
{
    X() ; // コンストラクターの宣言
} ;

X::X() { } // コンストラクターの定義
</pre>

<p>
コンストラクターは、クラス型のオブジェクトを初期化するのに用いられる。
</p>

<p>
コンストラクターのクラス名に、typedef名を用いることはできない。
</p>

<p>
コンストラクターに、virtual指定子、static指定子を指定することはできない。要約すれば、コンストラクターに使用可能な指定子は、inline、explicit、constexprである。コンストラクターをCV修飾することはできない。ただし、コンストラクターは、CV修飾されたオブジェクトの初期化に対しても、呼び出される。オブジェクトのCV修飾子は、構築中のオブジェクトには適用されないからである。コンストラクターをリファレンス修飾することはできない。
</p>

<pre>
struct X {
    virtual X() ; // エラー、コンストラクターにvirtual指定子は使えない
    static X() ; // エラー、コンストラクターにstatic指定子は使えない
    X() const ; // エラー、コンストラクターはCV修飾できない
    X() &amp; ; // エラー、コンストラクターはリファレンス修飾できない
} ;
</pre>

<h1>デフォルトコンストラクター</h1>
<p>
実引数なしで呼べるコンストラクターを、デフォルトコンストラクター（default constructor）という。これには、仮引数を取らないコンストラクターの他に、仮引数にすべてデフォルト実引数が指定されているコンストラクターも含まれる。
</p>


<p>
以下はすべて、Xに対するデフォルトコンストラクターの宣言である。
</p>

<pre>
X() ;
X( int = 0 ) ;
X( int = 0, int = 0 ) ;
</pre>

<p>
もし、ユーザー定義のデフォルトコンストラクターが存在しない場合、暗黙のデフォルトコンストラクターが、デフォルト化されて宣言される。
</p>

<pre>
struct X
{
// デフォルトコンストラクターの定義なし
// 暗黙に、X() = default ; が宣言される
} ;

struct Y
{
    Y(int) ; // ユーザー定義のコンストラクター
// 暗黙のデフォルトコンストラクターはdefault化されない
} ;
</pre>

<p>
ただし、以下のいずれかの条件をみたすクラスの場合、暗黙のデフォルトコンストラクターはdelete定義される。
</p>

<p>
<a href="#variant_member">unionのようなクラス</a>で、共用メンバーが非トリビアルデフォルトコンストラクターを持つ場合
</p>

<pre>
// 非トリビアルデフォルトコンストラクターを持つクラス
struct NonTrivial
{
    NonTrivial() { } // 非トリビアルデフォルトコンストラクター
} ;

// 非トリビアルデフォルトコンストラクターを持つメンバーのあるunion
union X
{
// 暗黙のデフォルトコンストラクターはdelete定義される
    NonTrivial nt ;
} ;

// そのような無名unionを直接のメンバーに持つクラス
struct Y
{
// 暗黙のデフォルトコンストラクターはdelete定義される
    union { NonTrivial nt ; } ;
} ;
</pre>

<p>
初期化子のないリファレンス型の非staticデータメンバーを持つクラスの場合
</p>

<pre>
int OBJECT ; // グローバル変数

struct X
{
// 初期化子のないリファレンス型の非staticデータメンバー
    int &amp; ref ;
} ;

struct Y
{
// 初期化子がある
    int &amp; ref = OBJECT ;
} ;

struct Z
{
    int &amp; ref ;
// ユーザー定義のコンストラクターがある
    Z() : ref( OBJECT ) { }
} ;

int main ()
{
    X x ; // エラー、デフォルトコンストラクターがdelete定義される
    Y y ; // OK
    Z z ; // OK
}
</pre>

<p>
クラスXのデフォルトコンストラクターは暗黙にdelete定義される。Y::refには初期化子がある。Z::refはstaticデータメンバーである。
</p>

<p>
unionのメンバーではない、const修飾された型かあるいはその配列型の、非staticデータメンバーが、ユーザー定義デフォルトコンストラクターを持たず、初期化子もない場合。
</p>

<pre>
// ユーザー定義デフォルトコンストラクターを持たないクラス
struct NoUserDefined { } ;

struct X
{
// 初期化子がない
    NoUserDefined const member ;
    NoUserDefined const array[1] ;
} ;

struct Y
{
// 初期化子がある
    NoUserDefined const member = NoUserDefined() ;
} ;


struct Z
{
    NoUserDefined const member ;
// memberに対する初期化子がないので不可
// Z() : member() { } なら可
    Z() { }    
} ;

int main ()
{
    X x ; // エラー
    Y y ; // OK
    Z z ; // エラー
}
</pre>

<p>
気をつける点としては、Zのユーザー定義デフォルトコンストラクターが、Z(){}という形の場合、Z::memberに対する初期化子がないので、エラーになる。Z() : member() { }という形の場合は、初期化子があるので、エラーにはならない。
</p>

<p>
<a href="#variant_member">unionのようなクラス</a>で、共用メンバーがconst修飾されている場合。これには、const修飾されている型への配列型も含む。
</p>

<pre>
union X
{ // すべてconst修飾されている
    int const a ;
    int const b ;
    int const c[1] ;
} ;

struct Y
{ // すべてconst修飾されている無名unionをメンバーに持つ
    X x ;
} ;

union Z
{
    int a ; // const修飾されていない
    int const b ;
    int const c[1] ;
} ;


int main ()
{
    X x ; // エラー
    Y y ; // エラー
    Z z ; // OK、Y::aはconst修飾されていない。
}
</pre>

<p>
unionのすべての非staticデータメンバーがconst修飾されている場合のみ、デフォルトコンストラクターが暗黙にdelete定義される。ひとつでもconst修飾されていない非staticデータメンバーがある場合、この条件には当てはまらない。
</p>


<p>
直接の基本クラス、仮想基本クラス、初期化子のない非staticデータメンバーの型が、デフォルトコンストラクターが使えない型である場合。これには、配列型も含まれる
</p>

<pre>
// デフォルトコンストラクターが使えないクラスの例
struct X
{
    X() = delete ;
} ;

// 直接の基本クラス
struct A : X { } ;
// 仮想基本クラス
struct B : virtual X { } ;
// 初期化子のない非staticデータメンバー
struct C
{
    X a ;
    X b[1] ;
} ;
</pre>

<p>
クラスA、B、Cは、いずれもデフォルトコンストラクターが暗黙にdelete定義される。
</p>

<p>
ある型のデフォルトコンストラクターが使えない場合というのは、以下の通りである。
</p>

<p>
デフォルトコンストラクターがない場合。
</p>

<pre>
// ユーザー定義コンストラクターがある場合、暗黙のデフォルトコンストラクターは定義されない。
struct NoDefaultConstructor { NoDefaultConstructor(int) ; } ;
struct X : NoDefaultConstructor { } ;
</pre>

<p>
デフォルトコンストラクターのオーバーロード解決の結果が曖昧になる場合。
</p>

<pre>
struct Ambiguous
{
    Ambiguous( int = 0 ) { }
    Ambiguous( double = 0.0 ) { }
} ;

struct X : Ambiguous { } ;

int main ()
{
    Ambiguous a ; // エラー、デフォルトコンストラクターのオーバーロード解決が曖昧
    X b ; // エラー、デフォルトコンストラクターは暗黙にdelete定義されている
}
</pre>

<p>
デフォルトコンストラクターがdelete定義されている場合
</p>

<pre>
struct X
{
    X() = delete ; // デフォルトコンストラクターのdelete定義
} ;
</pre>

<p>
クラスのデフォルト化されたデフォルトコンストラクターから、ある型のデフォルトコンストラクターにアクセス出来ない場合。
</p>

<pre>
class B1
{
private :
    B1() = default ;
} ;

class B2
{
private :
    B2() { }
} ;

class D1 : public B1 { } ;
class D2 : public B2 { } ;

int main()
{
    D1 a ; // エラー、デフォルトコンストラクターは暗黙にdelete定義されている
    D2 b ; // エラー、デフォルトコンストラクターは暗黙にdelete定義されている
}
</pre>

<p>
クラスB1、B2のデフォルトコンストラクターは、privateメンバーなので、friendではないクラスD1、D2からはアクセスできない。そのため、デフォルトコンストラクターは暗黙にdelete定義される。
</p>

<p>
これらの条件に当てはまらない場合、デフォルトコンストラクターは暗黙にdefault化される。
</p>

<p>
デフォルトコンストラクターがトリビアル（trivial）となるためには、以下の条件をすべて満たさなければならない。
</p>

<p>
デフォルトコンストラクターがユーザー定義もdelete定義もされていない。クラスはvirtual関数とvirtual基本クラスを持たない。クラスの非staticデータメンバーは、初期化子を持たない。クラスの直接の基本クラスは、トリビアルデフォルトコンストラクターを持つ。クラスの非staticデータメンバーは、トリビアルデフォルトコンストラクタを持つ。
</p>

<p>
デフォルトコンストラクターは、使われたときに、暗黙にdefault化される。デフォルトコンストラクターがdelete定義されずに、default化された場合、暗黙に定義される。この暗黙のデフォルトコンストラクターは、コンストラクター初期化子を書かずコンストラクターの本体を空にした、ユーザー定義のデフォルトコンストラクターと同等である。
</p>

<pre>
struct X
{
    // 暗黙のデフォルトコンストラクターは、以下のコードと同じ
    // X(){}
} ;

struct Y { } ;

int main()
{
    X x ; // 暗黙のデフォルトコンストラクターを使う
}
</pre>

<p>
クラスXはデフォルトコンストラクターが使われているので、暗黙にdefault化される。クラスYのデフォルトコンストラクターは使われていないので、定義されない。
</p>

<p>
もし、暗黙のデフォルトコンストラクターが定義されていて、同等のユーザー定義のデフォルトコンストラクターを書いた場合にエラーとなる場合は、プログラムもエラーとなる。
</p>

<pre>
struct X { int &amp; ref ; } ;
struct Y { int &amp; ref ; } ;

int main()
{
    X x ; // エラー
    int obj = 0 ;
    Y y = { obj } ; // OK
}
</pre>

<p>
クラスXはデフォルトコンストラクターを使っているので、暗黙のデフォルトコンストラクターがdefault化される。しかし、リファレンスの非staticデータメンバーを持つことにより、同等のユーザー定義のデフォルトコンストラクターがエラーになるので、エラーとなる。一方、クラスYでは、デフォルトコンストラクターが使われていない
</p>

<p>
同等のユーザー定義のデフォルトコンストラクターがconstexprコンストラクターの要求を満たす場合、暗黙のデフォルトコンストラクターも、constexprコンストラクターになる。
</p>

<p>
デフォルトコンストラクターは、初期化子なしで定義されたオブジェクトや、関数形式の明示的なキャストに対して呼ばれる。
</p>

<pre>
struct X { X() { } } ;

X x ; // デフォルトコンストラクターが呼ばれる

int main()
{
    X x ; // デフォルトコンストラクターが呼ばれる
    new X ; // デフォルトコンストラクターが呼ばれる
    X() ; // デフォルトコンストラクターが呼ばれる
}
</pre>

<p>
クラスのオブジェクトをコピー、ムーブする際には、コピー、ムーブコンストラクターがそれぞれ使われる。詳しくは、<a href="#class.copy">クラスオブジェクトのコピーとムーブ</a>を参照。
</p>

<p>
基本クラスと非staticデータメンバーのコンストラクターが呼ばれる順番や、実引数の渡し方については、<a href="#class.base.init">基本クラスとデータメンバーの初期化</a>を参照。
</p>

<p>
その他のコンストラクターについては、<a href="#class.conv.ctor">型変換コンストラクター</a>を参照。
</p>

<p>
コンストラクターに戻り値の型を指定することはできない。コンストラクターの本体の中でreturn文を使う場合は、値を指定してはならない。コンストラクターのアドレスを取得することはできない。
</p>

<p>
constなオブジェクトの構築中に、コンストラクターのthisを、直接、間接的に経由しないglvalueによってオブジェクト、またはそのサブオブジェクトにアクセスした場合、値は未規定である。この制限には、通常、まず遭遇することはない。例えば、以下のようなコードが問題になる。
</p>

<pre>
struct C ;

void f( C * ) ;

struct C
{
    int value ;
    C() : c(123)
    { // オブジェクトは、まだ構築中
        f( this ) ; // オブジェクトの構築中に呼び出す
    }
} ;

const C cobj ; // staticストレージ上のconstなオブジェクト

void f( C* cptr )
{
    cptr-&gt;value ; // OK、値は123。cptrはコンストラクターのthis由来
    cobj.value ; // 値は未規定
}
</pre>

<p>
オブジェクトは、コンストラクターを実行し終わった時点で、構築済みとなる。コンストラクターを実行中ということは、まだオブジェクトは構築中ということである。cobjは、デフォルトコンストラクターを呼び出す。したがって、関数fは、cobjの構築中に呼び出されるということになる。cptrの値は、コンストラクターのthisによって得られたアドレスである。したがって、cptrの値である、Cのオブジェクトへのアドレスを参照して、cobjにアクセスすることはできる。関数fは、クラスCのコンストラクターから呼び出されている。関数fの中からcobjを直接参照するということは、cobjの構築中に、コンストラクターのthisによらずにアクセスするということである。この場合、値は未規定となる。この例では、123であるとは保証されない。
</p>

<p>
この条件に当てはまるようなコードは、現実には極めて珍しい。
</p>
</article>

<article>
<h1 id="class.temporary"><a href="#class.temporary">一時オブジェクト（Temporary objects）</a></h1>

<p>
一時オブジェクト（temporary object）は、様々な場面で、自動的に生成、破棄される。例えば、prvalueをリファレンスに束縛する、prvalueを返す、prvalueを生成する型変換、例外のthrow、ハンドラーでキャッチ、初期化などである。例外における一時オブジェクトの寿命は、<a href="#except">例外</a>を参照。
</p>

<pre>
struct X { } ;

X f()
{
    return X() ; // prvalueを生成する型変換
}

int main()
{
    int &amp;&amp; ref = 0 ; // prvalueをリファレンスに束縛する
    f() ; // prvalueを返す
}
</pre>

<p>
実装は一時オブジェクトの生成を省略できる。例えば、以下のコードについて考える。
</p>

<pre>
struct X
{
    X( int ) ; // コンストラクター
    X( X const &amp; ) ; // コピーコンストラクター
    X &amp; operator = ( X const &amp; ) ; // コピー代入演算子
    ~X() ; // デストラクター
} ;

struct Y
{
    Y( int ) ; // コンストラクター
    Y( Y &amp;&amp; ) ; // ムーブコンストラクター
    ~Y() ; // デストラクター
};

X f( X ) ;
Y g( Y ) ;

int main()
{

    X a = f( X(2) ) ; // #1
    Y b = g( Y(3) ) ; // #2
    X c(1) ;
    c = f(c) ; // #3
}
</pre>

<p>
#1について考える。ある実装では、X(2)という式で一時オブジェクトがひとつ作られ、関数の実引数として渡す際に、別の一時オブジェクトがひとつ作られてコピーされるかもしれない。関数の戻り値も、別の一時オブジェクトがひとつ作られて、変数aにコピーされるかもしれない。別の実装では、X(2)という式による一時オブジェクトは、関数の実引数の一時オブジェクト上に直接構築されるので、一時オブジェクトを省略できるかもしれない。関数の戻り値も、変数aのオブジェクト上に直接構築されるので、一時オブジェクトを省略できるかもしれない。
</p>

<p>
#2も、コピーがムーブに、変数aがbに変わっただけで、同じことが言える。
</p>

<p>
#3では、変数cは、すでに構築されたオブジェクトなので、関数の戻り値の一時オブジェクトを、変数cのオブジェクトの上に、直接構築することはできない。ここでは一時オブジェクトが構築され、変数cにコピーされる。
</p>

<p>
一時オブジェクトの構築が省略されたとしても、もし一時オブジェクトを作成していればエラーになるようなコードは、エラーになる。たとえば、コンストラクターやデストラクターにアクセスできない場合だ。
</p>

<p>
一般に、ある式において一時オブジェクトがいくつ構築されるかということは、規格では定義されていない。実装次第である。一時オブジェクトが構築されなければ、コンストラクターやデストラクターも呼ばれない。
</p>

<p>
逆に、一時オブジェクトが構築される場合、非トリビアルなコンストラクターは必ず呼び出されるし、破棄するときには、非トリビアルなデストラクターは必ず呼び出される。
</p>

<p>
一時オブジェクトの破棄は原則として、その一時オブジェクトを構築することになった式を含む<a href="#intro.execution">完全式</a>の評価の最後の段階として、実行される。言いかえれば、一時オブジェクトの寿命は、完全式が評価され終わるまでということもできる。
</p>

<pre>
struct X
{
    X operator + ( X const &amp; ){ return X() ; }
} ;

int main()
{
    X a = 0 ;
    X b = a + a + a ;
}
</pre>

<p>
この例で、yの初期化子の中の式において構築された一時オブジェクトがもしあれば、その寿命は、ソースコード上で言えば、セミコロンまでとなる。
</p>

<p>
ただし、この原則に従わない場合が、ふたつ存在する。
</p>

<p>
ひとつは、配列の要素を初期化する際に、デフォルトコンストラクターがデフォルト実引数を持っていた場合、ある要素のデフォルトコンストラクター実行における一時オブジェクトの破棄は、次の要素の初期化の前に行われる。破棄に伴うあらゆるサイドエフェクトは、次の要素の初期化の以前にシーケンス（sequenced before）される。
</p>

<pre>
struct Fat { char [1000] ; } ;

struct X
{
    X( Fat f = Fat() ) { } // デフォルトコンストラクター
} ;

int main()
{
    X a[1000] ;
}
</pre>

<p>
この例では、a[0]からa[999]までの1000個のX型の配列の要素に対し、デフォルトコンストラクターが呼び出される。もし、a[0]がa[1]の前に初期化された場合、a[0]のデフォルトコンストラクター呼び出しによって構築されたFat型の一時オブジェクトは、a[1]を初期化するときには、すでに破棄されている。配列のすべての要素を初期化し終わるまで、1000個のFat型の一時オブジェクトが保持されることはない。
</p>

<p>
もうひとつは、一時オブジェクトをリファレンスに束縛した場合、一時オブジェクトの寿命は、リファレンスの寿命まで延長される。一時オブジェクトは、rvalueリファレンスか、constなlvalueリファレンスで束縛できる。
</p>

<pre>
struct X { } ;

int main()
{
    {
        X const &amp; lvalue_reference = X() ;
        X &amp;&amp; rvalue_reference = X() ;
    // 一時オブジェクトの寿命はここまで
    }
}
</pre>

<p>
ただし、このリファレンス束縛の寿命の延長には、いくつかの例外が存在する。
</p>

<p>
コンストラクター初期化子によってリファレンスのメンバーに束縛された一時オブジェクトの寿命は、コンストラクター呼び出しが終了するまでである。
</p>

<pre>
struct Member { } ;

struct X
{
    Member const &amp; ref ;
    X( Member const &amp; ref ) : ref(ref)
    {
        // refは妥当なオブジェクトを参照している
    }
} ;

int main()
{
    X x = Member()  ;
    // 一時オブジェクトが破棄される
    // x.refは無効なオブジェクトを参照している
}
</pre>

<p>
もし、クラスXのコンストラクターの実引数が、一時オブジェクトへのリファレンスだった場合、一時オブジェクトの寿命は、コンストラクター呼び出しが終了するまでである。そのため、初期化の終わった変数xのメンバーrefは、無効なオブジェクトを参照していることになる。
</p>

<p>
仮引数のリファレンスに束縛された一時オブジェクトの寿命は、関数呼び出しを含む式の完全式の評価が終了するまでである。
</p>

<pre>
struct X { } ;

void f( X const &amp; ref )
{
    // refは妥当なオブジェクトを参照している
}

int main()
{
    f( X() ) ;
    // 一時オブジェクトが破棄される
}
</pre>

<p>
この例で、X()を含む完全式というのは、関数fに対する関数呼び出し式のオペランドである。したがって、完全式はX()となる。しかし、この解釈に従うと、関数の本体では、refは無効なオブジェクトを参照することになってしまう。そのため、仮引数のリファレンス束縛に対しては、関数呼び出しを含む完全式になる。この場合、f( X() )である。そのため、X()によって構築された一時オブジェクトは、関数fの本体の中でも妥当である。
</p>

<p>
関数のreturn文によって構築された、関数の戻り値のリファレンスに束縛された一時オブジェクトの寿命は、延長されない。一時オブジェクトは、return文を含む完全式の終了をもって、破棄される。
</p>

<pre>
struct X { } ;

X const &amp; f( X const &amp; ref )
{
    return X() ;
}

int main()
{
    X const &amp; ref = f( X() ) ;
    // 一時オブジェクトは破棄される
    // refは無効なオブジェクトを参照している
}
</pre>

<p>
このように、関数の戻り値としてのリファレンスに束縛されても、一時オブジェクトの寿命は延長されない。これには注意が必要である。
</p>

<p>
new初期化子の中でリファレンス束縛された一時オブジェクトの寿命は、new初期化子を含む完全式の終わりまでである。
</p>

<pre>
struct X { int const &amp; ref ; } ;

int main()
{
    X * ptr = new X{ 0 } ;
    // 一時オブジェクトが破棄される
    // ptr-&gt;refは無効なオブジェクトを参照している
}
</pre>

<p>
リファレンス束縛により、寿命の延長を受けていない一時オブジェクトの破棄の順番は、構築の逆順に行われる。後に構築された一時オブジェクトの方が、先に構築された一時オブジェクトより、先に破棄される。
</p>

<p>
もし、リファレンス束縛を受けた、複数の一時オブジェクトが、同じ場所で破棄される場合、破棄の順番は、構築の逆順に行われる。
</p>

<pre>
struct X { X( int ) { } } ;
void f( X const &amp;, X const &amp; ) { }

int main()
{
    f( X(1), X(2) ) ; // #1
}
</pre>

<p>
今、#1のX(1)、X(2)という式に対して、それぞれ一時オブジェクトが構築されたとする。関数の実引数の評価順序は規定されていないので、どちらが先に構築されるかは、規格の定めるところではない。しかし、仮にX(1)の一時オブジェクトが、X(2)に先んじて構築された場合、オブジェクトの破棄は、X(2)が先になる。
</p>
</article>

<article>
<h1 id="class.conv"><a href="#class.conv">型変換（Conversions）</a></h1>

<p>
クラスの型変換を実現するには、方法がふたつある。コンストラクターと変換関数（conversion function）だ。このふたつを合わせて、ユーザー定義型変換（user-deﬁned conversions）という。ユーザー定義型変換は、暗黙の型変換、初期化、明示的な型変換に用いられる。
</p>

<p>
ひとつの値に対して、ユーザー定義型変換は1回しか適用されない。
</p>

<pre>
struct X { } ;
struct Y
{
    Y( int ){ } // int型からY型へ
    operator X() { return X() ; } // Y型からX型へ
} ;

int main()
{
    Y a = 0 ; // OK、int型からY型への型変換
    X b = Y(0) ; // OK、Y型からX型への型変換
    X c = 0 ; // エラー
}
</pre>

<p>
ユーザー定義型変換によって、int型からY型に変換することはできる。また、Y型からX型に変換することはできる。ただし、int型から、暗黙にX型に変換することはできない。なぜならば、それにはユーザー定義型変換を、2回適用しなければならないからだ。
</p>

<p>
ユーザー定義型変換は、曖昧にならない場合のみ、暗黙に使われる。派生クラスの型変換関数は、基本クラスの型変換関数を隠さない。ただし、同じ型に対する型変換関数の場合を除く。複数の型変換関数がある場合、関数のオーバーロード解決と同じ方法で、最適な関数が解決される。
</p>

<pre>
struct Base
{
    operator int() { return 0 ; }
} ;
struct Derived : Base
{
    // Base::operator intを隠さない
    operator char() { return char(0) ; }
} ;

int main()
{
    Derived obj ;
    int a = obj ; // OK
    char b = obj ; // OK
    bool c = obj ; // エラー、　曖昧
}
</pre>

<article>
<h1 id="class.conv.ctor"><a href="#class.conv.ctor">コンストラクターによる型変換（Conversion by constructor）</a></h1>

<p>
explicit指定子を使わずに宣言されているコンストラクターは、仮引数からクラスへの型変換の方法を指定するメンバー関数である。このような関数を、型変換コンストラクター（converting constructor）という。
</p>

<pre>
struct X
{
    X( int ) {} // int型からの型変換を提供
    X( double ) {} // double型からの型変換を提供
    X( int, int, int ) ; // 3個のint型からの型変換を提供
} ;

int main()
{
    X a = 0 ; // int型からの型変換
    X b(0) ; // int型からの型変換
    X c = 0.0 ; // double型からの型変換
    X d( 1, 2, 3 ) ;
}
</pre>

<p>
型変換コンストラクターは、仮引数からクラス型への変換方法を指定する。仮引数は、複数でもよい。
</p>

<p>
explicit指定子のあるコンストラクターは、explicitのないコンストラクターとほぼ同じである。ただし、explicitコンストラクターは、<a href="#dcl.init">直接初期化</a>か、キャストが明示的に使われたときにしか、使われない。
</p>

<pre>
struct X
{
    explicit X( int ) {} // explicitコンストラクター
} ;

void f( X ) { }

int main()
{
    X a = 0 ; // エラー
    X b(0) ; // OK、直接初期化
    X c = X(0) ; // OK、明示的なキャスト
    X d = static_cast&lt;X&gt;(0) ; // OK、明示的なキャスト

    f( 0 ) ; // エラー
    f( static_cast&lt;X&gt;(0) ) ; // OK
}
</pre>

<p>
デフォルトコンストラクター、コピーコンストラクター、ムーブコンストラクターにも、explicitを指定できる。これらの関数も、explicit指定子を指定しない場合、暗黙に使われる。
</p>

<pre>
struct X
{
    X() { }
    explicit X( X const &amp; ) {} // explicitコピーコンストラクター
} ;

int main()
{
    X a ;
    X b = a ; // エラー、コピー初期化（代入式とは違うことに注意）
    X c( a ) ; // OK、直接初期化
}
</pre>

<p>
デフォルトコンストラクターに対するexplicit指定子の有無は、以下のコード例のような違いをもたらす。
</p>

<pre>
struct X
{
    X() { }
} ;

struct Y
{
    explicit Y() { }
} ;


int main( )
{
    X x( { } ) ; // OK、非explicitデフォルトコンストラクター
    Y y( { } ) ; // エラー、explicitデフォルトコンストラクター
}
</pre>

<p>
実用上、気になるほどの違いはない。
</p>

</article>

<article>
<h1 id="class.conv.fct"><a href="#class.conv.fct">型変換関数（Conversion functions）</a></h1>

<p>
以下のような文法で宣言されるメンバー関数を、型変換関数（Conversion function）という。
</p>

<pre>
explicit<sub>opt</sub> operator 型識別子 ( )
</pre>

<p>
型変換関数は、仮引数を取らず、戻り値の型を指定しない。型変換関数は、メンバーであるクラス型から、型識別子の型への型変換を提供する。
</p>

<pre>
struct X
{
    operator int() { return 0 ; } 
} ;

int main()
{
    X x ;
    int i = x ; // 0
}
</pre>

<p>
この例では、クラスXは、暗黙にint型の0に変換できるクラスとなる。
</p>

<p>
型変換関数の型は、「仮引数を取らず、型識別子の型を返す、メンバー関数」になる。
</p>

<pre>
struct X
{
    operator int() const { return 0 ; } 
} ;

int main()
{
    // 型はint (X::*)(void) const
    int (X::*ptr)(void) const = &amp;X::operator int ; // ポインターを得る
    X x ;
    (x.*ptr)() ; // 呼び出す
}
</pre>

<p>
型識別子が、自分自身のクラス型（リファレンスも含む）、自分自身の基本クラス型（リファレンスも含む）、void型、またこれらの型にCV修飾子を付けた型の場合、型変換関数が使われることはない。これらの型変換には、標準型変換が用いられる。型変換関数は使われない。これらの型変換関数を宣言することはエラーではないが、使われることはない。
</p>

<pre>
struct Base{ } ;

struct Derived : Base
{
    // これらの型変換関数は、使われることはない
    operator Derived () ; // 自分自身のクラス型
    operator Derived &amp; () ; // 自分自身のクラスへのリファレンス型
    operator Derived const &amp; () ; // 自分自身のクラスへのconstリファレンス型
    operator Base () ; // 基本クラス型
    operator void () ; // void型
} ;

int main()
{
    Derived d ;
    Base b = d ; // 標準型変換が使われる。型変換関数は使われない
}
</pre>

<p>
型変換関数にexplicit指定子が指定されている場合、型変換関数は、直接初期化や明示的なキャストが使われなければ、呼び出されない。
</p>

<pre>
struct A { } ;
struct B { } ;

struct X
{
    operator A() { return A() ; }
    explicit operator B() { return B() ; }

} ;

int main()
{
    X x ;

    A a1 = x ; // OK
    A a2(x) ; // OK
    A a3 = A(x) ; // OK

    B b1 = x ; // エラー、コピー初期化
    B b2(x) ; // OK、直接初期化
    B b3 = B(x) ; // OK、明示的なキャスト
}
</pre>

<p>
型変換関数の型識別子を、関数型と配列型にすることはできない。
</p>

<pre>
struct X
{
    operator void (void) () ; // エラー、関数型
    operator int[1] () ; // エラー、配列型
} ;
</pre>

<p>
その他の型には、特に制限はない。
</p>

<pre>
struct Y { } ;

struct X
{
    using pointer_type = void (*)(void) ;
    using reference_type = int (&amp;)[1] ;

    operator pointer_type () ; // 関数ポインタ―型
    operator reference_type () ; // 配列への参照型

    operator Y() ; // 他のクラス型
} ;
</pre>

<p>
型変換関数は継承される。
</p>

<pre>
struct Base
{
    operator int() { return 0 ; }
} ;

struct Derived : Base { } ;

int main()
{
    Derived d ;
    int i = d ; // Base::operator intを呼び出す
}
</pre>

<p>
型変換関数はvirtual関数にできる。
</p>

<pre>
struct Base
{
    // ピュアvirtual関数
    virtual operator int() = 0 ;
} ;

struct Derived : Base
{
    // オーバーライド
    virtual operator int() { return 0 ; }
} ;
</pre>

<p>
型変換関数はstatic関数にはできない。
</p>

<pre>
struct X
{
    static operator int() ; // エラー
} ;
</pre>
</article>

</article>

<article>
<h1 id="class.dtor"><a href="#class.dtor">デストラクター（Destructors）</a></h1>

<p>
以下のような文法の宣言を、デストラクター（destructor）という。
</p>

<pre>
関数指定子<sub>opt</sub> ~ クラス名 ( )
</pre>

<p>
デストラクターの宣言は、~（チルダ）に続いて、クラス名、空の引数リストを指定する。関数指定子には、inlineとvirtualを指定できる。クラス名の代わりに、typedef名を使用することはできない。
</p>

<pre>
struct X
{
    ~X() ; // デストラクターの宣言
} ;
</pre>

<p>
デストラクターはクラス型のオブジェクトを破棄する際に使われる。デストラクターには、仮引数や戻り値の型を指定することはできない。デストラクターのアドレスを得ることはできない。デストラクターはstaticメンバーにはなれない。デストラクターは、CV修飾、リファレンス修飾できない。ただし、デストラクターは、CV修飾されたクラス型のオブジェクトに対しても呼び出される。
</p>

<pre>
struct X
{
    ~X() { }
} ;

int main()
{
    {
        X x ;
    // オブジェクト破棄、デストラクターが呼ばれる
    }

    X * ptr = new X ;
    delete ptr ; // オブジェクト破棄、デストラクターが呼ばれる
}
</pre>

<p>
デストラクターの宣言に例外指定がない場合は、暗黙のデストラクターと同等の例外指定が、暗黙に指定される。詳しくは、<a href="#except.spec">例外指定</a>を参照。
</p>

<p class="editorial-note">
TODO:サンプルコードが必要だが、Madrid会議で変更される可能性があるので保留。
</p>

<p>
クラスにユーザー宣言されたデストラクターがない場合、デストラクターは暗黙にdefault化されて宣言される。暗黙に宣言されたデストラクターは、クラスのinline publicメンバーである。
</p>

<p>
暗黙のデストラクターは、以下のいずれかの条件を満たしたとき、delete定義される。
</p>

<section>
<p>
<a href="#variant_member">unionのようなクラス</a>で、共用メンバーが、非トリビアルデストラクターを持つ場合。
</p>


<pre>
struct Trivial { } ;
struct NonTrivial { ~NonTrivial() { } } ;

// デストラクターは暗黙にdefault化される
union A1 { Trivial member ; } ;
struct A2 { union { Trivial member ; } ; } ;

// デストラクターは暗黙にdelete定義される
union B1 { NonTrivial member ; } ;
struct B2 { union { NonTrivial member ; } ; } ;

int main()
{
// OK、暗黙のデストラクターを使う
    A1 a1 ; A2 a2 ;
// エラー、暗黙のデストラクターはdelete定義されている
    B1 b1 ; B2 b2 ;
}
</pre>

<p>
クラスの非staticデータメンバーのデストラクターがdelete定義されているか、デフォルトデストラクターからアクセス出来ない場合。
</p>

<pre>
struct deleted_destructor
{
    ~deleted_destructor() = delete ;
} ;

struct inaccessible_destructor
{
private :
    ~inaccessible_destructor() ;
    friend struct Y ; 
} ;

// クラスのデストラクターは暗黙にdelete定義される
struct X
{
    deleted_destructor m1 ; // デストラクターがdelete定義されている
    inaccessible_destructor m2 ; // デストラクターにアクセス出来ない
} ;

struct Y
{
    inaccessible_destructor m ; // friendなので、デストラクターにアクセス可能
} ;
</pre>

<p>
直接の基本クラス、もしくは、virtual基本クラスのデストラクターがdelete定義されているか、デフォルトデストラクターからアクセス出来ない場合。
</p>

<pre>
struct Base
{ 
    ~Base() = delte ;
} ;

struct D1 : Base
{
// D1のデストラクターはdelete定義される
} ;
</pre>

<p>
間接の基本クラスのデストラクターは、影響しない。
</p>

<pre>
struct Base
{ 
private :
    ~Base() { }
    friend struct D1 ;
} ;

struct D1 : Base
{
// friend宣言により、Baseのデストラクターにアクセスできる
} ;

struct D2 : D1
{
// D1のデストラクターにアクセスできる
} ;


int main()
{
    D1 d1 ; // OK
    D2 d2 ; // OK
}
</pre>

<p>
ただし、virtual基本クラスには、直接と間接の違いはないので、影響する。
</p>


<pre>
struct Base
{ 
private :
    ~Base() { }
    friend struct D1 ;
} ;

struct D1 : virtual Base
{
// friend宣言により、Baseのデストラクターにアクセスできる
} ;

struct D2 : D1
{
// virtual基本クラスのBaseのデストラクターにアクセスできない
// デストラクターは暗黙にdelete定義される
} ;


int main()
{
    D1 d1 ; // OK、暗黙のデストラクターを使う
    D2 d2 ; // エラー、デストラクターはdelete定義されている
}
</pre>

<p>
D2からD1のデストラクターにアクセスすることはできるが、D2からvirtual基本クラスであるBaseのデストラクターにアクセス出来ないため、D2のデストラクターは暗黙にdelete定義される。
</p>
</section>

<p>
デストラクターがトリビアルとなるためには、ユーザー提供もdelete定義もされておらず、以下の条件をすべて満たす必要がある。
</p>

<ul>
<li>デストラクターはvirtualではない。</li>
<li>直接の基本クラスのデストラクターは、すべてトリビアルである。</li>
<li>非staticデータメンバーのデストラクターは、すべてトリビアルである。</li>
</ul>

<p>
注意すべきこととしては、直接の基本クラスのデストラクターがトリビアルとなるためには、直接の基本クラスの直接の基本クラスのデストラクターもトリビアルでなければならない。つまり、最終的には、間接の基本クラスのデストラクターも、すべてトリビアるでなければならない。
</p>

<p>
delete定義されていない暗黙のデストラクターは、使われたときに、定義される。もしくは、明示的にdefault化されたときにも定義される。
</p>

<p>
デストラクターの呼び出しは、コンストラクター呼び出しの逆順に行われる。コンストラクター呼び出しの順番については、<a href="#class.base.init">基本クラスとデータメンバーの初期化</a>を参照。
</p>

<p>
クラスのデストラクターの本体の実行を終え、本体内の自動変数を破棄する。<a href="#variant_member">共用メンバー</a>を除くクラスの直接のメンバーに対して、デストラクターを呼び出す。クラスの直接の基本クラスのデストラクターを呼び出す。クラスが、最上位の派生クラスならば、virtual基本クラスのデストラクターを呼び出す。
</p>

<p>
配列の要素に対するデストラクターも、コンストラクターの逆順に呼ばれる。
</p>

<p>
デストラクターは、virtual関数やピュアvirtual関数にすることができる。基本クラスのデストラクターがvirtual関数である場合、派生クラスのデストラクターもvirtualになる。基本クラスのデストラクターがピュアvirtual関数の場合、派生クラスのオブジェクトを構築するためには、デストラクターを定義しなければならない。これらは、通常のvirtual関数と変わらない。
</p>

<pre>
struct Base
{
    virtual ~Base() { } // デストラクターはvirtual関数
} ;

struct Derived : Base
{
    ~Derived() { } // デストラクターはvirtual関数
} ;

struct Abstruct_base
{
    virtual ~Abstruct_base() = 0 ; // デストラクターはピュアvirtual関数
} ;
</pre>

<p>
デストラクターをvirtual関数にする目的は、オブジェクトに動的に構築、破棄する際に、型情報を管理しなくてもいいという点にある。
</p>

<pre>
#include &lt;iostream&gt;

struct B1
{
    virtual ~B1() { } // virtual関数
} ;

struct D1 : B1
{
    ~D1() { std::cout &lt;&lt; "D1 destructor" &lt;&lt; std::endl ; }
} ;

struct B2
{
    ~B2() {} // 非virtual関数
} ;

struct D2 : B2
{
    ~D2() { std::cout &lt;&lt; "D2 destructor" &lt;&lt; std::endl ; } 
} ;

int main()
{
    B1 * b1_ptr = new D1 ;
    delete b1_ptr ; // 派生クラスのデストラクターが呼ばれる

    B2 * b2_ptr = new D2 ;
    delete b2_ptr ; // 派生クラスのデストラクターが呼ばれない
}
</pre>

<p>
delete式に渡しているのは、基本クラスへのポインターである。そのため、非virtualなデストラクターでは、派生クラスのデストラクターが呼び出されない。デストラクターをvirtual関数にしておけば、このような場合にも、派生クラスのデストラクターが正しく呼び出される。
</p>

<p>
デストラクターが暗黙に呼ばれる条件は、以下の通りである。
</p>

<ul>
<li>staticストレージ上のオブジェクトに対しては、プログラムの終了時に呼ばれる。</li>
<li>threadストレージ上のオブジェクトに対しては、スレッドの終了時に呼ばれる。</li>
<li>自動ストレージ上のオブジェクトに対しては、オブジェクトを構築したブロックを抜けたときに呼ばれる。</li>
<li>一時オブジェクトに対しては、寿命が尽きたときに呼ばれる。</li>
<li>new式で構築されたオブジェクトに対しては、delete式で破棄されるときに呼ばれる</li>
<li>その他、例外として投げられたオブジェクトのキャッチに関連して呼ばれることがある</li>
</ul>

<p>
クラス型、もしくはクラスの配列型のオブジェクトが宣言された箇所で、クラスのデストラクタにアクセス出来ない場合は、エラーとなる。
</p>

<pre>
class X
{
private :
    ~X() { } // privateメンバー
} ;


int main()
{
    X x ; // エラー、デストラクターにアクセスできない。
}
</pre>

<p>
クラスがvirtualデストラクターを持つ場合、クラスには対応する解放関数が使える状態でなければならない。解放関数は、まずクラスのスコープ内で探され、見つからない場合は、グローバルスコープで探される。解放関数が見つからないか、曖昧か、delete定義されている場合、エラーとなる。これは、たとえプログラム中でdeletex式を使わなくてもエラーとなる。
</p>

<pre>
struct X
{
    virtual ~X() { } // OK、グローバルスコープのoperator deleteが発見される
} ;

struct Y
{
    virtual ~Y() { } // エラー、operator deleteはdelete定義されている。
    void operator delete( void * ptr ) = delete ;
} ;

struct B1
{
    void operator delete( void * ptr ) ;
    virtual ~B1() { }
} ;

struct B2
{
    void operator delete( void * ptr ) ;
} ;

struct Derived : B1, B2
{
// エラー、曖昧
// 暗黙のデストラクターはvirtual関数
} ;
</pre>

<p>
この規格の意図は、動的な型のオブジェクトは、常にdelete式が適用できることを保証するためである。
</p>

<p>
デストラクターは、明示的に呼び出すことができる。デストラクターを明示的に呼び出すには、メンバーアクセス演算子を使い、~に続いて、クラス型に対応する型名か、decltype指定子を使う。
</p>

<pre>
// このコードは、あくまで明示的なデストラクター呼び出しを説明するための例である
// 関数fを呼び出すと、Xのデストラクターは4回呼び出されることになり、挙動は未定義である
struct X { } ;

void f()
{
    X x ;
    x.~X() ; // デストラクターの明示的な呼び出し（型名）
    x.decltype(x)() ; // デストラクタの明示的な呼び出し（decltype指定子）
    x.X::~X() ; // 修飾名付き

    // ブロックを抜ける際に、デストラクターが暗黙に呼び出される
}
</pre>

<p>
たとえ、自動ストレージ上のオブジェクトに対してデストラクターを明示的に呼び出したとしても、ブロックを抜けた際に、デストラクターは暗黙的に呼び出される。デストラクターを呼び出した後のオブジェクトに対して、再びデストラクターを呼び出した場合、挙動は未定義なので、上記のコードの挙動も、未定義である。
</p>

<p>
一般に、自動ストレージ上のオブジェクトに対して明示的にデストラクターを呼び出した後、そのオブジェクトに対して、通常ならば暗黙にデストラクターが呼び出される状況になっている場合、挙動は未定義である。
</p>

<p>
デストラクターの明示的な呼び出しは、まず使う必要はない。デストラクターが暗黙に呼び出されることがない場合としては、placement newによる、ユーザー指定のストレージ上へのオブジェクトの構築が上げられる。
</p>

<pre>
#include &lt;new&gt;

struct X
{
    ~X() { /*実装*/ }
} ;

int main()
{
    void * ptr = ::operator new( sizeof(X) ) ; // ストレージを確保
    X * x_ptr = new(ptr) X ; // ptrの指すストレージ上にX型のオブジェクトを構築
    x_ptr-&gt;~X() ; // デストラクターの明示的な呼び出し
    ::operator delete( ptr ) ; // ストレージの解放
}
</pre>

<p>
スカラー型に対しても、デストラクターを明示的に呼び出すことができる。これによって、テンプレートのコードにおいて、型が組み込み型であるかどうかを気にしなくてすむ。
</p>

<pre>
int main()
{
    typedef int I ;
    I i ;
    i.~I() ; // OK、なにもしない
}
</pre>

<p>
デストラクターを呼び出した後のオブジェクトに対して、再びデストラクターを呼び出した場合の挙動は未定義である。
</p>

</article>

<article>
<h1 id="class.free"><a href="#class.free">フリーストア（Free store）</a></h1>

<p>
クラスに対する確保関数（operator new）と解放関数（operator delete）は、メンバー関数としてオーバーロードすることができる。確保関数と解放関数の具体的な実装方法については、<a href="#support.dynamic">動的メモリー管理</a>を参照。
</p>

<p>
クラスのメンバー関数としての確保関数、解放関数は、staticメンバー関数である。たとえstatic指定子が明示的に使われていなくても、staticメンバー関数となる。
</p>

<pre>
#include &lt;cstddef&gt;

struct X
{
    // 確保関数
    void * operator new ( std::size_t size )
    { return ::operator new( size ) ; }
    // 配列
    void * operator new[] ( std::size_t size )
    { return ::operator new( size ) ; }
    // placement form
    void * operator new ( std::size_t size, int, int, int )
    { return ::operator new( size ) ; }

    // 解放関数
    void operator delete( void * ptr )
    { ::operator delete ( ptr ) ; }
    // 配列
    void operator delete[] ( void * ptr )
    { ::operator delete ( ptr ) ; }

    // placement form
    void operator delete( void * ptr, int, int, int )
    { ::operator delete ( ptr ) ; }

} ;
</pre>

<p>
解放関数に例外指定がない場合、noexcept(true)が指定されたものとみなされる。
</p>

</article>

<article>
<h1 id="class.init"><a href="#class.init">初期化（Initialization）</a></h1>

<p>
この項目では、クラスのオブジェクトの初期化について取り扱う。特に、明示的に初期化子が指定されているオブジェクトと、クラスの基本クラスとメンバーのサブオブジェクトの初期化方法を解説する。
</p>
<p>
クラスのオブジェクトに初期化子が指定されていない場合の初期化方法は、<a href="#dcl.init">初期化子</a>を参照。
</p>

<p>
クラスオブジェクトの配列の要素を初期化する際には、コンストラクターは、添字の順番に呼ばれる。デストラクターはコンストラクターの逆順に呼ばれる。
</p>

<pre>
#include &lt;iostream&gt;

class X
{
private :
    int value ; 
public :
    X( int value ) : value(value) { std::cout &lt;&lt; value ; }
    ~X() { std::cout &lt;&lt; value ; }
} ;

int main()
{
    X a[3] = { 1, 2, 3 } ;
}
</pre>

<p>
X型の配列の要素は、a[0], a[1], a[2]の順番に構築され、a[2], a[1], a[0]の順番に破棄される。したがって、出力は、123321となる。
</p>

<article>
<h1 id="class.expl.init"><a href="#class.expl.init">明示的な初期化（Explicit initialization）</a></h1>
<p>
クラスのオブジェクトの初期化子には括弧に囲まれた式リストを使うことができる。この場合、適切な仮引数リストのコンストラクターによって初期化される。
</p>

<pre>
struct X
{
    X( int ) ;
    X( int, int ) ;
    X( int, int, int ) ;
} ;

int main()
{
    X x1( 1 ) ; // X::X(int)
    X x2( 1, 2 ) ; // X::X(int,int)
    X x3( 1, 2, 3 ) ; // X::X(int,int,int)
}
</pre>

<p>
詳しくは、<a href="#dcl.init">初期化子</a>の直接初期化を参照。
</p>

<p>
また、=（イコール）記号に続いて値を指定することで、初期化することもできる。
</p>

<pre>
struct X
{
    X( int ) ;
} ;

int main()
{
    X x = 0 ; // X::X(int)
}
</pre>

<p>
詳しくは、<a href="#dcl.init">初期化子</a>のコピー初期化を参照。
</p>

<p>
クラスのオブジェクトは、初期化リストで初期化することができる。
</p>

<pre>
struct X
{
    X( int ) { }
} ;

int main()
{
    X a[3] = { 1, 2, 3 } ;
}
</pre>

<p>
詳しくは、<a href="#dcl.init.list">リスト初期化</a>を参照。
</p>
</article>

<article>
<h1 id="class.base.init"><a href="#class.base.init">基本クラスとデータメンバーの初期化（Initializing bases and members）</a></h1>
<p>
基本クラスは、コンストラクター初期化子により初期化できる。データメンバーは、コンストラクター初期化子か、メンバーの宣言に続く初期化子によって、初期化できる。また、コンストラクターはデリゲート(Delegate)できる。
</p>

<h1>コンストラクター初期化子</h1>
<p>
クラスのコンストラクターの定義で、直接の基本クラス、virtual基本クラス、非staticデータメンバーを初期化できる。文法は、以下のようになる。
</p>

<pre>
コンストラクター初期化子:
: メンバー初期化 ...<sub>opt</sub>
: メンバー初期化子, メンバー初期化子 ...<sub>opt</sub>

メンバー初期化子:
メンバー初期化識別子 ( 式リスト ) 
メンバー初期化識別子 初期化リスト

メンバー初期化識別子:
クラス名
decltype
識別子
</pre>

<pre>
struct Base
{ 
    Base( int ) { }
} ;

struct Derived : Base
{
    int member1 ;
    int member2 ;

    Derived()-
    // コンストラクター初期化子
        : Base( 0 ), // 基本クラス
        member1( 0 ), // メンバー
        member2{ 0 } // メンバー（初期化リスト）
    { }
} ;
</pre>

<p>
非修飾のメンバー初期化識別子は、まずコンストラクターのクラスのスコープ内で名前探索され、見つからなかった場合は、基本クラスのスコープから探される。そのため、基本クラスの名前と、クラスの非staticデータメンバーの名前が衝突した場合、必ずメンバーの名前が使われる。その場合、基本クラスを指定するには、修飾名を用いなければならない。
</p>

<pre>
struct Base { } ;

struct Derived : Base
{
    int Base ;
    Derived() :
        Base(), // Derivedの非staticデータメンバー
        Derived::Base() // 基本クラス
    { }
} ;
</pre>

<p>
メンバー初期化識別子として使える名前は、直接の基本クラスと、Virtual基本クラス、コンストラクターのクラスの非staticデータメンバーである。
</p>

<pre>
struct A { } ;
struct B { } ;
struct C : B, virtual A { } ;
struct D : C
{
    D() :
        C(), // OK
        A()  // OK
        // BはDの直接の基本クラスではないので使えない
    { }
} ;
</pre>

<p>
メンバー初期化子識別子には、基本クラスの型を指し示すtypedef名やdecltype指定子を使うこともできる。
</p>

<pre>
struct A { } ;
typedef A type ;
struct B { } ;
B b ;

struct C : A
{
    C() : type(), decltype(b)()
    { }
} ;
</pre>

<p>
複数の<a href="#variant_member">共用メンバー</a>のうちの、ひとつだけを、メンバー初期化子で初期化することができる。
</p>

<pre>
union U
{
    int a ; int b ;
    U() : a(0) { } // OK、ひとつだけ
} ;

struct S
{
    union { int a ; int b ; } ;
    S() : a(0) { } // OK ひとつだけ
} ;

union Error
{
    int a ; int b ;
    Error() : a(0), b(0) // エラー、複数の指定
    { }

} ;
</pre>

<p>
同じunionのメンバーである共用メンバーは、オブジェクト上のストレージを共有しているので、複数初期化することはできない。
</p>


<p>
メンバー初期化子に、同じメンバー名、あるいは基本クラス名を、複数指定することはできない。
</p>

<p>
struct Base { } ;
struct Derived : Base
{
    int member ;
    Derived()
    : member(), member(), // エラー、同じメンバー名
      Base(), Base() // エラー、同じ基本クラス名
    { }          
} ;
</p>

<p>
コンストラクターのデリゲートについては、<a href="#deligating.constructor">コンストラクターのデリゲート</a>を参照。
</p>


<p>
メンバー初期化が明示的に指定されておらず、アブストラクトクラスのvirtual基本クラスでもない非staticデータメンバーと基本クラスは、次のように初期化される。
</p>

<p>
非staticデータメンバーに初期化子が指定されている場合、<a href="#dcl.init">初期化子</a>の方法に従って初期化される。
</p>

<pre>
struct S
{
    int member = 123 ;
    S() /*メンバー初期化子によるmemberの指定なし*/ { }
} ;
</pre>

<p>
この例では、memberは、123で初期化される。
</p>

<p>
共用メンバーの場合、初期化されない。
</p>

<pre>
union U
{
    int member ;
    U() /*メンバー初期化子による共用メンバー指定なし*/ { }
} ;

struct S
{
    union { int member ; } ;
    S() /*メンバー初期化子による共用メンバーの指定なし*/ { }
} ;

union initialize
{
    int member ;
    initialize() : m1(0) { } // m1を0で初期化
} ;
</pre>

<p>
共用メンバーには、明示的な初期化が必要である。
</p>

<p>
それ以外の場合、<a href="#dcl.init.default-initialize">デフォルト初期化</a>される。
</p>

<pre>
struct X { X() { } } ;

struct S
{
    int m1 ; 
    X m2 ;
    S() { }
} ;
</pre>

<p>
この例では、int型の非staticデータメンバーm1の初期化処理は<a href="#dcl.init.default-initialize">デフォルト初期化</a>で定義されているように、何もしない。X型m2は、X型のデフォルトコンストラクターによって初期化される。
</p>

<p>
同じunionに属する非staticな共用メンバーは、ひとつしか初期化できない。
</p>

<pre>
union U
{
    int m1 ; int m2 ;
    U() : m1(0), m2(0) { } // エラー
} ;

struct X
{
    union { int m1 ; int m2 ; } ;
    X() : m1(0), m2(0) { } // エラー
} ;

struct Y
{
    union { int m1 ; } ;
    union { int m2 ; } ;
    Y() : m1(0), m2(0) { } // OK、違うunionの共用メンバー
} ;
</pre>

<p>
Yの例は、違うunionの共用メンバーなので、問題のないコードである。
</p>

<p>
クラスのコンストラクターの実行が終了した時点で、初期化も明示的な値の設定もされていないメンバーの値は、不定である。
</p>

<pre>
struct X
{
    int member ;
    X() { }
} ;

X x1 ; // staticストレージ上に構築されたオブジェクトは、ゼロ初期化されるので、x1.memberの値は0

int main()
{
    X x2 ; // x2.memberの値は不定
}
</pre>

<p>
非staticデータメンバーの宣言に初期化子があり、メンバー初期化子も指定されている場合、メンバー初期化子が優先される。この場合、メンバー宣言の初期化子は無視される。
</p>

<pre>
struct X
{
    int member = 1;
    X() { } // memberは1で初期化される
    X( int arg ) : member( arg ) { } // memberはargで初期化される
} ;


int main()
{
    X x1 ; // x1.memberの値は1
    X x2(2) ; // x2.memberの値は2
}
</pre>

<p>
デリゲートしていないコンストラクターにおける初期化は、以下のように行われる。
</p>

<p>
まず始めに、クラスが最も派生した型である場合、virtual基本クラスが初期化される。
</p>

<pre>
struct V { } ;

struct B : virtual V { } ;
struct C : B { } ;
struct D : C { } ;

int main()
{
    D d ; // DのコンストラクターでVが初期化される
    C c ; // CのコンストラクターでVが初期化される。
    B b ; // BのコンストラクターでVが初期化される。
}
</pre>

<p>
virtual基本クラスは、最も派生したクラスで初期化されるということには、注意が必要である。例えば、以下のような場合、
</p>

<pre>
struct V
{
    int member ;
    V( int arg ) : member( arg )  { }
} ;

struct B : virtual V
{
    B() : V(1) { }
} ;
struct C : B { } ;

int main()
{
    C c ; // エラー、Vのデフォルトコンストラクターは暗黙にdelete定義されている。
}
</pre>

<p>
VはCで初期化されるので、Bによる初期化は、無視されてしまう。Cのメンバー初期化子には、Vは記述されていないので、Vはデフォルト初期化される。Vのデフォルトコンストラクターは暗黙にdelete定義されているので、エラーとなる。
</p>

<p>
複数のvirtual基本クラスを持つ場合、初期化の順番は、深度優先（depth-ﬁrst）かつ、左から右（left-to-right）となる。「深度」とは、基本クラスに行くほど深くなる。「左から右」とは、基本クラス指定子リストに現れるvirtual基本クラスの順番である。
</p>

<pre>
struct V1 { } ; struct V2 { } ; struct V3 { } ;

struct B : virtual V1, virtual V2 { } ;
struct C : B, virtual V3 { } ;

C c ; // V1, V2, V3の順番で初期化される
</pre>

<p class="editorial-note">
TODO: directed acyclic graphを表現する図
</p>

<p>
virtual基本クラスの初期化が終わった後で、直接の基本クラスが、基本クラス指定子リストに現れる順番で初期化される。メンバー初期化子は、初期化の順番に影響しない。
</p>

<pre>
struct B1 { } ; struct B2 { } ;
struct D : B1, B2
{
    D() : B2(), B1() { }
} ;

D d ; // B1, B2の順番に初期化される
</pre>

<p>
メンバー初期化子は、初期化の順番に何の影響も与えないことに注意しなければならない。これは、副作用が初期化に影響をあたえるような場合、問題になる。
</p>

<pre>
int i ;

struct B1 { B1(int) { } } ;
struct B2 { B2(int) { } } ;

struct D1 : B1, B2
{
    D1() : B2(++i), B1(++i) { }
} ;

struct D2 : B2, B1
{
    D2() : B2(++i), B1(++i) { }
} ;

int main()
{
    i = 0 ;
    D1 d1 ; // B1(1)、B2(2)で初期化される
    D2 d2 ; // B2(1)、B1(2)で初期化される
}
</pre>

<p>
メンバー初期化子の順番は、基本クラスの初期化順序に影響しない。そのため、ある基本クラスの初期化における副作用が、次の基本クラスの初期化に影響をあたえるようなコードでは、基本クラスの記述の順番を変えるだけで、初期化の結果が異なってしまう。一般に、直接の基本クラスの初期化の順番が保証されていることを前提にしたコードを書くべきではない。
</p>

<p>
直接の基本クラスの初期化が終わった後で、クラス定義内の非staticデータメンバーが、宣言されている順番で初期化される。メンバー初期化子は、初期化の順番に影響しない。
</p>

<pre>
struct X
{
    int m1 ;
    int m2 ;
    X() : m2(0), m1(0) { }
} ;

X x ; // m1, m2の順番で初期化される
</pre>

<p>
直接の基本クラスの場合と同じく、メンバー初期化子は初期化の順番に影響しないということに注意しなければならない。非staticデータメンバーの初期化の順番は、クラス定義の中でメンバーが宣言されている順番である。したがって、あるメンバーの初期化の副作用が、次のメンバーの初期化に影響をあたえるようなコードでは、メンバーの宣言の順番を変えただけで、初期化処理が異なってしまう。具体的な問題例は、直接の基本クラスの場合と同じである。一般に、非staticデータメンバーの初期化の順番が保証されていることを前提にしたコードを書くべきではない。
</p>

<p>
最後に、コンストラクターの本体が実行される。
</p>

<pre>
struct V { } ;
struct B { } ;
struct M { } ;

struct D : B, virtual V
{
    M m ;
    D() { /* コンストラクターの本体*/ }
} ;

D d ; // V, B, m, コンストラクターの本体の順番で初期化される
</pre>

<p>
メンバー初期化子における名前は、コンストラクターの本体で評価される。
</p>

<pre>
int  ;

struct X
{
    int x ;
    int y ;
    X() : x(0), y(x) { }
} ;
</pre>

<p>
メンバー初期化子では、thisを使うことができる。ただし、thisの参照先はまだ構築途中である場合もあるので、注意が必要である。
</p>


<p>
非staticメンバー関数は、virtual関数を含めて、構築中のオブジェクトであっても呼び出すことができる。また、構築途中のオブジェクトを、<a href="#expr.typeid">typeid演算子</a>や<a href="#expr.dynamic.cast">Dynamic cast（Dynamic cast）</a>のオペランドに渡すこともできる。
</p>

<p>
ただし、コンストラクター初期化子において、まだすべての基本クラスの初期化が終わっていない時点で、この種の操作を行った場合、結果は未定義である。これは、間接的に操作が行われる場合も含む。
</p>

<pre>
struct A { A(int) { } } ;
struct B : A
{
    int f() { return 0 ; }
    B() : A( f() ) // 結果は未定義
    { }
} ;

// 間接的に操作が行われる例
struct C : A
{
    static int call_f( C * ptr ) { return ptr->f() ; }
    int f() { return 0 ; }
    C() : A( call_f( this ) ) // 未定義
    { }
} ;
</pre>

<p>
構築中のオブジェクトに対してvirtual関数を呼び出したり、typeidやdynamic_castを使った場合の挙動は、<a href="#class.cdtor">生成と破棄</a>を参照。
</p>

<p>
メンバー初期化子では、パック展開できる。
</p>

<pre>
template &lt; typename Bases &gt;
struct X : Bases...
{
    X() : Bases()...
    { }
} ;
</pre>

<article>
<h1 id="deligating.constructor"><a href="#deligating.constructor">コンストラクターのデリゲート</a></h1>

<p>
メンバー初期化識別子に、クラス型を指定することによって、別のコンストラクターに初期化処理をデリゲートすることができる。これを、コンストラクターのデリゲート(delegate)という
</p>

<pre>
struct X
{
    int member ;

    X( int value ) : member( value )
    { /* 初期化処理 */ }

    X( double d ) : X(123) // コンストラクターのデリゲート
    {
        // 追加の処理
    }
} ;
</pre>

<p>
この例では、コンストラクターX::X(double)は、初期化処理をX::X(int)にデリゲートしている。
</p>

<p>
別のコンストラクターにデリゲートしているコンストラクターのことを、デリゲートコンストラクター(delegating constructor)といい、デリゲート先のコンストラクターのことを、ターゲットコンストラクター(target constructor)という。またオブジェクトの初期化のために最初に呼び出されたコンストラクターのことを、最初のコンストラクター(principal constructor)という。
</p>

<pre>
struct X
{
    X() : X( 0 ) { }
    X( int ) : X( 0.0 ) { }
    X( double ) { }
} ;

X x ; // 初期化
</pre>

<p>
上に例における、Xのオブジェクトxの初期化では、最初のコンストラクターとして、X::X()が選ばれる。これは、デリゲートコンストラクターであり、ターゲットコンストラクターであるX::X(int)にデリゲートする。X::X(int)もデリゲートコンストラクターであり、ターゲットコンストラクターのX::X(double)にデリゲートする。
</p>

<p>
デリゲートコンストラクターは、他のメンバー初期化識別子を指定してはならない。
</p>

<pre>
struct Base { } ;

struct X : Base
{
    int member ;
    X() : X( 0 ),
        Base(), member(0) // エラー、デリゲートコンストラクターは他の識別子を指定できない
    { }
    X( int ) { }
} ;
</pre>

<p>
ターゲットコンストラクターは、オーバーロード解決により選ばれる。
</p>

<pre>
struct X
{
    X() : X( 0 ) { } // X::X(int)を呼ぶ
    X( int ) : X( 0.0 ) { } // X::X(double)を呼ぶ
    X( double ) { }
} ;
</pre>

<p>
ターゲットコンストラクターが処理を返した後に、デリゲートコンストラクターの本体が実行される。
</p>

<pre>
struct X
{
    int member ;
    X() : X( 0 )
    { /* 処理2 */ }
    X( int value ) : member( value )
    { /* 処理1 */ }
} ;

X x ;
</pre>

<p>
この例では、オブジェクトxの初期化の際、最初のコンストラクターとしてX::X()が選ばれる。これはデリゲートコンストラクターである。ターゲットコンストラクターは、X::X(int)となる。ターゲットコンストラクターは、通常のコンストラクターと同じように基本クラスやメンバーの初期化を終えた後、コンストラクターの本体を実行し（処理1）、処理を返す。ターゲットコンストラクターが処理を返したので、最初のコンストラクターの本体が実行される（処理2）。
</p>

<p>
デリゲートコンストラクターが、直接的にせよ、間接的にせよ、自分自身にデリゲートを行った場合は、エラーとなる。
</p>

<pre>
struct X
{
    X() : X() {} // エラー、直接的な自分自身へのデリゲート
} ;

struct Y
{
    Y() : Y(0) { } // エラー、間接的な自分自身へのデリゲート
    Y(int) : Y(0.0) { } // エラー、間接的な自分自身へのデリゲート
    Y(double) : Y() { } // エラー、間接的な自分自身へのデリゲート
} ;
</pre>

<p>
クラスYは、間接的に、自分自身へのデリゲートを行う例である。デリゲートのネスト、つまり他のデリゲートコンストラクターへのデリゲートは可能である。ただし、間接的であっても、自分自身へのデリゲートは認められない。
</p>

</article>


</article>

</article>

<article>
<h1 id="class.cdtor"><a href="#class.cdtor">生成と破棄（Construction and destruction）</a></h1>

<p>
クラスのオブジェクトが構築される前、破棄された後、あるいは構築や破棄の最中には、いくつか気を付けなければならないことがある。
</p>

<p>
非トリビアルコンストラクターを持つクラスのオブジェクトのコンストラクターの実行が始まる前に、非staticメンバーや基本クラスにアクセスした場合、挙動は未定義である。
</p>

<pre>
struct X
{
    X() { } // 非トリビアルコンストラクター
    int member ;
} ;


int main()
{
    X * ptr = static_cast&lt;X *&gt;( operator new( sizeof(X) ) )  ; // 初期化されていないストレージ
    ptr-&gt;member ; // 未定義
    &amp;ptr->member ; // 未定義、ポインターを得ることもできない
    new(ptr) X ; // 初期化
    ptr-&gt;member ; // OK
    &amp;ptr->member ; // OK
    operator delete( ptr ) ;
}
</pre>

<p>
非トリビアルデストラクターを持つクラスのオブジェクトのデストラクターの実行が終わった後に、非staticメンバーや基本クラスにアクセスした場合、挙動は未定義である。
</p>

<pre>
struct X
{
    ~X() { } // 非トリビアルデストラクター
    int member ;
} ;


int main()
{
    X * ptr = static_cast&lt;X *&gt;( operator new( sizeof(X) ) )  ; // 初期化されていないストレージ
    new(ptr) X ; // 初期化
    ptr-&gt;~X() ; // デストラクターの実行

    ptr-&gt;member ; // 未定義
    operator delete( ptr ) ;
}
</pre>

<p>
クラスへのポインターを、基本クラスへのポインターに型変換する際には、クラスとそのすべての基本クラスのコンストラクターの実行が始まっていなければならない。また、デストラクターの実行が完了していてはならない。そうでない場合の挙動は未定義である。これは、トリビアルクラスにも当てはまる。
</p>

<pre>
struct X { } ;
struct Y : X { } ;

int main()
{
    Y * y_ptr = static_cast&lt;Y *&gt;( operator new( sizeof(Y) ) )  ; // 初期化されていないストレージ

    X * x_ptr = y_ptr ; // 未定義
    new (y_ptr) Y ; // 初期化
    x_ptr = y_ptr ; // OK
    y_ptr-&gt;~Y() ; // デストラクターの実行
    x_ptr = y_ptr ; // 未定義

    operator delete( y_ptr ) ;
}
</pre>

<p>
オブジェクトの構築や破棄の途中で、メンバー関数を呼び出すことはできる。ただし、virtual関数をコンストラクターやデストラクターの中で呼び出す際には、注意が必要である。virtual関数をコンストラクターやデストラクターの中、あるいはその中から呼び出された関数内で呼び出すと、そのコンストラクターあるいはデストラクターのクラスの型にとってのファイナルオーバーライダーが用いられ、派生クラスは考慮されない。これは、基本クラスのコンストラクターの実行中には、派生クラスはまだ完全に初期化されていないからである。
</p>

<pre>
struct A
{
    virtual void f() { }
    virtual void g() { }
    // A::f、A::gを呼び出す
    A() { f() ; g() ;  }
    virtual ~A() { f() ; g() ; }
} ;

struct B : A
{
    virtual void f () { }
    // B::f, A::gを呼び出す
    B() { f() ; g() ; }
    virtual ~B() { f() ; g() ; }
} ;

struct C : B
{
    virtual void g() { }
    // B::f, C::gを呼び出す
    C() { f() ; g() ; }
    virtual ~C() { f() ; g() ; }
} ;
</pre>

<p>
この例で、たとえクラスCのオブジェクトを構築したとしても、基本クラスAのコンストラクターの中ではA::f, A::gが呼ばれることになる。
</p>

<p>
オブジェクトの構築や破棄の途中で、typeid演算子を使うことはできる。typeid演算子がコンストラクターやデストラクターの中、あるいはその中から呼び出された関数内で使われていて、typeid演算子のオペランドが、そのクラスの構築中のオブジェクトである場合、typeidはコンストラクターやデストラクターのクラス型情報を表すstd::type_infoオブジェクトを返す。これは、基本クラスの構築中は、まだ派生クラスは構築し終わっていないからである。
</p>

<pre>
struct A
{
    A()
    {
        typeid( *this ) == typeid( A ) ; // true
    }
    virtual ~A()
    {
        typeid( *this ) == typeid( A ) ; // true
    } 
} ;

struct B : A { } ;
</pre>

<p>
この例では、たとえBのオブジェクトが構築されたとしても、typeidはA型を表すstd::type_infoオブジェクトを返す。
</p>

<p>
オブジェクトの構築や破棄の途中で、dynamic_castを使うことはできる。dynamic_castがコンストラクターやデストラクターの中、あるいはその中から呼び出された関数内で使われていて、オペランドがそのクラスの構築中のオブジェクトである場合、コンストラクターやデストラクターの属するクラスが、最終的に派生された型であるとみなされる。これは、基本クラスの構築中は、まだ派生クラスは構築し終わっていないからである。
</p>

<pre>
struct A
{
    A() ;
    virtual ~A() ;
} ;

struct B : A { } ;

A::A()
{
    B * ptr = dynamic_cast&lt;B *&gt;( this ) ; // 常にnullポインター
}

A::~A()
{
    B * ptr = dynamic_cast&lt;B *&gt;( this ) ; // 常にnullポインター
}
</pre>

<p>
たとえ、Aから派生されたB型のオブジェクトであっても、Aのコンストラクター、デストラクターの中では、A型が最終的な派生クラスであるとみなされる。
</p>

</article>

<article>
<h1 id="class.copy"><a href="#class.copy">クラスのコピーとムーブ</a></h1>


<p class="editorial-note">
TODO: プログラミング上のコピーとムーブの解説へのリンク。
</p>

<p>
ここでは、クラスのコピーとムーブを行うための特別なコンストラクターと代入演算子の宣言について説明している。コピーとムーブのプログラミング上の意味については、[TODO]を参照。
</p>

<p>
クラスのオブジェクトは、初期化と代入によって、コピーもしくはムーブされる。コピーやムーブを行うためのコンストラクターと代入演算子を、それぞれ特別に、コピーコンストラクター、ムーブコンストラクター、コピー代入演算子、ムーブ代入演算子と呼ぶ。
</p>



<p>
コピーコンストラクター（copy constructor）とは、あるクラスXにおいて、非テンプレートなコンストラクターで、一つ目の仮引数の型が、X &amp;、const X &amp;、volatile X &amp;、const volatile X &amp;のいずれかであり、二つ目以降の仮引数は存在しないか、すべてデフォルト実引数があるものをいう。
</p>

<pre>
struct X
{
    // コピーコンストラクター
    X( X &amp; ) ;
    X( X const &amp; ) ;
    X( X volatile &amp; ) ;
    X( X const volatile &amp; ) ; 
    X( X const &amp;, int x = 0, int y = 0 ) ; // 二つ目以降の仮引数にデフォルト実引数がある

    // コピーコンストラクターではない
    X( ) ;
    X( int ) ;
    template &lt; typename T &gt;
    X( T ) ; // テンプレートコンストラクターはコピーコンストラクターではない
    X( X const &amp;, short ) ; // 二つ目以降の仮引数にデフォルト実引数がない
} ;
</pre>

<p>
ムーブコンストラクター（move constructor）とは、あるクラスXにおいて、非テンプレートなコンストラクターで、一つ目の仮引数の型が、X &amp;&amp;、const X &amp;&amp;、volatile X &amp;&amp;、const volatile X &amp;&amp;のいずれかであり、二つ目以降の仮引数は存在しないか、すべてデフォルト実引数があるものをいう。
</p>

<pre>
struct X
{
    X( X &amp;&amp; ) ;
    X( X const &amp;&amp; ) ;
    X( X volatile &amp;&amp; ) ;
    X( X const volatile &amp;&amp; ) ;
    X( X const &amp;&amp;, int x = 0 ) ;
} ;
</pre>

<p>
クラスXのコンストラクターの一つ目の仮引数の型がXで、二つ目以降の仮引数が存在しないか、すべてデフォルト実引数が指定されている場合は、エラーとなる。
</p>

<pre>
struct X
{
    X( X ) ; // エラー
} ;
</pre>

<p>
また、テンプレートコンストラクターのインスタンス化の結果が、このようなシグネチャになる場合、そのテンプレートはインスタンス化されない。
</p>

<pre>
struct X
{
    template &lt; typename T &gt;
    X( T ) { } // X&lt;X&gt;というインスタンス化は起こらない。
} ;

int main()
{
    X a( 0 ) ; // テンプレートコンストラクターが使われる。
    X b( a ) ; // 暗黙のコピーコンストラクターが使われる
}
</pre>

<p>
あるクラスにおいて、コピーコンストラクターが明示的に宣言されていない場合、コピーコンストラクターは暗黙的に宣言される。もし、クラスにユーザー定義のムーブコンストラクター、ムーブ代入演算子、コピー代入演算子、デストラクターが存在する場合、コピーコンストラクターは暗黙的にdelete定義される。そうでない場合は、default定義される。
</p>

<pre>
struct A
{
    // コピーコンストラクターは暗黙的にdefault定義される
    // A( A const &amp; ) = default ;
} ;

struct B
{
    B( B &amp;&amp; ) ; // ユーザー定義ムーブコンストラクター
    B &amp; operator = ( B &amp;&amp; ) ; // ユーザー定義ムーブ代入演算子
    B &amp; operator = ( B &amp; ) ; // ユーザー定義コピー代入演算子
    ~B() ; // ユーザー定義デストラクター

    // コピーコンストラクターは暗黙的にdelete定義される
    // B( B const &amp; ) = delete ;
} ;
</pre>

<p>
クラスXの暗黙のコピーコンストラクターのシグネチャは、通常、
</p>

<pre>
X::X( const X &amp; )
</pre>

<p>
となる。ただし、直接の基本クラスやvirtual基本クラス、非staticデータメンバーがconst修飾されていない仮引数のコンストラクターを持つ場合、
</p>

<pre>
X::X( X &amp; )
</pre>

<p>
となる。
</p>

<pre>
struct A
{
    A() = default ;
    A( A const &amp; ) { }
} ;

struct B : A
{
// 暗黙のコピーコンストラクターのシグネチャ
// B( B const &amp; ) = default ;
} ;

struct C
{
    C() = default ;
    C( C &amp; ) { }
} ;

struct D : C
{
// 暗黙のコピーコンストラクターのシグネチャ
// D( D &amp; ) = default ;
} ;
</pre>

<p>
あるクラスにおいて、ムーブコンストラクターが明示的に宣言されていない場合、ムーブコンストラクターは暗黙的に宣言される。もし、あるクラスがユーザー定義の、コピーコンストラクター、コピー代入演算子、ムーブ代入演算子、デストラクターを持たず、またムーブコンストラクターがdelete定義されていない場合、ムーブコンストラクターはdefault定義される。
</p>

<p>
ユーザー定義のムーブ代入演算子が存在する場合、ムーブコンストラクターは暗黙的にdefault定義されない。これは、デフォルトのムーブコンストラクターの挙動と、ユーザー定義のムーブ代入演算子の挙動が異なる可能性があるため、安全のためにdefault定義されないのである。
</p>

<pre>
struct X
{
    // ムーブコンストラクターはdefault定義されない

    // ユーザー定義のムーブ代入演算子
    X &amp; operator = ( X &amp;&amp; obj )
    {
        // ユーザー定義のムーブを実装
    }
} ;
</pre>

<p>
そのため、自前実装のムーブ構築とムーブ代入を行いたい場合、ムーブコンストラクターとムーブ代入演算子を両方ユーザー定義する必要がある。
</p>

<p>
ムーブコンストラクターが、暗黙にも明示的にも宣言されていない場合、ムーブコンストラクターを呼び出す式は、代わりにコピーコンストラクターを呼び出す。
</p>

<pre>
struct X
{
    X() = default ;
    // ユーザー定義のコピーコンストラクター
    X( X const &amp; ) { }
    // ムーブコンストラクターは宣言されない
} ;


int main()
{
    X a ;
    // コピーコンストラクターを呼び出す
    X b( static_cast&lt; X &amp;&amp; &gt;( a ) ) ;
}
</pre>

<p>
クラスXの暗黙のムーブコンストラクターのシグネチャは、以下の通りである。
</p>

<pre>
X::X( X &amp;&amp; )
</pre>

<p>
あるクラスが以下の条件を満たした時、コピー/ムーブコンストラクターはdelete定義される。
</p>


<ul>
<li>
<p>
クラスがunionのようなクラスで、共用メンバーがそれぞれ非トリビアルなコピー/ムーブコンストラクターを持つ場合、対応するコンストラクターがdelete定義される。
</p>

<pre>
struct NonTrivial
{
    NonTrivial( NonTrivial const &amp; ) { }
    NonTrivial( NonTrivial &amp;&amp; ) { }
} ;

struct X
{ 
    X() { }
    union { NonTrivial n ; } ;
    // コピーコンストラクターは、nが非トリビアルなコピーコンストラクターを持つためにdelete定義される
    // ムーブコンストラクターは、nが非トリビアルなムーブコンストラクターを持つためにdelete定義される。
} ;

</pre>

</li>

<li>
<p>

</p>
</li>



</ul>

<p class="editorial-note">
TODO:あとで書く
</p>
</article>

<article>
<h1 id="class.inhctor"><a href="#class.inhctor">コンストラクター継承（Inheriting constructors）</a></h1>

<p>
using宣言を使って派生クラスから基本クラスのコンストラクターを指定することで、基本クラスのコンストラクターを明示的に継承できる。これにより、機械的な手書きのコードを省くことができる。
</p>

<pre>
class Base
{
private :
    int member ;
public :
    Base( int value ) : member(value) { }
} ;

class Derived : Base
{
public :
    // Base::Base(int)を継承
    using Base::Base ;
} ;

int main()
{
    Derived d(0) ; // 継承コンストラクターを使う
}
</pre>


<p>
using宣言は通常通り、アクセス指定の影響を受けることに注意すること。派生クラスによって継承された基本クラスのコンストラクターは、同じ仮引数をとり、引数をそのままメンバー初期化子で基本クラスに渡し、関数本体は空であるコードを手書きした場合と同じように動く。
</p>

<pre>
struct Base { Base(int, double) { } } ;
struct Derived : Base
{
    // Baseクラスのコンストラクターの継承
    using Base::Base ;
    // 以下のコードを手書きした場合と同等
    // Derived( int p1, double p2 )
    // : Base( p1, p2 )
    // { }
} ;
</pre>

<p>
このような手書きのコンストラクターを、実際に使うとエラーとなる場合、継承コンストラクターの使用もエラーとなる。
</p>

<p>
派生クラスで同じシグネチャーのコンストラクターをユーザー定義した場合、そのコンストラクターの継承は起こらない。
</p>

<pre>
struct Base
{
    Base( int ) { }
    Base( double ) { }
} ;
struct Derived : Base
{
    using Base::Base ;

    Derived( int value ) : Base(value)
    {
        // 処理
    }
}
</pre>

<p>
この場合、Base::Base(double)は継承されるが、Base::Base(int)は継承されない。クラスDerivedでユーザー定義されたコンストラクターが使用される。
</p>

<p>
継承コンストラクターの詳細はすこし難しい。まず、継承される基本クラスのコンストラクターが、継承コンストラクターの候補(candidate set of inherited constructors)として列挙される。この際、コンストラクターにデフォルト実引数がある場合は、デフォルト実引数を省略したシグネチャーの関数も追加される。たとえば、以下のようなクラスの場合、
</p>

<pre>
struct A
{
    A( int i ) { }
} ;

struct B
{
    A( int p1 = 1, int p2 = 2 ) { }
} ;
</pre>

<p>
クラスAの継承コンストラクターの候補は、以下の通り。
</p>

<pre>
A( int )
A( A const &amp; )
A( A &amp;&amp; )
</pre>

<p>
クラスBの継承コンストラクターの候補は、以下の通り。
</p>

<pre>
B( ) // デフォルト実引数の省略形
B( int = 1 ) // デフォルト実引数の省略形
B( int = 1, int = 2 )
B( B const &amp; )
B( B &amp;&amp; )
</pre>

<p>
さて、この継承コンストラクターの候補から、引数を取らないコンストラクター（デフォルトコンストラクター）、引数をひとつだけ取るコピー/ムーブコンストラクターを除くコンストラクターが継承コンストラクターとなる。これらのコンストラクターは、派生クラス側で暗黙に宣言されるものだからだ。ただし、派生クラスで同じシグネチャーのコンストラクターがユーザー定義されている場合は、継承されない。
</p>

<p>
いくつか例を示す。
</p>

<pre>
struct Base
{
    Base( int ) { }
} ;

struct Derived : Base
{
    using Base::Base ;
} ;
</pre>

<p>
この場合、クラスDerivedのコンストラクターは、以下のようになる。
</p>

<pre>
Derived( ) // 継承コンストラクターではない。使うとエラーになる
Derived( int ) // クラスBから継承されたコンストラクター
Derived( Derived const &amp; ) // 継承コンストラクターではない
Derived( Derived &amp;&amp; ) // 継承コンストラクターではない
</pre>

<p>
デフォルトコンストラクターやコピー/ムーブコンストラクターは継承されないので、通常通りの挙動になる。この場合、クラスBaseのデフォルトコンストラクターは暗黙に宣言されていないし、ユーザー定義もされていないため、使うとエラーになる。
</p>

<pre>
struct A
{
    A( int ) { }
} ;

struct B
{
    B( int ) { }
} ;

struct C : A, B
{
    using A::A ;
    using B::B ;
// エラー、宣言の重複
} ;

struct D : A, B
{
    using A::A ;
    using B::B ;
    D( int x ) : A(x), B(x) { } // OK、ユーザー定義を優先
}
</pre>

<p>
クラスCでは、C(int)を重複して宣言してしまうので、エラーとなる。クラスDでは、ユーザー定義があるために、コンストラクターの継承は起こらない。もっとも、この場合、using宣言を使ってコンストラクターを継承する意味がない。
</p>






</article>

</article>

<article>
<h1 id="over"><a href="#over">オーバーロード(Overloading)</a></h1>

<p>
関数と関数テンプレートは、異なる宣言であれば、同一スコープ内でも、同じ名前を使うことができる。これを、オーバーロード(overload)という。オーバーロードされた名前が関数呼び出しで使われた場合、オーバーロード解決(overload resolution)が行われ、最も最適な宣言が選ばれる。
</p>

<pre>
void name( int ) ;
void name( double ) ;

int main()
{
    name( 0 ) ; // name(int)
    name( 0.0 ) ; // name(double)
}
</pre>

<p>
これにより、引数が違うだけで本質的には同じ関数群に、それぞれ別名を付けなくてもよくなる。
</p>

<article>
<h1 id="over.load"><a href="#over.load">オーバーロード可能な宣言(Overloadable declarations)</a></h1>

<p>
シグネチャが異なっていれば、どのような関数、あるいは関数テンプレートでもオーバーロードできるわけではない。以下は、オーバーロードでは考慮されないシグネチャ上の違いである。
</p>

<ul>
<li>
<p>戻り値の型</p>

<pre>
int f( int ) { return 0 ; }
double f( int ) { return 0.0 ; } // エラー、オーバーロードできない
</pre>
</li>

<li>
<p>メンバー関数とメンバー関数テンプレートにおいて、staticと非staticの違い</p>

<pre>
struct Foo
{
    void f() ;
    static void f() ; // エラー
} ;
</pre>
</li>

<li>
<p>
メンバー関数とメンバー関数テンプレートにおいて、リファレンス修飾子の有無が混在している場合
</p>

<p>
メンバー関数の暗黙のオブジェクト仮引数のリファレンスによるオーバーロードを行いたい場合は、lvalueリファレンスでも、リファレンス修飾子を省略することはできない。
</p>

<pre>
struct Foo
{
    void f() ; // リファレンス修飾子の省略、暗黙にlvalueリファレンス
    void f() &amp;&amp; // エラー、他の宣言でリファレンス修飾子が省略されている

    void g() &amp; ; // OK
    void g() &amp;&amp; ; // OK

} ;
</pre>
</li>

<li>
<p>仮引数の型が、同じ型を指す異なるtypedef名の場合</p>

<pre>
using Int = int ;

void f( int ) ;
void f( Int ) ; // 再宣言
</pre>

<p>
typedef名は単なる別名であって、異なる型ではないので、シグネチャはおなじになる。
</p>

</li>

<li>
<p>
仮引数の型の違いが、*か[]である場合
</p>

<p>
<a href="#dcl.fct">関数の型</a>で説明したように、仮引数のポインターと配列のシグネチャは同じである。ただし、2つ目以降の配列は考慮されるので注意。
</p>

<pre>
void f( int * ) ;
void f( int [] ) ; // 再宣言、void f(int *)と同じ
void f( int [2] ) ; // 再宣言、void f(int *)と同じ

void f( int [][2] ) ; // オーバーロード、シグネチャはvoid f(int(*)[2])
</pre>
</li>

<li>
<p>
仮引数が関数型か、同じ関数型へのポインターである場合
</p>

<p>
<a href="#dcl.fct">関数の型</a>で説明したように、仮引数としての関数型は同じ関数型へのポインター型に変換される。
</p>

<pre>
void f( void(*)() ) ;
void f( void () ) ; // 再宣言
void f( void g() ) ; // 再宣言
</pre>

<p>
これらはオーバーロードではない。
</p>

</li>

<li>
<p>
仮引数のトップレベルのCV修飾子の有無
</p>

<p>
<a href="#dcl.fct">関数の型</a>で説明したように、仮引数のトップレベルのCV修飾子は無視される。トップレベル以外のCV修飾子は別の型とみなされるので、オーバーロードとなる。
</p>

<pre>
void f( int * ) ;
void f( int * const ) ; // 再宣言
void f( int * volatile ) ; // 再宣言
void f( int * const volatile ) ; // 再宣言

void f( int const * ) ; // オーバーロード
void f( int volatile * ) ; // オーバーロード
void f( int const volatile * ) ; // オーバーロード
</pre>

</li>

<p>
デフォルト実引数の違い
</p>

<p>
デフォルト実引数の違いは、オーバーロードとはみなされない。
</p>

<pre>
void f( int, int ) ;
void f( int, int = 0 ) ; // 再宣言
void f( int = 0, int ) ; // 再宣言
</pre>

</ul>

</article>


<article>
<h1 id="over.dcl"><a href="#over.dcl">オーバーロードのその他の注意事項</a></h1>

<p>
オーバーロード解決は、名前解決によって複数の宣言が列挙される場合に行われる。内側のスコープによって名前が隠されている場合は、オーバーロード解決は行われない。
</p>

<p>
たとえば、派生クラスで基本クラスのメンバー関数名と同名のものがある場合、そのメンバー関数は基本クラスのメンバー関数の名前を隠す。
</p>

<pre>
struct Base
{
   void f( int ) { }
} ;

struct Derived : Base
{
    void f( double ) { } // Base::f(int)を隠す
} ;


int main()
{
    Derived d ;
    d.f( 0 ) ; // Derived::f(double)が呼ばれる
}
</pre>

<p>
似たような例に、関数のローカル宣言がある。
</p>

<pre>
void f( int ) { }
void f( double ) { }

int main()
{
    f( 0 ) ; // f(int)を呼び出す
    void f( double ) ; // f(int)を隠す
    f( 0 ) ; // f(double)を呼び出す
}
</pre>

<p>
オーバーロードされたメンバー関数は、それぞれ別々のアクセス指定を持つことができる。アクセス指定は名前解決には影響しないので、オーバーロード解決は行われる。
</p>

<pre>
class X
{
private :
    void f( int ) { }
public :
    void f( double ) { }

} ;

int main()
{
    X x ;
    x.f( 0 ) ; // エラー、X::f(int)はprivateメンバー
}
</pre>

<p>
この例では、オーバーロード解決によって、X::f(int)が選ばれるが、これはprivateメンバーなので、Xのfriendではないmain関数からは呼び出せない。よってエラーになる。
</p>

</article>

<article>
<h1 id="over.match"><a href="#over.match">オーバーロード解決(Overload resolution)</a></h1>

<p>
オーバーロードされた関数を呼び出す際に、実引数から判断して、最もふさわしい関数が選ばれる。これを、オーバーロード解決(Overload resolution)と呼ぶ。オーバーロード解決のルールは非常に複雑である。単純に実引数と仮引数の型が一致するだけならまだ話は簡単だ。
</p>

<pre>
void f( int ) { }
void f( double ) { }

int main()
{
    f( 0 ) ; // f(int)が呼ばれる
    f( 0.0 ) ; // f(double)が呼ばれる
}
</pre>

<p>
この結果には、疑問はない。実引数と仮引数の型が一致しているからだ。しかし、もし、実引数の型と仮引数の型が一致していないが、暗黙の型変換によって仮引数の型に変換可能な場合、問題は非常にややこしくなる。
</p>

<pre>
void f( int ) { }
void f( double ) { }

int main()
{
    short a = 0 ;
    f( a ) ; // f(int)を呼ぶ

    float b = 0.0f ;
    f( b ) ; // f(double)を呼ぶ
}
</pre>

<p>
この結果も、妥当なものである。shortは整数型なので、doubleよりはintを優先して欲しい。floatは、浮動小数点数型なので、doubleを優先して欲しい。
</p>

<p>
では、以下のような場合はどうだろうか。
</p>

<pre>
void f( int ) { }
void f( long long ) { }
int main()
{
    long a = 0l ;
    f( a ) ; // 曖昧

    short b = 0 ;
    f( b ) ; // f(int)を呼び出す
}
</pre>

<p>
この結果は、少し意外だ。比べるべき型は、intとlong long intである。long型を渡すと曖昧になる。しかし、short型を渡すと、なんとint型が選ばれる。こちらは曖昧にならない。これは、short型からint型への型変換に<a href="#conv.prom">整数のプロモーション</a>が使われているためである。
</p>


<p>
では、ユーザー定義の型変換が関係する場合はどうだろうか。
</p>

<pre>
void f( int ) { }

class X
{
public :
    X() = default ;
    X( double ) { } // ユーザー定義の型変換
} ;

void f( X ) { }

int main()
{
    f( 0.0 ) ; // f(int)を呼ぶ
}
</pre>

<p>
この場合、ユーザー定義の型変換より、言語側に組み込まれた、標準型変換を優先している。
</p>

<p>
では、引数が複数ある場合はどうなるのか。関数テンプレートの場合はどうなるのか。疑問は尽きない。オーバーロード解決のルールは非常に複雑である。これは、できるだけオーバーロード解決の挙動を、人間にとって自然にし、詳細を知らなくても問題がないように設計した結果である。その代償として、オーバーロード解決の詳細は非常に複雑になり、実装にも手間がかかるようになった。
</p>

<p>
オーバーロード解決の手順を、簡潔にまとめると、以下のようになる。
</p>

<ol>
<li>名前探索によって見つかる同名の関数をすべて、候補関数(Candidate functions)として列挙する</li>
<li>候補関数から、実際に呼び出すことが可能な関数を、適切関数(Viable functions)に絞る</li>
<li>実引数から仮引数への暗黙の型変換を考慮して、最適な関数(Best viable function)を決定する</li>
</ol>

<p>
例えば、以下のようなオーバーロード解決の場合、
</p>

<pre>
void f() { }
void f( int ) { }
void f( int, int ) { }
void f( double ) { }

void g( int ) { }

int main()
{
    f( 0 ) ; // オーバーロード解決が必要
}
</pre>

<p>
候補関数には、f(), f(int), f(int,int), f(double)が列挙される。適切関数には、f(int), f(double)が選ばれる。これを比較すると、f(int)が型一致で最適関数となる。
</p>

<p>
本書におけるオーバーロード解決の解説は、細部をかなり省略している。
</p>

<article>
<h1><a href="over.match.funcs">候補関数(Candidate functions)</a></h1>

<p>
候補関数(Candidate functions)は、正確に言えば、候補関数群とでも訳されるべきであろう。候補関数とは、その名前の通り、オーバーロード解決の際に呼び出しの優先順位を考慮される関数のことである。候補関数に選ばれなければ、呼び出されることはない。ある名前に対してオーバーロード解決が必要な場合に、まず最初に行われるのが、候補関数の列挙である。候補関数は、通常通りに名前探索をおこなって見つけた関数すべてである。これには、実際には呼び出すことのできない関数も含む。オーバーロード解決の際に考慮するのは、この候補関数だけである。その他の関数は考慮しない。
</p>

<pre>

void f() { }
void f( int ) { }
void g() { }

int main()
{
    f( 0 ) ; // 候補関数の列挙が必要
}
</pre>

<p>
ここでの候補関数とは、f()とf(int)である。f()は、実際に呼び出すことができないが、候補関数として列挙される。この場合、g()は候補関数ではない。
</p>

<p>
オーバーロード解決の際に使われる名前探索は、通常の名前探索と何ら変わりないということに注意しなければならない。例えば、名前が隠されている場合は、発見されない。
</p>

<pre>
void f( int ) { }
void f( double ) { }

int main()
{
    f( 0 ) ; // #1 f(int)
    void f( double ) ; // 再宣言、f(int)を隠す
    f( 0 ) ; // #2 f(double)
}
</pre>

<p>
#1では、f(int)が名前探索で見つかるので、オーバーロード解決によって、f(int)が最適関数に選ばれる。#2では、f(int)は隠されているので、名前探索では見つからない。そのため、f(int)は候補関数にはならない。結果として、f(double)が最適関数に選ばれる。
</p>

<p>
関数のローカル宣言はまず使われないが、派生クラスのメンバー関数の宣言によって、基本クラスのメンバー関数が隠されることはよくある。
</p>

<pre>
struct Base
{
    void f( int ) { }
    void f( long ) { }
} ;

struct Derived : Base
{
    void f( double ) { } // Baseクラスの名前fを隠す
    void g()
    {
        f( 0 ) ; // Derived::f(double)
    }
} ;
</pre>

<p>
この例では、Derived::f(double)が、Baseのメンバー関数fを隠してしまうので、候補関数にはDerived::f(double)しか列挙されない。
</p>



<p>
候補関数がメンバー関数である場合、コード上には現れない仮引数として、クラスのオブジェクトを取る。これを、暗黙のオブジェクト仮引数(implicit object parameter)と呼ぶ。これは、オーバーロード解決の際に考慮される。暗黙のオブジェクト仮引数は、オーバーロード解決においては、関数の第一引数だとみなされる。暗黙のオブジェクト仮引数の型は、まず、クラスの型XにCV修飾子がつき、さらに、
</p>


<p>
リファレンス修飾子がない場合、あるいは、リファレンス修飾子が&amp;の場合、X（場合によってCV修飾子）へのlvalueリファレンス。
</p>

<pre>
struct X
{
    // コメントは暗黙のオブジェクト仮引数の型
    void f() &amp; // X &amp;
    void f() const &amp; // X const &amp;
    void f() volatile &amp; // X volatile &amp;
    void f() const volatile &amp; // X const volatile &amp;

    viod g() ; // X &amp;
} ;
</pre>

<p>
リファレンス修飾子が&amp;&amp;の場合、X(場合によってCV修飾子)へのrvalueリファレンス。
</p>

<pre>
struct X
{
    // コメントは暗黙のオブジェクト仮引数の型
    void f() &amp;&amp; // X &amp;&amp;
    void f() const &amp;&amp; // X const &amp;&amp;
    void f() volatile &amp;&amp; // X volatile &amp;&amp;
    void f() const volatile &amp;&amp; // X const volatile &amp;&amp;
} ;
</pre>

<p>
となる。例えば、以下のようにオーバーロード解決に影響する。
</p>

<pre>
struct X
{
    void f() &amp; ; // #1 暗黙のオブジェクト仮引数の型は、X &amp;
    void f() const &amp; ; // #2 暗黙のオブジェクト仮引数の型は、X const &amp;
    void f() &amp;&amp; ; // #3 暗黙のオブジェクト仮引数の型は、X &amp;&amp;
} ;

int main()
{
    X x ;
    x.f() ; // #1
    X const cx ;
    cx.f() ; // #2
    static_cast&lt;X &amp;&amp;&gt;(x).f() ; // #3
} 
</pre>

<p>

</p>


<p>
候補関数には、メンバー関数と非メンバー関数の両方を含むことがある。
</p>

<pre>
struct X
{
    X operator + ( int ) const
    { return X() ; }
} ;

X operator + ( X const &amp;, double )
{ return X() ; }

int main()
{
    X x ;
    x + 0 ; // X::operator+(int)
    x + 0.0 ; // operator+(X const &amp;, double)
}
</pre>

<p>
この場合、候補関数には、メンバー関数であるX::operator +と、非メンバー関数であるoperator+の両方が含まれる。候補関数に列挙されるので、当然、オーバーロード解決で最適関数が決定される。
</p>

<p>
テンプレートの実引数推定は、名前解決の際に行われる。そのため、候補関数として関数テンプレートのインスタンスが列挙された時点で、テンプレート実引数は決定されている。
</p>

<p>
オーバーロード解決が行われる文脈には、いくつか種類がある。それによって、候補関数の選び方も違ってくる。
</p>


<article>
<h1 id="over.match.call"><a href="#over.match.call">関数呼び出しの文法(Function call syntax)</a></h1>

<p>
最も分かりやすい関数呼び出しは、関数呼び出しの文法によるものだろう。しかし、一口に関数呼び出しの文法といっても、微妙に違いがある。単なる関数名に対する関数呼び出し式の適用もあれば、暮らすのオブジェクトに.や-&gt;を使った式に対する関数呼び出し、つまりメンバー関数の呼び出しや、クラスのオブジェクトに対する関数呼び出し式、つまりoperator ()のオーバーロードを呼び出すものがある。
</p>

<pre>
struct X
{
    void f( int ) { }
    void f( double ) { }

    void operator () ( int ) { }
    void operator () ( double ) { }
} ;

int main()
{
    X x ;
    x.f( 0 ) ; // オーバーロード解決が必要
    x( 0 ) ; // オーバーロード解決が必要
}
</pre>

<p>
オーバーロード解決は、関数へのポインターやリファレンスを経由した間接的な呼び出しの際には、行われない。
</p>

<pre>
void f( int ) { }
void f( double ) { }

int main()
{
    void (* p)( int ) = &amp;f ;
    p( 0.0 ) ; // f(int)
}
</pre>
</article>

<article>
<h1 id="over.match.oper"><a href="#over.match.oper">式中の演算子(Operators in expressions)</a></h1>

<p>
この項は、オーバーロードされた演算子を候補関数として見つける際の詳細である。演算子のオーバーロードの宣言方法については、<a href="#over.oper">オーバーロードされた演算子</a>を参照。
</p>

<p>
演算子を使った場合にも、オーバーロード解決が必要になる。ただし、演算子にオーバーロード解決が行われる場合、オペランドにクラスやenumが関わっていなければならない。オペランドが基本型だけであれば、組み込みの演算子が使われる。
</p>

<pre>
// エラー、オペランドがすべて基本型
int operator + (int, int) { return 0 ; }
</pre>

<p>
演算子のオーバーロードは、メンバー関数としてオーバーロードする方法と、非メンバー関数としてオーバーロードする方法がある。すでに述べたように、候補関数には、どちらも列挙される。
</p>

<p>
演算子のオーバーロード関数は、演算子を仮に@と置くと、以下の表のように呼ばれる。
</p>

<table>
<thead>
<tr>
<th>種類</th>
<th>式</th>
<th>メンバー関数として呼び出す場合</th>
<th>非メンバー関数として呼び出す場合</th>
</tr>
</thead>

<tbody>
<tr>
<td>単項前置</td>
<td>@a</td>
<td>(a).operator@ ( )</td>
<td>operator@ (a)</td>
</tr>

<tr>
<td>単項後置</td>
<td>a@</td>
<td>(a).operator@ (0)</td>
<td>operator@ (a, 0)</td>
</tr>

<tr>
<td>二項</td>
<td>a@b</td>
<td>(a).operator@ (b)</td>
<td>operator@ (a, b)</td>
</tr>

<tr>
<td>代入</td>
<td>a=b</td>
<td>(a).operator= (b)</td>
</tr>

<tr>
<td>添字</td>
<td>a[b]</td>
<td>(a).operator[](b)</td>
</tr>

<tr>
<td>クラスメンバーアクセス</td>
<td>a-&gt;</td>
<td>(a).operator-&gt; ( )</td>
</tr>

</tbody>
</table>

<p>
代入、添字、クラスメンバーアクセスの演算子は、メンバー関数として宣言しなければならないので、非メンバー関数は存在しない。
</p>


</article>

<article>
<h1 id="over.match.ctor"><a href="#over.match.ctor">コンストラクターによる初期化(Initialization by constructor)</a></h1>

<p>
クラスのオブジェクトの直接初期化の場合、そのクラスからコンストラクターが候補関数として列挙され、オーバーロード解決が行われる。
</p>

<pre>
struct X
{
    X( int ) { }
    X( double ) { }
} ;

int main()
{
    X a( 0 ) ; // オーバーロード解決が行われる
    X b( 0.0 ) ; // オーバーロード解決が行われる
}
</pre>

</article>

<article>
<h1 id="over.match.copy"><a href="#over.match.copy">ユーザー定義型変換によるクラスのコピー初期化(Copy-initialization of class by user-defined conversion)</a></h1>

<p>
クラスのコピー初期化におけるユーザー定義型変換には、オーバーロード解決が行われる。ユーザー定義型変換には、変換コンストラクターと変換関数がある。これは、両方とも、候補関数として列挙される。
</p>

<pre>

struct Destination ;
extern Destination obj ;

struct Source
{
    operator Destination &amp;() { return obj ; }
} ;


struct Destination
{
    Destination() { }
    Destination( Source const &amp; ) { }
} ;

Destination obj ;


int main()
{
    Source s ;
    Destination d ;
    d = s ; // オーバーロード解決、Source::operator Destination &amp;()
    Source cs ;
    d = cs ; // オーバーロード解決、Destination::Destination( Source const &amp; ) 
}
</pre>

<p>
この例では、変換コンストラクターと変換関数の両方が候補関数として列挙される。この例で、もし変換コンストラクターの仮引数が、Source &amp;ならば、オーバーロード解決は曖昧になる。
</p>

<p>
ただし、explicit変換コンストラクターとexplicit変換関数は、直接初期化か、明示的なキャストが使われた際にしか候補関数にならない。
</p>

<pre>
struct X
{
    X() { }
    explicit X( int ) { }
    explicit operator int() { return 0 ; }
    
} ;

int main()
{
    X x ;
    int a( x ) ; // OK
    int b = x ; // エラー

    X c( 0 ) ; // OK
    X d = 0 ; // エラー
}
</pre>

<p>
この場合の実引数リストには、初期化式が使われる。変換コンストラクターの場合は、第一仮引数と比較され、変換関数の場合は、クラスの隠しオブジェクト仮引数と比較される。
</p>


<pre>
// 変換コンストラクターの例
struct A { } ;

struct X
{
    // 候補関数
    X( A &amp; ) { }
    X( A const &amp; ) { }
} ;

int main()
{
    A a ;
    X x1 = a ; // オーバーロード解決、A::A(A&amp;)
    A const ca ;
    X x2 = ca ; // オーバーロード解決、A::A(A const &amp;)
}
</pre>

<p>
この例では、実引数としてaやcaが使われ、クラスXの変換コンストラクターの第一仮引数と比較される。
</p>

<pre>
// 変換関数の例
struct A { } ;

struct X
{
    // 候補関数
    operator A() &amp; { return A() ; }
    operator A() const &amp; { return A() ; }
    operator A() &amp;&amp; { return A() ; }

} ;

int main()
{   
    X x ;
// オーバーロード解決、X::operator A() &amp;
// 実引数はlvalueのX、
    A a1 = x ; 
    X const cx ;
// オーバーロード解決、X::operator A() const &amp;
// 実引数はconstなlvalue
    A a2 = cx ; 
// オーバーロード解決、X::operator A() &amp;&amp;
// 実引数はxvalue
    A a3 = static_cast&lt;X &amp;&amp;&gt;(x) ; 
}
</pre>

<p>
この例では、クラスXのオブジェクトが実引数として、変換関数のクラスの隠しオブジェクト仮引数として比較される。たとえば、A a1 = x ; の場合、実引数は非constなlvalueなので、オーバーロード解決により、X::operator A() &amp;が選ばれる。
</p>

<p>
その他の変換コンストラクターと変換関数に対しても、オーバーロード解決で比較する実引数と仮引数はこれに同じ。
</p>

</article>

<article>
<h1 id="over.match.conv"><a href="#over.match.conv">変換関数によるクラスではないオブジェクトの初期化(Initialization by conversion function)</a></h1>

<p>
クラスではないオブジェクトを、クラスのオブジェクトの初期化式で初期化する際、クラスの変換関数が候補関数として列挙され、オーバーロード解決が行われる。実引数リストには、初期化式がひとつの実引数として渡される
</p>

<pre>
struct X
{
    operator int() { return 0 ; }
    operator long() { return 0L ; }
    operator double() { return 0.0 ; }
} ;

int main()
{
    X x ;
    int i = x ; // オーバーロード解決が行われる
}
</pre>

<p>
この例では、候補関数に、X::operator int、X::operator long、X::operator doubleが列挙され、オーバーロード解決によってX::operator intが選ばれる。
</p>
</article>

<article>
<h1 id="over.match.ref"><a href="#over.match.ref">変換関数によるリファレンスの初期化(Initialization by conversion function for direct reference binding)</a></h1>

<p>
リファレンスを初期化するとき、初期化式に変換関数を適用して、その結果を束縛できる。このとき、クラスの変換関数が候補関数として列挙され、オーバーロード解決が行われる。
</p>

<pre>

struct X
{
    operator int() { return 0 ; }
    operator short() { return 0 ; }
} ;

int main()
{   
    X x ;
    int &amp;&amp; ref = x ; // オーバーロード解決、X::operator int()
}
</pre>

</article>

<article>
<h1 id="over.match.list"><a href="#over.match.list">リスト初期化による初期化(Initialization by list-initialization)</a></h1>

<p>
<a href="#dcl.init.aggr">アグリゲート</a>ではないクラスがリスト初期化によって初期化されるとき、オーバーロード解決によってコンストラクターが選択される。
</p>

<p>
この際の候補関数の列挙は、二段階に分かれている。
</p>

<p>
まず一段階に、クラスの初期化リストコンストラクターが候補関数として列挙され、オーバーロード解決が行われる。実引数リストには、初期化リストが唯一の実引数として、std::initializer_list&lt;T&gt;の形で、与えられる
</p>

<pre>
struct X
{
    // 初期化リストコンストラクター
    X( std::initializer_list&lt;int&gt; ) { }
    X( std::initializer_list&lt;double&gt; ) { }

    // その他のコンストラクター
    X( int, int, int ) { }
    X( double, double, double ) { }
} ;

int main()
{   
    X a = { 1, 2, 3 } ; // オーバーロード解決、X::X( std::initializer_list&lt;int&gt; )
    X b = { 1.0, 2.0, 3.0 } ; // オーバーロード解決、X::X( std::initializer_list&lt;double&gt; )
}
</pre>

<p>
この場合、候補関数には、初期化リストコンストラクターしか列挙されない。
</p>

<p>
もし、一段階目の名前解決で、<a href="#over.match.viable">適切</a>な初期化リストコンストラクターが見つからなかった場合、二段階の候補関数として、再びオーバーロード解決が行われる。今度は、クラスのすべてのコンストラクターが候補関数として列挙される。実引数は、初期化リストの中の要素が、それぞれ別の実引数として渡される
</p>

<pre>
struct X
{
    // 適切な初期化リストコンストラクターなし

    X( int, int, int ) { }
    X( double, double, double ) { }
    X( int, double, int ) { }
} ;

int main()
{   
    X a = { 1, 2, 3 } ; // オーバーロード解決、X::X( int, int, int )
    X b = { 1.0, 2.0, 3.0 } ; // オーバーロード解決、X::X( double, double, double )
    X c = { 1, 2.0, 3 } ; // オーバーロード解決、X::X( int, double, int )
}
</pre>

<p>
「適切」という用語に注意すること。もし、<a href="#dcl.init.list">縮小変換</a>が必要となれば、適切関数かどうかを判定する前にエラーとなる。
</p>

<pre>
struct X
{
    X( std::initializer_list&lt;int&gt; ) { }
    X( double, double, double ) { }
} ;

int main()
{   
    X b = { 1.0, 2.0, 3.0 } ; // エラー、縮小変換が必要
}
</pre>

<p>
デフォルトコンストラクターを持つクラスに空の初期化リストが渡された場合、一段階目のオーバーロード解決は行われず、デフォルトコンストラクターが呼ばれる。
</p>

<pre>


</pre>
struct X
{
    X ( ) { }
    template &lt; typename T &gt;
    X( std::initializer_list&lt;T&gt; ) { }
} ;

int main()
{   
    X x = { } ; // デフォルトコンストラクターが呼ばれる
}
</article>

<p>
コピーリスト初期化では、explicitコンストラクターが選ばれた場合、エラーとなる。
</p>

<pre>
struct X
{
    explicit X( int ) { }
} ;

int main()
{   
    X a = { 0 } ; // エラー、コピーリスト初期化でexplicitコンストラクター
    X b{ 0 } ; // OK、直接初期化
}
</pre>


</article>


</article>

<article>
<h1 id="over.match.viable"><a href="#over.match.viable">適切関数(Viable functions)</a></h1>


<p>
候補関数は、単に名前探索の結果であり、実際には呼び出すことができない関数も含まれている。このため、候補関数を列挙した後、呼び出すことが出来る関数、すなわち適切関数(Viable functions)を列挙する。
</p>

<p>
適切関数とは、与えられた実引数で、実際に呼び出すことが出来る関数である。これには、大きく二つの要素がある。仮引数の数と型である。
</p>

<p>
適切関数となるためにはまず、与えられた実引数の個数に対して、仮引数の個数が対応していなければならない。そのための条件は、以下のいずれかを満たしていればよい。
</p>

<ul>
<li>
<p>
実引数の個数と、候補関数の仮引数の個数が一致する関数
</p>

<p>
これは簡単だ。実引数と同じ個数だけの仮引数があればよい。可変長テンプレートのインスタンス化による関数もこのうちに入る。
</p>

<pre>
void f( int, int ) { }

int main()
{
    f( 0, 0 ) ; // OK
    f( 0 ) ; // エラー
}
</pre>

</li>

<li>
<p>
候補関数の仮引数の個数が、実引数の個数より少ないが、仮引数リストにエリプシス(...)がある場合。
</p>

<p>
これは、C言語でお馴染みの...のことだ。可変長テンプレートは、このうちには入らない。
</p>

<pre>
void f( int, ... ) ;

int main()
{   
    f( 0 ) ; // 適切関数
    f( 0, 1 ) ; // 適切関数
    f( 0, 1, 2, 3, 4, 5 ) ; // 適切関数
}
</pre>

</li>

<li>
<p>
候補関数の仮引数の個数は、実引数より多いが、実引数より多い仮引数にはすべて、デフォルト実引数が指定されていること。
</p>

<pre>
void f( int, int = 0, int = 0, int = 0, int = 0, int = 0 ) ;

int main()
{   
    f( 0 ) ; // 関数
    f( 0, 1 ) ; // 適切関数
    f( 0, 1, 2, 3, 4, 5 ) ; // 適切関数
}
</pre>
</li>
</ul>

<p>
さらに、対応する実引数から仮引数に対して、後述する暗黙の型変換により、妥当な変換が存在しなければならない。
</p>

<pre>
void f( int ) { }

int main()
{
    f( 0 ) ; // OK、完全一致
    f( 0L ) ; // OK、整数変換
    f( 0.0 ) ; // OK、整数と浮動小数点数間の変換
    f( &amp;f ) ; // エラー
}
</pre>

<p>
適切関数であるからといって、実際に呼び出せるとは限らない。たとえば、宣言されているが未定義であったり、アクセス指定による制限を受けたり、あるいはその他実装依存の理由など、現実には呼び出すことができない理由は多数存在する。
</p>

</article>

<article>
<h1 id="over.match.best"><a href="#over.match.best">最適関数(Best viable function)</a></h1>
<p>
適切関数が複数ある場合、定められた方法で関数を比較することによって、ひとつの最も適切(best viable)な関数を選択する。この関数を最適関数と呼ぶ。オーバーロード解決の結果は、この最適関数となる。もし、最も適切な関数をひとつに決定できない場合、オーバーロード解決は曖昧であり、エラーとなる。
</p>

<p>
最適関数の決定は、主に、後述する暗黙の型変換の優先順位によって決定される。
</p>

<p>
まず大前提として、ある関数が、別の関数よりも、より適切であると判断されるには、ある関数のすべて仮引数に対する実引数からの暗黙の型変換の優先順位が劣っておらず、かつ、ひとつ以上の優れている型変換が存在しなければならない。
</p>

<pre>
void f( int, double ) { } // #1
void f( long, int ) { } // #2

int main()
{   
    f( 0 , 0 ) ; // エラー、オーバーロード解決が曖昧
}
</pre>

<p>
この例では、どの関数も、仮引数への型変換の優先順位が、他の関数より劣っている。したがってオーバーロード解決は曖昧となる。一見すると、#2の方が、どちらも整数型であるので、よりよい候補なのではないかと思うかもしれない。しかし、#1の第一仮引数の型はintなので、longよりも優れている。一方、第二引数では、#2の方が優れている。このため、曖昧となる。最適関数となるためには、全ての仮引数の型が、他の候補より劣っていてはならないのだ。
</p>

<p>
ユーザー定義型変換による初期化の場合、ユーザー定義型変換の結果の型から、目的の型へ、標準型変換により変換する際、より優先順位の高いものが選ばれる。
</p>

<pre>
struct X
{
    operator int() ;
    operator double() ;

} ;

void f()
{   
    X x ;
    int i = x ; // operator intが最適関数
    float f = x ; // エラー、曖昧
}
</pre>

<p>
一見すると、doubleからfloatへの変換は、intからの変換より優先順位が高いのではないかと思うかもしれないが、後述する標準型変換の優先順位のルールにより、同じ優先順位なので、曖昧となる。
</p>

<p>
非テンプレート関数と関数テンプレートの特殊化では、非テンプレート関数の特殊化が優先される。
</p>

<pre>
template &lt; typename T &gt;
void f( T ) ;
void f( int ) ;

int main()
{   
    f( 0 ) ; // 非テンプレート関数を優先
}
</pre>

<p>
もちろん、これは大前提の、すべての仮引数に対し劣った型変換がないということが成り立つ上での話である。
</p>

<pre>
template &lt; typename T &gt;
void f( T ) ;
void f( long ) ;

int main()
{   
    f( 0 ) ; // 関数テンプレートの特殊化f&lt;int&gt;を優先
}
</pre>

<p>
この場合は、テンプレートの特殊化である仮引数int型の方が、実引数int型に対して、より優れた型変換なので、優先される。
</p>

<p>
テンプレートの実引数推定のルールは複雑なので、一見して、非テンプレート関数が優先されると思われるコードで、関数テンプレートの実体化の方が優先される場合がある。
</p>

<pre>
// #1
// 非テンプレート関数
void f( int const &amp; ) ;


// #2
// 関数テンプレート
template &lt; typename T &gt;
void f( T &amp;&amp; ) ; 

int main()
{
    int x = 0 ; // xは非constなlvalue
    f( x ) ; // #2を呼ぶ
}
</pre>

<p>
これは、#2の実体化の結果が、f&lt;int &amp;&gt;( int &amp; )になるからだ。xは非constなlvalueであるので、非constなlvalueリファレンス型の仮引数と取る#2の方が優先される。
</p>

<p>
ふたつの関数が両方ともテンプレートの特殊化の場合、<a href="#temp.func.order">半順序</a>によって、より特殊化されていると判断される方が、優先される。
</p>

<pre>
template &lt; typename T &gt; void f( T ) ; // #1
template &lt; typename T &gt; void f( T * ) ; // #2

int main()
{   
    int * ptr = nullptr ;
    f( ptr ) ; // 半順序により#2を優先
}
</pre>

<p>
#1と#2の特殊化による仮引数の型は、どちらも int *であるが、#2のテンプレートの特殊化の方が、半順序のルールによって、より特殊化されているとみなされるため、#2が優先される。
</p>

<article>
<h1 id="over.best.ics"><a href="#over.best.ics">暗黙の型変換の順序(Implicit conversion sequences)</a></h1>

<p>
暗黙の型変換には、いくつかの種類と、多数の例外ルールがあり、それぞれ優先順位を比較することができる。残念ながら、この詳細は非常に冗長であり、本書では概略の説明に留める。
</p>

<p>
まず、暗黙の型変換には、大別して三種類ある。<a href="#conv">標準型変換</a>、<a href="#class.conv">ユーザー定義型変換</a>、エリプシス変換である。優先順位もこの並びである。標準型変換が一番優先され、次にユーザー定義型変換、最後にエリプシス変換となる。
</p>

<pre>
struct X { X(int) ; } ;

void f( int ) ; // #1 
void f( X ) ; // #2

void g( X ) ; // #3
void g( ... ) ; // #4


int main()
{
    f( 0 ) ; // #1、標準型変換がユーザー定義型変換に優先される
    g( 0 ) ; // #3、ユーザー定義型変換がエリプシス変換に優先される
}
</pre>

<p>
さらに、標準型変換とユーザー定義変換同士の間での優先順位がある。
</p>

<p>
エリプシスに基本型以外を渡して呼び出した場合の挙動は未定義だが、オーバーロード解決には影響しない。
</p>

<article>
<h1 id="over.ics.scs"><a href="#over.ics.scs">標準型変換（Standard conversion sequences）</a></h1>

<p>
オーバーロード解決における標準型変換の間の優先順位は、非常に複雑で、単に、ランクA＞ランクBのような単純な比較ができない。ここでは、とくに問題になりそうな部分のみ取り上げる。
</p>

<p>
まず、型変換の必要のない、完全一致が最も優先される。
</p>

<pre>
void f( int ) ;
void f( double ) ;

int main()
{
    f( 0 ) ; // f(int)
    f( 0.0 ) ; // f(double)
}
</pre>

<p>
この完全一致には、<a href="#conv.lval">lvalueからrvalueへの型変換</a>、<a href="#conv.array">配列からポインターへの型変換</a>、<a href="#conv.func">関数からポインターへの型変換</a>が含まれる。
</p>

<p>
void f( int ) ;

int main()
{
    int x = 0 ;
    f( x ) ; // lvalueからrvalueへの変換
}
</p>

<p>
配列や関数からポインターへの変換は、完全一致とみなされることに注意。
</p>

<pre>
void g( ) ;

void f( void (*)() ) ; // ポインター
void f( void (&amp;)() ) ; // リファレンス

int main()
{
    f( g ) ; // エラー、オーバーロード解決が曖昧、候補関数はすべて完全一致
    f( &amp;g ) ; // OK、f( void (*)() )
}
</pre>

<p>
完全一致は、ポインターやリファレンスに<a href="#conv.qual">CV修飾子を付け加える型変換</a>より優先される。
</p>

<pre>
void f( int &amp; ) ; // #1
void f( int const &amp; ) ; // #2

int main()
{
    int x = 0 ;
    f( x ) ; // #1、完全一致
}
</pre>

<p>
整数と浮動小数点数のプロモーションは、その他の整数と浮動小数点数への変換より優先される。
</p>

<pre>
void f( int ) ;
void f( long ) ;

int main()
{
    short x = 0 ;
    f( x ) ; // f(int)、プロモーション
}
</pre>

</article>




</article>

</article>

<article>
<h1 id="over.over"><a href="#over.over">オーバーロード関数のアドレス(Address of overloaded function)</a></h1>

<p>
ある関数の名前に対して、複数の候補関数がある場合でも、名前から関数のアドレスを取得できる。どの候補関数を選ぶかは、文脈が期待する型の完全一致で決定される。初期化や代入、関数呼び出しの実引数や明示的なキャストの他に、関数の戻り値も、文脈により決定される。
</p>

<pre>
void f( int ) ;
void f( long ) ;

void g( void (*)(int) ) ;

void h()
{
    // 初期化
    void (*p)(int) = &amp;f ; // void f(int)のアドレス
    // 代入
    p = &amp;f ; // void f(int)のアドレス
    // 関数呼び出しの実引数
    g( &amp;f ) ;
    // 明示的なキャスト
    static_cast&lt;void (*)(int)&gt;(&amp;f) ; // void f(int)のアドレス
}

// 関数の戻り値
auto i() -&gt; void (*)(int)
{
    return &amp;f ; // void f(int)のアドレス
}
</pre>

<p>
これらの文脈では、ある具体的な完全一致の型を期待しているので、オーバーロードされた関数名から、適切な関数を決定できる。
</p>

<p>
完全一致の型ではない場合や、型を決定できない場合はエラーである。
</p>

<pre>
void f( int ) ;
void f( long ) ;

template &lt; typename T &gt;
void g( T ) { }

int main()
{
    g( &amp;f ) ; // エラー
}
</pre>

</article>

<article>
<h1 id="over.oper"><a href="#over.oper">オーバーロード演算子(Overloaded operators)</a></h1>

<p>
特別な識別子を使っている関数宣言は、演算子関数(operator function)として認識される。この識別子は以下のようになる。
</p>

<pre>
operator <i>演算子</i>
</pre>

<p>
オーバーロード可能な演算子は以下の通りである。
</p>

<pre>
new     delete  new[]   delete[]
+   -   *   /   %   ˆ   &amp;   |   ~
!   =   &lt;   &gt;   +=  -=  *=  /=  %=
ˆ=  &amp;=  |=  &lt;&lt;  &gt;&gt;  &gt;&gt;= &lt;&lt;= ==  !=
&lt;=  &gt;=  &amp;&amp;  ||  ++  --  ,   -&gt;* -&gt;
( ) [ ]
</pre>

<p>
以下の演算子は、単項、二項の両方でオーバーロードできる。
</p>
<pre>
+   -   *   &amp;
</pre>

<p>
以下の演算子は、関数呼び出しと添え字である。
</p>

<pre>
( ) [ ]
</pre>

<p>
以下の演算子は、オーバーロードできない。
</p>

<pre>
.   .*  ::  ?:
</pre>

<p class="todo">
allocation functionとdeallocation functionへのリンク
</p>

<p>
演算子関数は、非staticメンバー関数か、非メンバー関数でなければならない。非staticメンバー関数の場合、暗黙のオブジェクト仮引数が、第一オペランドになる。これが*thisである。
非メンバー関数の場合、仮引数のひとつは、クラスか、クラスへのリファレンス、enumかenumへのリファレンスでなければならない。
</p>

<pre>
struct X
{
    // 非staticメンバー関数による演算子関数
    X operator +() const ; // 暗黙のオブジェクト仮引数 X const &amp;
    X operator +( int ) const ; // 暗黙のオブジェクト仮引数 X const &amp;
} ;

// 非メンバー関数による演算子関数
X operator -( X const &amp; ) ;
X operator -( X const &amp;, int ) ;
X operator -( int, X const &amp; ) ;
</pre>

<p>
以下の例はエラーである。
</p>

<pre>
// エラー、組み込みの演算子をオーバーロードできない
int operator +( int, int ) ; 

struct X { } ;
// エラー、組み込みの演算子をオーバーロードできない
X operator + ( X * ) ; 
</pre>

<p>
ただし、代入演算子や添字演算子のように、非staticメンバー関数として実装しなければならない例外的な演算子もある。
</p>

<p>
演算子関数は、必ず元の演算子と同じ数の仮引数を取らなければならない。
</p>

<pre>
struct X　{　} ;

X operator / ( X &amp; ) ; // エラー、仮引数が少ない
X operator / ( X &amp;, X &amp;, X &amp; ) ; // エラー、仮引数が多い
</pre>

<p>
ただし、これも関数呼び出し演算子のように、例外的な演算子がある。
</p>

<p>
演算子関数は、組み込みの演算子と同じ挙動を守らなくてもよい。例えば、戻り値の型は自由であるし、オーバーロードされた演算子関数が、基本型にその単項演算子を適用した場合に期待される挙動をしなくてもかまわない。例えば、オーバーロードした演算子関数では、"++a"、と、"a += 1"というふたつの式を評価した際の挙動や結果が同じにならなくてもよい。また、組み込み演算子ならば非constなlvalueを渡す演算子で、constなlvalueやrvalueを受け取っても構わない
</p>

<pre>
struct X　{　} ;

void operator + ( X &amp; ) ; // OK、戻り値の型は自由
void operator ++ ( X const &amp; ) ; // OK、constなlvalueリファレンスでもよい
</pre>

<p>
演算子関数は、通常通り演算子を使うことによって呼び出すことができる。その際、演算子の優先順位は、組み込みの演算子と変わらない。また、識別子を指定することによって、通常の関数呼び出し式の文法で、明示的に呼び出すこともできる。
</p>

<pre>
struct X
{
    X operator +( X const &amp; ) const ;
    X operator *( X const &amp; ) const ;
} ;

int main()
{
    X a ; X b ; X c ;
    a + b ; // 演算子を使うことによる呼び出し
    a + b * c ; // 優先順位は、(a + (b * c))

    a.operator +(b) ; // 明示的な関数呼び出し
}
</pre>

<p>
代入演算子=や、単項演算子の&amp;や、カンマ演算子は、オーバーロードしなくてもすべての型に対してあらかじめ定義された挙動がある。この挙動はオーバーロードして変えることもできる。
</p>

<article>
<h1 id="over.unary"><a href="#over.unary">単項演算子(Unary operators)</a></h1>

<p>
オーバーロード可能な単項演算子は、以下の通りである。
</p>

<pre>
+ - * &amp; ~ ! 
</pre>

<p>
ここでは、*と&amp;は単項演算子であることに注意。<a href="#over.binary">二項演算子</a>の項も参照。
</p>

<p>
インクリメント演算子とデクリメント演算子については、<a href="#over.inc">インクリメントとデクリメント</a>を参照。
</p>

<p>
単項演算子は、演算子を@とおくと、@xという式は、非staticメンバー関数の場合、x.operator @()、非メンバー関数の場合、operator @(x)として呼び出される。単項演算子では、非staticメンバー関数と非メンバー関数は、機能的に違いはない。
</p>

<pre>
struct X
{
    void operator + () ;
} ;

void operator -( X &amp; ) ;

int main()
{
    X x ;
    +x ; // x.operator + ()
    -x ; // operator + (x) 
}
</pre>

<p>
非staticメンバー関数の場合、明示的に仮引数をとらない。暗黙のオブジェクトが仮引数として渡される。
</p>

<pre>
struct X
{
    void operator + () &amp; ;
    void operator + () const &amp; ;
    void operator + () volatile &amp; ;
    void operator + () const volatile &amp; ;

    void operator + () &amp;&amp; ;
    void operator + () const &amp;&amp; ;
    void operator + () volatile &amp;&amp; ;
    void operator + () const volatile &amp;&amp; ;
} ;

int main()
{
    X x ;
    +x ; // void operator + () &amp;
    +static_cast&lt;X &amp;&amp;&gt;(x) ; // void operator + () &amp;&amp;

    X const cx ;
    +x ; // void operator + () const &amp;
}
</pre>

<p>
同様のコードを、非メンバー関数として書くと、以下のようになる。
</p>

<pre>
struct X { } ;

void operator + ( X &amp; ) ;
void operator + ( X const &amp; ) ;
void operator + ( X volatile &amp; ) ;
void operator + ( X const volatile &amp; ) ;

void operator + ( X &amp;&amp; ) ;
void operator + ( X const &amp;&amp; ) ;
void operator + ( X volatile &amp;&amp; ) ;
void operator + ( X const volatile &amp;&amp; ) ;

int main()
{
    X x ;
    +x ; // void operator + ( X &amp; )
    +static_cast&lt;X &amp;&amp;&gt;(x) ; // void operator + ( X &amp;&amp; )

    X const cx ;
    +x ; // void operator + ( X const &amp; )
}
</pre>

<p>
また、非メンバー関数の場合は、クラス型を引数に取ることができる。
</p>

<pre>
struct X { } ;
void operator + ( X ) ;
</pre>

<p>
operator &amp;には、注意を要する。これは、組み込みの演算子、すなわち、オペランドのアドレスを得る演算子として、すべての型にあらかじめ定義されている。
</p>

<pre>
// operator &amp;のオーバーロードなし
struct X { } ;

int main()
{
    X x ;
    X * ptr = &amp;x ; // 組み込みのoperator &amp;の呼び出し
}
</pre>

<p>
この演算子をオーバーロードすると、組み込みのoperator &amp;が働かなくなる。
</p>

<pre>
struct X
{
    X * operator &amp;() { return nullptr ; }
} ;

int main()
{
    X x ;
    X * ptr = &amp;x ; // 常にnullポインターになる。
}
</pre>

<p>
もちろん、戻り値の型は自由だから、なにか別のことをさせるのも可能だ。
</p>

<pre>
class int_wrapper
{
private :
    int obj ;
public :
    int * operator &amp;() { return &amp;obj ; } 
} ;

int main()
{
    int_wrapper wrap ;
    int * ptr = &amp;wrap ;
}
</pre>

<p>
ただし、クラスのユーザーが、オブジェクトのアドレスを得たい場合、組み込みの演算子を呼び出すのは簡単ではない。そのため、標準ライブラリヘッダー&lt;memory&gt;には、std::addressofという関数テンプレートが定義されている。これを使えば、operator &amp;がオーバーロードされているクラスでも、クラスのオブジェクトのアドレスを得ることができる。
</p>

<pre>
struct X
{
    void operator &amp;() { }
} ;

int main()
{
    X x ;
    X * p1 = &amp;x ; // エラー、operator &amp;amp;の戻り値の型はvoid
    X * ptr = std::addressof(x) ; // OK
}
</pre>

</article>

<article>
<h1 id="over.binary"><a href="#over.binary">二項演算子(Binary operators)</a></h1>

<p>
オーバーロード可能な二項演算子は以下の通りである。
</p>

<pre>
+   -   *   /   %   ^   &amp;   |   ~
!   &lt;   &gt;   +=  -=  *=  /=  %=
^=  &amp;=  |=  &lt;&lt;  &gt;&gt;  &gt;&gt;= &lt;&lt;= ==  !=
&lt;=  &gt;=  &amp;&amp;  ||  ,
</pre>

<p>
代入演算子は特別な扱いを受ける。詳しくは、<a href="#over.ass">代入演算子</a>を参照。複合代入演算子は、二項演算子に含まれる。
</p>

<p>
二項演算子は、演算子を@とおくと、x@yという式に対して、非staticメンバー関数の場合、x.operator @(y)、非メンバー関数の場合、operator @(x,y)のように呼び出される。
</p>

<pre>
struct X
{
    void operator + (int) const ;
} ;

void operator - ( X const &amp;, int ) ;

int main()
{
    X x ;
    x + 1 ; // x.operator +(1)
    x - 1 ; // operator -(1)
}
</pre>

<p>
非staticメンバー関数の場合、第一オペランドが暗黙のオブジェクト仮引数に、第二オペランドが実引数に渡される。
</p>

<pre>
struct X
{
    void operator + (int) &amp; ;
    void operator + (int) const &amp; ;
    void operator + (int) volatile &amp; ;
    void operator + (int) const volatile &amp; ;

    void operator + (int) &amp;&amp; ;
    void operator + (int) const &amp;&amp; ;
    void operator + (int) volatile &amp;&amp; ;
    void operator + (int) const volatile &amp;&amp; ;
} ;

int main()
{
    X x ;
    x + 1 ; // X::operator + (int) &amp;
    static_cast&lt;X &amp;&amp;&gt;(x) + 1 ; // X::operator + (int) &amp;&amp;
    X const cx ;
    cx + 1 ; // X::operator + (int) const &amp;
}
</pre>

<p>
同様のコードを、非メンバー関数で書くと以下のようになる。
</p>

<pre>
struct X { } ;

void operator + ( X &amp;, int) ;
void operator + ( X const &amp;, int) ;
void operator + ( X volatile &amp;, int) ;
void operator + ( X const volatile &amp;, int) ;

void operator + ( X &amp;&amp;, int) ;
void operator + ( X const &amp;&amp;, int) ;
void operator + ( X volatile &amp;&amp;, int) ;
void operator + ( X const volatile &amp;&amp;, int) ;

int main()
{
    X x ;
    x + 1 ; // operator + ( X &amp;, int)
    static_cast&lt;X &amp;&amp;&gt;(x) + 1 ; // operator + ( X &amp;&amp;, int)
    X const cx ;
    cx + 1 ; // operator + ( X const &amp;, int)
}
</pre>

<p>
非メンバー関数の場合は、クラス型を仮引数に取ることができる。
</p>

<pre>
struct X { } ;
void operator + ( X, int ) ;
</pre>

<p>
第二オペランドにクラスやenum型、あるいはそのリファレンス型を取りたい場合は、非メンバー関数しか使えない。
</p>

<pre>
struct X { } ;

void operator + ( int, X &amp; ) ;

int main()
{
    X x ;
    1 + x ;
}
</pre>

<p>
メンバー関数によるオーバーロードでは、必ず第一オペランドのメンバーとして演算子関数がよばれるので、これはできない。
</p>

<p>
カンマ演算子、operator ,には、あらかじめ定義された組み込みの演算子が存在する。オーバロードにより、この挙動を変えることもできる。ただし、operator ,の挙動を変えるのは、ユーザーを混乱させるので、慎むべきである。もし、単に任意個の引数を取りたいというのであれば、可変長テンプレートや初期化リストなどの便利な機能が他にもある。
</p>

</article>

<article>
<h1 id="over.ass"><a href="#over.ass">代入(Assignment)</a></h1>

<p>
代入演算子のオーバーロードは、仮引数をひとつとる非staticメンバー関数として実装する。非メンバー関数として実装することはできない。複合代入演算子は、代入演算子ではなく、二項演算子である。
</p>

<pre>
struct X
{
    // コピー代入演算子
    X &amp; operator = ( X const &amp; ) ; 
    // ムーブ代入演算子
    X &amp; operator = ( X &amp;&amp; ) ;

    // intからの代入演算子
    X &amp; operator = ( int ) ;
} ;

// エラー、非メンバー関数として宣言することはできない
X &amp; operator = ( X &amp;, double ) ;

// OK、複合代入演算子は二項演算子
X &amp; operator += ( X &amp;, double ) ;
</pre>

<p>
もちろん、戻り値の型は自由である。ただし、慣例として、暗黙に定義される代入演算子は、*thisを返すようになっている。詳しくは、<a href="#class.copy">クラスオブジェクトのコピーとムーブ</a>を参照。
</p>

</article>

<article>
<h1 id="over.call"><a href="#over.call">関数呼び出し(Function call)</a></h1>

<p>
関数呼び出し演算子の識別子は、operator ()である。関数呼び出し演算子のオーバーロードは、任意個の仮引数を持つ非staticメンバー関数として宣言する。非メンバー関数として宣言することはできない。デフォルト実引数も使うことができる。
</p>

<p>
関数呼び出し演算子は、x(arg1, ...)とおくと、x.operator()(arg1, ...)のように呼び出される。
</p>

<pre>
struct X
{
    void operator () ( ) ;
    void operator () ( int ) ;
    void operator () ( int, int, int = 0 ) ;
} ;

int main()
{
    X x ;
    x() ; // x.operator () ( )
    x( 0 ) ; // x.operator () ( 0 )
    x( 1, 2 ) ; // x.operator() ( 1, 2 ) 
}
</pre>


</article>

<article>
<h1 id="over.sub"><a href="#over.sub">添字(Subscripting)</a></h1>

<p>
添字演算子の識別子は、operator []である。添字演算子のオーバーロードは、ひとつの仮引数を持つ非staticメンバー関数として宣言する。非メンバー関数として宣言することはできない。
</p>

<p>
添字演算子は、x[y]とおくと、x.operator [] (y)のように呼び出される。
</p>

<pre>
struct X
{
    void operator [] ( int ) ;
} ;

int main()
{
    X x ;
    x[1] ; // x.operator [] (1)
}
</pre>

<p>
添字演算子に複数の実引数を渡すことはできない。ただし、初期化リストならば渡すことができる。
</p>

<pre>
struct X
{
    void operator [] ( std::initializer_list&lt;int&gt; list ) ;
} ;

int main()
{
    X x ;
    x[ { 1, 2, 3 } ] ;
}
</pre>

</article>

<article>
<h1 id="over.ref"><a href="#over.ref">クラスメンバーアクセス(Class member access)</a></h1>
<p>
クラスメンバーアクセス演算子の識別子は、operator -&gt;である。クラスメンバーアクセス演算子は仮引数を取らない非staticメンバー関数として宣言する。非メンバー関数にすることはできない。クラスメンバーアクセス演算子は、後述するように、少し変わった特徴がある。
</p>

<p>
クラスメンバーアクセス演算子は、x-&gt;mとおくと、(x.operator-&gt;())-&gt;mのように呼び出される。つまり、もし、x.operator-&gt;()の戻り値の型がクラスへのポインターであれば、そのまま組み込みのクラスメンバーアクセス演算子が使われる。それ以外の場合は、戻り値に対してクラスメンバーアクセス演算子を適用しているために、さらに戻り値のクラスメンバーアクセス演算子が、もし存在すれば、呼び出される。
</p>

<pre>
struct A 
{
    int member ;
} ;

struct B
{
    A a ;
    A * operator -&gt;() { return &amp;a ; }
} ;

struct C
{
    B b ;
    B &amp; operator -&gt;() { return b ; }
} ;


int main()
{
    B b ;
    b-&gt;member ; // (b.operator -&gt;())-&gt;member

    C c ;
// (c.operator -&gt;())-&gt;member
// すなわちこの場合、以下のように展開される。
// ((c.operator -&gt;()).operator -&gt;())-&gt;member
    c-&gt;member ; 
}
</pre>

<p>
クラスBは、
</p>
<p>
クラスCのoperator -&gt;がB &amp;型を返していることに注目。lvalueのBにクラスメンバーアクセス演算子である-&gt;が使われるため、クラスBのクラスメンバーアクセス演算子が呼ばれる。
</p>

<p>
クラスメンバーアクセス演算子の評価の結果に対するクラスメンバーアクセス演算子の呼び出しは、際限なく行われる。このループを断ち切るには、最終的にクラスへのポインターを返し、組み込みのクラスメンバーアクセス演算子を使わなければならない。
</p>

<p>
もちろん、これは演算子として使用した場合であって、明示的に関数を呼び出す場合には、通常通り、その関数だけが呼ばれる。もちろん、戻り値の型をvoid型にすることもできる。
</p>

<pre>
struct X
{
    void operator -&gt;() { return nullptr ; }
} ;


int main()
{
    X x ;
    x.operator -&gt;() ; // OK
}
</pre>

</article>

<article>
<h1 id="over.inc"><a href="#over.inc">インクリメントとデクリメント(Increment and decrement)</a></h1>


<p>
インクリメント演算子の識別子はoperator ++、デクリメント演算子の識別子はoperator --である。インクリメント演算子とデクリメントの演算子は非staticメンバー関数と、非メンバー関数の両方で宣言できる。インクリメント演算子とデクリメント演算子は、識別子の違いを除けば、同じように動く。ここでのサンプルコードは、インクリメント演算子の識別子を使う。
</p>

<p>
インクリメントとデクリメントには、前置と後置の違いがある。
</p>

<pre>
++a ; // 前置
a++ ; // 後置
</pre>

<p>
前置演算子は、非staticメンバー関数の場合、仮引数を取らない。非メンバー関数の場合は、ひとつの仮引数を取る。
</p>

<p>
前置演算子は、++xという式に対して、非staticメンバー関数の場合、x.operator ++ ()、非メンバー関数の場合、operator ++　( x )のように呼び出される。。
</p>

<pre>
struct X
{// 非staticメンバー関数の例
    void operator ++ () ;
} ;

struct Y { } ;
// 非メンバー関数の例
void operator ++ ( Y &amp; ) ;

int main()
{
    X x ;
    ++x ; // x.operator ++() 

    Y y ;
    ++y ; // operator ++(y) 
}
</pre>

<p>
後置演算子は、非staticメンバー関数の場合、int型の引数を取る。非メンバー関数の場合は、二つの仮引数を取る。第二仮引数の型はintでなければならない。int型の仮引数は、単に前置と後置を別の宣言にするためのタグであり、それ以上の意味はない。式としてインクリメントとデクリメントを使うと、実引数には0が渡される。
</p>

<p>
後置演算子は、x++という式に対して、非staticメンバー関数の場合、x.operator ++( 0 ), 非メンバー関数の場合、operator ++ ( x, 0 )のように呼び出される。
</p>

<pre>

struct X
{ // 非staticメンバー関数の例
    void operator ++ (int) ;
} ;

struct Y { } ;
// 非メンバー関数の例
void operator ++ ( Y &amp; , int ) ;



int main()
{
    X x ;
    x++ ; // x.operator ++( 0 ) 

    Y y ;
    y++ ; // operator ++( y, 0 )
}
</pre>

<p>
intをタグとして使うこの仕様はすこし汚いが、例外的な文法を使わなくてもよいという利点があるので採用された。もし明示的に呼び出した場合は、int型の仮引数に対し、0以外の実引数を与えることもできる。
</p>

</article>

<article>
<h1 id="allocation-and-deallocation"><a href="#allocation-and-deallocation">確保関数と解放関数(allocation function and deallocation function)</a></h1>

<p class="todo">
Basic Conceptの該当項目の記述とリンク
</p>

<p>
注意：本来、これはコア言語ではなくライブラリで規定されていることなので、本書の範疇ではないのだが、ここでは読者の便宜のため、宣言方法と、デフォルトの挙動のリファレンス実装を提示する。また、サンプルコードは分割して掲載しているが、確保関数と解放関数はそれぞれ関係しており、すべて一つのソースファイルに含まれることを想定している。そのため、ヘッダーファイルのincludeは最初のサンプルコードにしか書いていない。
</p>

<p>
確保関数の識別子はoperator newである。解放関数の識別子はoperator deleteである。この関数は、動的ストレージの確保と解放を行う。確保関数と解放関数が行うのは、生の動的ストレージの確保と解放である。よく誤解があるが、コンストラクターやデストラクターの呼び出しの責任は持たない。
</p>

<p>
確保関数と解放関数のオーバーロードは、グローバル名前空間か、クラスのメンバー関数として宣言する。グローバル名前空間以外の名前空間で宣言するとエラーとなる。確保関数と解放感数がユーザー定義されない場合、実装によってデフォルトの挙動を行う確保関数と開放感数が自動的に定義される。
</p>

<pre>
// グローバル名前空間
void* operator new(std::size_t size) ; // OK

namespace NS
{
void* operator new(std::size_t size); // エラー、グローバル名前空間ではない
}

struct X
{
    void* operator new(std::size_t size) ; // OK
} ;
</pre>

<p>
グローバル名前空間の宣言は、デフォルトの確保関数と解放関数の生成を妨げる。クラスのメンバー関数は、そのクラスと派生クラスの確保と解放に使われる。
</p>

<p>
確保関数には、効果(effect)と必須の挙動(requied behavior)とデフォルトの挙動(default behavior)が規定されている。解放関数には、効果ととデフォルトの挙動が規定されている。効果とは、その関数がどのようなことに使われるのかという規定である。必須の挙動とは、たとえユーザー定義の関数であっても必ず守らなければならない挙動のことである。デフォルトの挙動とは、関数がユーザー定義されていない場合、実装によって用意される定義の挙動である。
</p>

<p>
C++11ではスレッドの概念が入ったので、確保関数と解放関数は、データ競合を引き起こしてはならない。この保証は、ユーザー定義の確保関数と開放感数にも要求される。
</p>

<p>
C++11ではアライメントの概念が入ったので、確保関数の確保するストレージは、要求されたサイズ以下の大きさのオブジェクトを配置できるよう、適切にアラインされていなければならない。
</p>


<h1>単数形の確保関数</h1>
<pre>
void* operator new(std::size_t size) ;
</pre>

<dl>
<dt>効果</dt>
<dd>
<p>
この確保関数は、new式からsizeバイトのストレージを確保するために呼ばれる。
</p>
</dd>

<dt>必須の挙動</dt>
<dd>
<p>
適切にアラインされたストレージを指し示すnullポインターではない値を返す。もしくは、std::bad_exceptionがthrowされる。
</p>
</dd>

<dt>デフォルトの挙動</dt>
<dd>
<ul>
<li>ループを実行する。ループの中で、要求されたストレージの確保を試みる。ストレージ確保の方法は実装依存である。</li>
<li>ストレージの確保が成功したならば、ストレージへのポインターを返す。ストレージの確保が成功しなかった場合で、現在のnew_handlerがnullポインターの場合、std::bad_allocをthrowする。</li>
<li>現在のnew_handlerがnullポインター以外の場合、現在のnew_handlerを呼び出す。呼び出しが返ったならば、ループを続行する。</li>
<li>ループはストレージの確保が失敗するか、new_handlerの呼び出しが返らないまで、続けられる。</li>
</ul>

<pre>
#include &lt;cstddef&gt;
#include &lt;cstdlib&gt;
#include &lt;new&gt;

void* operator new( std::size_t size )
{
    // std::mallocに実引数0を渡した場合の挙動は定義されていない
    if ( size == 0 ) { size = 1 ; }

    while( true ) // ループを実行する
    {
        // ループの中で、要求されたストレージの確保を試みる
        void * ptr = std::malloc( size ) ;

        // ストレージの確保が成功したならば
        if ( ptr != nullptr )
        { // ストレージへのポインターを返す
            return ptr ;
        }

        // ストレージの確保が成功しなかった場合
        std::new_handler handler = std::get_new_handler() ;
        if ( handler == nullptr ) // 現在のnew_handlerがnullポインターの場合
        { // std::bad_allocをthrowする。
            throw std::bad_alloc() ;
        } else // 現在のnew_handlerがnullポインターではない場合
        { // 現在のnew_handlerを呼び出す
            handler( ) ;
        }
    // ループを続行する
    }
}
</pre>
</dd>
</dl>


<h1>nothrow版の単数形の確保関数</h1>
<pre>
void * operator new( std::size_t size, const std::nothrow_t &amp; ) noexcept ;
</pre>

<dl>
<dt>効果</dt>
<dd>
<p>
前項の確保関数と同じ。ただし、エラー報告としてstd::bad_allocをthrowする代わりに、nullポインターを返す
</p>
</dd>

<dt>必須の挙動</dt>
<dd>
<p>
適切にアラインされたストレージへのポインターを返すか、nullポインターを返す。この関数の返すポインター、nothrowではない確保関数を呼び出してストレージを確保した場合と同じポインターを返す。
</p>
</dd>

<dt>デフォルトの挙動</dt>
<dd>
<p>
operator new(size)を呼び出す。呼び出しが通常通り返れば、その戻り値を返す。それ以外の場合、nullポインターを返す。
</p>

<pre>
void* operator new( std::size_t size, const std::nothrow_t &amp; ) noexcept
{
    try { // operator new(size)を呼び出す
    // 呼び出しが通常通り返れば、その戻り値を返す
        return operator new( size ) ;
    } catch( ... )
    { // それ以外の場合、nullポインターを返す。
        return nullptr ;
    }
}
</pre>
</dd>
</dl>



<h1>単数形の解放関数</h1>
<pre>
void operator delete( void * ptr ) noexcept ;
</pre>

<dl>
<dt>効果</dt>
<dd>
<p>
この解放関数は、ptrの値を無効にするため、delete式から呼ばれる。ptrの値は、nullポインターか、operator new(std::size_t) もしくは operator new(std::size_t,const std::nothrow_-
t&amp;)によって返された値で、まだoperator delete(void*)に渡していないものである。
</p>
</dd>

<dt>デフォルトの挙動</dt>
<dd>
<p>
ptrの値がnullポインターであれば、なにもしない。それ以外の場合、先のoperator newの呼び出しで確保されたストレージを解放する。
</p>

<pre>
void operator delete( void* ptr ) noexcept
{
    std::free( ptr ) ;
}
</pre>
</dd>
</dl>

<h1>nothrow版の単数形の解放関数</h1>
<pre>
void operator delete( void * ptr, const std::nothrow_t &amp; ) noexcept ;
</pre>



<dl>
<dt>効果</dt>
<dd>
<p>
nothrow版のnew式によって呼び出されたコンストラクターが例外を投げた時に、ストレージを解放するために呼ばれる。delete式では呼ばれない。
</p>

<pre>
struct X
{
    X() { throw 0 ; }
} ;


int main()
{
    new(std::nothrow) X ; // operator delete( void *, std::nothrow_t &amp;)が呼ばれる
}
</pre>
</dd>

<dt>デフォルトの挙動</dt>
<dd>
<p>
operator delete(ptr)を呼び出す。
</p>
<pre>
void operator delete( void* ptr, const std::nothrow_t &amp; ) noexcept
{
    operator delete( ptr ) ;
}
</pre>
</dd>
</dl>

<h1>配列形の確保関数</h1>
<pre>
void　* operator new[](　std::size_t size　)　;
</pre>

<dl>
<dt>効果</dt>
<dd>
<p>
この確保関数は配列形のnew式からsizeバイトのストレージを確保するために呼ばれる。
</p>
</dd>

<dt>必須の挙動</dt>
<dd>
<p>
単数形の確保関数と同じ。
</p>
</dd>

<dt>デフォルトの挙動</dt>
<dd>
<p>
operator new(size)を返す
</p>

<pre>
void * operator new[]( std::size_t size )
{
    return operator new( size ) ;
}
</pre>
</dd>
</dl>

<h1>nothrow版の配列形の確保関数</h1>
<pre>
void * operator new[]( std::size_t size, const std::nothrow_t &amp; ) noexcept ;
</pre>

<dl>
<dt>効果</dt>
<dd>
<p>
この確保関数は、nothorow版のnew式から呼ばれる。エラー報告として、std::bac_allocをthrowする代わりに、nullポインターを返す。
</p>
</dd>

<dt>必須の挙動</dt>
<dd>
<p>
適切にアラインされたストレージへのポインターを返すか、nullポインターを返す
</p>
</dd>

<dt>デフォルトの挙動</dt>
<dd>
<p>
operator new[](size)を呼び出す。呼び出しが通常通り返れば、その結果を返す。それ以外の場合は、nullポインターを返す。
</p>

<pre>
void * operator new[]( std::size_t size, const std::nothrow_t &amp; ) noexcept
{
    try {
        return operator new[]( size ) ;
    } catch( ... )
    {
        return nullptr ;
    }
}
</pre>
</dd>
</dl>

<h1>配列型の解放関数</h1>

<pre>
void operator delete[]( void * ptr) noexcept ;
</pre>

<dl>
<dt>効果</dt>
<dd>
<p>
この解放関数は、配列型のdelete式から、ptrの値を無効にするために呼ばれる
</p>
</dd>


<dt>デフォルトの挙動</dt>

<dd>
<p>
operator delete(ptr)を呼ぶ。
</p>

<pre>
void operator delete[]( void * ptr ) noexcept
{
    operator delete( ptr ) ;
}
</pre>
</dd>
</dl>

<h1>nothrow版の配列型の解放関数</h1>
<pre>
void operator delete[]( void * ptr, const std::nothrow_t &amp; ) noexcept ;
</pre>

<dl>
<dt>効果</dt>
<dd>
<p>
nothrow版の配列型のnew式によって呼び出されたコンストラクターが例外を投げた時に、ストレージを解放するために呼ばれる。配列型のdelete式では呼ばれない。
</p>
</dd>

<dt>デフォルトの挙動</dt>

<dd>
<p>
operator delete[](ptr)を呼び出す
</p>

<pre>
void operator delete[]( void * ptr, const std::nothrow_t &amp; ) noexcept
{
    operator delete[]( ptr ) ;
}
</pre>
</dd>
</dl>

</article>


<article>
<h1 id="over.literal"><a href="#over.literal">ユーザー定義リテラル</a></h1>

<p class="todo">
Basic Conceptsの該当項目へのリンク
</p>

<p>
以下の形のオーバーロード演算子は、ユーザー定義リテラル演算子のオーバーロードである。
</p>

<pre>
operator "" 識別子
</pre>

<p>
""と識別子の間には、必ずひとつ以上の空白文字を入れなければならない。また、識別子の先頭文字は、必ずアンダースコアひとつから始まらなければならない。ただし、通常の識別子では、アンダースコアから始まる名前は予約されているので注意すること。これは、ユーザー定義リテラル演算子のみの特別な条件である。
</p>

<pre>
// OK
void operator "" /* 空白文字が必要 */ _x( unsigned long long int ) ;

// エラー、""と_yの間に空白文字がない
void operator ""_y( unsigned long long int ) ;

// エラー、識別子がアンダースコアから始まっていない
void operator "" z( unsigned long long int ) ;

// エラー、""の間に空白文字がある
void operator " " _z( unsigned long long int ) ;
</pre>

<p>
リテラル演算子の仮引数リストは、以下のいずれかでなければならない。
</p>

<pre>
const char*
unsigned long long int
long double
char
wchar_t
char16_t
char32_t
const char*, std::size_t
const wchar_t*, std::size_t
const char16_t*, std::size_t
const char32_t*, std::size_t
</pre>

<p>
上記以外の仮引数リストを指定すると、エラーとなる。
</p>

<p>
リテラル演算子テンプレートは、仮引数リストが空で、テンプレート仮引数は、char型の非型テンプレート仮引数の仮引数パックでなければならない。
</p>

<pre>
template &lt; char ... Chars &gt;
void operator "" _x () { }
</pre>

<p>
これ以外のテンプレート仮引数を取るリテラル演算子テンプレートはエラーとなる。
</p>

<p>
リテラル演算子は、Cリンケージを持つことができない。
</p>

<pre>
// エラー
extern "C" void operator "" _x( unsigned long long int ) { }

// OK
extern "C++" void operator "" _x( unsigned long long int ) { }
</pre>

<p>
リテラル演算子は、名前空間スコープで宣言しなければならない。つまり、クラススコープで宣言することはできない。ただし、friend関数になることはできる。
</p>

<pre>
// グローバル名前空間スコープ
void operator "" _x( unsigned long long int ) { }

namespace ns {
// ns名前空間スコープ
void operator "" _x( unsigned long long int ) { }
}

class X
{
    // OK、friend宣言できる
    friend void operator "" _x( unsigned long long int ) ;

    // エラー、クラススコープでは宣言できない
    static void operator "" _y( unsigned long long int ) ; 
} ;
</pre>

<p>
ただし、名前空間スコープで宣言したリテラル演算子を、ユーザー定義リテラルとして使うには、using宣言かusingディレクティブが必要となる。
</p>

<pre>
namespace ns {
void operator "" _x( unsigned long long int ) { }
}

int main( )
{
    1_x ; // エラー、operator "" _xは見つからない

    {
        using namespace ns ;
        1_x ; // OK
    }

    {
        using ns::operator "" _x ;
        1_x ; // OK
    }
}
</pre>

<p>
これ以外は、通常の関数と何ら変りない。例えば、明示的に呼び出すこともできるし、その際には通常のオーバーロード解決に従う。inlineやconstexpr関数として宣言することもできる。内部リンケージでも外部リンケージのどちらでも持てる。アドレスも取得できる。等々。
</p>

</article>

</article>

</article>

<article>
<h1 id="temp"><a href="#temp">テンプレート(Templates)</a></h1>

<p>
テンプレートとは、コンパイル時に型や値を引数として渡す機能のことである。
</p>

<pre>
template &lt; テンプレート仮引数リスト &gt; 宣言
</pre>

<p>
テンプレートを指定できる宣言は、クラス、関数、エイリアス宣言である。それぞれ、クラステンプレート、関数テンプレート、エイリアステンプレートと呼ばれる。
</p>

<pre>
// 関数テンプレート
template &lt; typename T &gt;
void f( ) ;

// クラステンプレート
template &lt; typename T &gt;
struct X ;

// エイリアステンプレート
template &lt; typename T &gt;
using type = T ;
</pre>

<p>
テンプレート仮引数リストのテンプレート仮引数名は省略できる
</p>

<pre>
template &lt; typename &gt;
struct X { } ;
</pre>

<p>
俗に、クラス/関数のテンプレートの代わりに、テンプレートのクラス/関数などと呼ばれることがある。ただし、テンプレートコードには実体がないので、テンプレートのクラスというよりは、クラスのテンプレートと言ったほうが正確である。
</p>

<p>
テンプレートには実体がない。テンプレートは具体的な型実引数を与えられて、実体化(インスタンス化、Instantiation)する。テンプレートの異なる実体は、それぞれ別の型を持つ。
</p>

<pre>
// クラステンプレートの宣言
template &lt; typename T &gt;
struct X ;

// クラステンプレートの定義
template &lt; typename T &gt;
struct X { } ;

// クラステンプレートの実体化
X&lt;int&gt; x ;
</pre>

<p>
テンプレートを宣言できるのは、名前空間スコープかクラススコープの中だけである。例えば、関数のブロックスコープでは宣言できない。
</p>

<pre>
void f()
{
    // エラー
    template &lt; typename T &gt;
    struct X { } ; 
}
</pre>



<article>
<h1 id="temp.param"><a href="#temp.param">テンプレート仮引数/実引数(Template parameters/arguments)</a></h1>

<p>
テンプレート仮引数(template parameters)は、テンプレート側で記述する引数である。テンプレート実引数は、テンプレートに与える引数である。本来、テンプレート仮引数とテンプレート実引数は明確に別の機能であるが、本書では分かりやすさを重視して、同時に説明する。
</p>

<p>
テンプレート仮引数と実引数には、型、非型、テンプレートがある。ここでは、テンプレート仮引数の宣言方法とテンプレート実引数の渡し方を説明する。
</p>

<article>
<h1 id="template.pa"><a href="#template.pa">型テンプレート仮引数/実引数</a></h1>

<p>
型を引数に取るテンプレート仮引数は、classまたはtypenameというキーワードに続いて、テンプレート仮引数名を記述する。classとtypenameには、意味上の違いはない。
</p>

<pre>
template &lt; typename T &gt;
class X ;

template &lt; class T &gt;
class Y ;

// 複数の引数を取る場合は、,で区切る
template &lt; typename T, typename U &gt;
classs X ;
</pre>

<p>
テンプレート実引数は、テンプレート名に続いて、&lt; &gt;で実引数を囲んで渡す。
</p>

<pre>
template &lt; typename T &gt;
void f() { }

template &lt; typename T &gt;
struct X { } ;

int main( )
{
    // テンプレート実引数 int
    f&lt;int&gt;() ;
    // テンプレート実引数 int
    X&lt;int&gt; x ;
}
</pre>

<p>
テンプレート仮引数は、テンプレートコードの中で、あたかも型や値であるかのように使うことができる。
</p>

<pre>
template &lt; typename T &gt;
struct X
{
    // T型のデータメンバーmemberの宣言
    T member ;
} ;
</pre>

<p>
Tの具体的な型は、テンプレート実引数が与えられたときに、すなわち、テンプレートが実体化したときに決定される。
</p>
</article>

<article>
<h1 id="non-type.template.pa"><a href="#non-type.template.pa">非型テンプレート仮引数/実引数</a></h1>
<p>
非型テンプレート仮引数(non-type template parameters)は、型以外、つまり値を引数に取る。非型テンプレート仮引数は、class/typenameと記述する代わりに、型を記述する。非型テンプレート仮引数に使える型は以下の通り。
</p>

<ul>
<li>
<p>
整数型とenum型
</p>

<pre>
// 整数型の一例
template &lt; int I, unsigned int UI, unsigned long long int ULLI &gt;
struct A { } ;

// enum型の例
enum struct E : int { value = 0 } ;

template &lt; E value &gt;
struct B { } ;


int main( )
{
    // 非型テンプレート実引数
    A&lt; 0, 0u, 0ull &gt; a ;
    B&lt; E::value &gt; b ;
}
</pre>
</li>


<li>
<p>
オブジェクトへのポインターと、関数へのポインター
</p>

<pre>
// オブジェクトへのポインター
template &lt; int * P &gt;
struct A { } ;

// 関数へのポインター
using func_ptr_type = void (*)() ;

template &lt; func_ptr_type FUN &gt;
struct B { } ;

void f() { }
static int global = 0 ;

int main( )
{
    // 非型テンプレート実引数
    A&lt; &amp;global &gt; a ;
    B&lt; &amp;f &gt; b ;
}
</pre>
</li>

<li>
<p>
オブジェクトへのlvalueリファレンスと関数へのlvalueリファレンス
</p>

<pre>
// オブジェクトへのlvalueリファレンス
template &lt; int &amp; P &gt;
struct A { } ;

// 関数型のtypedef名
using func_type = void () ;
// 関数へのlvalueリファレンス
template &lt; func_type &amp; FUN &gt;
struct B { } ;

void f() { }
static int global = 0 ;

int main( )
{
    // 非型テンプレート実引数
    A&lt; global &gt; a ;
    B&lt; f &gt; b ;
}
</pre>

</li>

<li>
<p>
メンバーへのポインター
</p>

<pre>
struct X
{
    int member ;
} ;

// メンバーへのポインター
template &lt; int X::* P &gt;
struct Y { } ;

int main( )
{
    Y&lt; &amp;X::member &gt; y ;
}
</pre>
</li>

<li>
<p>
std::nullptr_t
</p>

<pre>
template &lt; std::nullptr_t N &gt;
struct X { } ;

X&lt; nullptr &gt; x ;
</pre>

</li>

</ul>

<p>
非型かつ非リファレンスのテンプレート仮引数はprvalueであり、いかなる方法を持っても代入などの値の変更をすることはできない。アドレスを取得することはできない。リファレンスに束縛される場合には、一時オブジェクトが使われる。
</p>

<pre>
template &lt; int I &gt;
void f()
{
// 値の変更はできない
    I = 0 ; // エラー
    ++I ; // エラー

// アドレスの取得はできない
    int * p = &amp;I ; // エラー

// リファレンスの束縛には一時オブジェクトがつかわれる
    int const &amp; ref = I ;
}
</pre>

<p>
非型テンプレート仮引数は、浮動小数点数型、クラス型、void型として宣言することはできない。
</p>

<pre>
// エラー
template &lt; double d &gt;
struct S1 ;

struct X { }

// エラー
template &lt; X x &gt;
struct S2 ;

// エラー
template &lt; void v &gt;
struct S3 ;
</pre>

<p>
非型テンプレート仮引数の型が、「T型への配列」や、「T型を返す関数」である場合、それぞれ、「T型へのポインター」、「T型を返す関数へのポインター」と、型が変換される。
</p>

<pre>
// int * a
template &lt; int a[5] &gt; 
struct S1 ;

// int (*func)()
template &lt; int func() &gt;
struct S2 ;
</pre>

<p>
非型テンプレート実引数は、厳しい制約を受ける。
</p>

<p>
整数型とenum型の非型テンプレート仮引数に対するテンプレート実引数は、以下のとおりである。
</p>

<ul>
<li>
<p>テンプレート仮引数の型に変換できる定数式</p>

<pre>
template &lt; int I &gt;
struct S { } ;


int main()
{
    S&lt; 0 &gt; s1 ;
    S&lt; 1 + 1 &gt; s2 ;

    constexpr int x = 0 ;
    S&lt; x &gt; s3 ;
}
</pre>

</li>

<li>
<p>
非型テンプレート仮引数の名前
</p>

<pre>
template &lt; int I &gt;
struct A { } ;

template &lt; int I &gt;
struct B
{
    A&lt;I&gt; a ;
} ;
</pre>

</li>

<li>
<p>
定数式の、静的ストレージ上のオブジェクトへのアドレスと関数で、リンケージを持つもの。
</p>

<pre>
int x = 0 ; 

template &lt; int * ptr &gt;
struct A { } ;


int f() { return 0 ; }

template &lt; int (*func)() &gt;
struct B { } ;

int main()
{
    A&lt; &amp;x &gt; a ; // OK
    B&lt; &amp;f &gt; b ; // OK

    static int no_linkage = 0 ; // リンケージを持たない
    A&lt; no_linkage &gt; a2 ; // エラー
}
</pre>

<p>
これは、実際にはもっと複雑な条件だが、本書では省略する。
</p>
</li>

<li>nullポインター、nullメンバーポインターの値であると評価される定数式</li>
<li>メンバーへのポインター</li>

</ul>

<p>
文字列リテラルをテンプレート実引数として渡すことはできない。配列の要素へのアドレスを渡すこともできない。
</p>
</article>

<article>
<h1 id="template.template.pa"><a href="#template.template.pa">テンプレートテンプレート仮引数/実引数</a></h1>
<p>
テンプレート仮引数は、テンプレートを実引数に取ることができる。これをテンプレートテンプレート仮引数、テンプレートテンプレート実引数と呼ぶ。
</p>

<pre>
template &lt; typename T &gt;
struct A { } ;

template &lt;
    template &lt; typename T &gt;
    // ここはclassキーワードを使わなければならない
    class U 
&gt;
struct B
{
    // Uはテンプレートとして使える
    U&lt;int&gt; u ;
} ; 

int main()
{
    B&lt; A &gt; b ;

    B&lt; int &gt; e1 ; // エラー
    B&lt; 0 &gt; e2 ; // エラー
}
</pre>

<p>
テンプレートテンプレート仮引数は、テンプレートを受け取る。テンプレートを受け取るテンプレートなので、「テンプレートテンプレート仮引数」となる。この宣言は、テンプレート仮引数自体が、さらにtemplateキーワードを使う文法になる。テンプレート仮引数の名前には、文法上の制約により、classキーワードを使わなければならない。
</p>

<pre>
// OK
template &lt; template &lt; typename &gt; class T &gt;
struct X { } ;

// エラー
template &lt; template &lt; typename &gt; typename T &gt;
struct Y { } ;
</pre>

<p>
テンプレートテンプレート仮引数に対するテンプレートテンプレート実引数は、クラステンプレートか、エイリアステンプレートでなければならない。
</p>

<pre>
// クラステンプレート
template &lt; typename T &gt;
struct A { } ;

// エイリアステンプレート
template &lt; typename T &gt;
using B = T ;

template &lt; template &lt; typename T &gt; class U  &gt;
struct C
{
    U&lt;int&gt; u ;
} ; 

int main()
{
    C&lt; A &gt; a ; // クラステンプレート
    C&lt; B &gt; b ; // エイリアステンプレート
}
</pre>


</article>

<article>
<h1 id="default-template-argument"><a href="#default-template-argument">デフォルトテンプレート実引数</a></h1>

<p>
テンプレート仮引数には、デフォルトテンプレート実引数を指定することができる。デフォルトテンプレート実引数は、=に続けて実引数を記述する。
</p>

<pre>
template &lt; typename T = int, int I = 0 &gt;
struct X { } ;

int main()
{
    
    X&lt;&gt; a ; // X&lt; int, 0 &gt;
    X&lt; double &gt; b ; // X&lt; double, 0 &gt;
    X&lt; short, 1 &gt; c ; // X&lt; short, 1 &gt;
}
</pre>


<p>
デフォルトテンプレート実引数は、可変引数テンプレートを除く、すべての種類のテンプレート仮引数（型、非型、テンプレート）に指定できる。
</p>

<pre>
// 型テンプレート
template &lt; typename T = int &gt;
struct X { } ;

// 非型テンプレート
template &lt; int I = 123 &gt;
struct Y { } ;

// テンプレートテンプレート
template &lt; template &lt; typename &gt; class TEMP = X &gt;
struct Z { } ;

// エラー、可変引数テンプレートには指定できない
template &lt; typename ... T &gt;
struct Error { } ;
</pre>

<p>
デフォルトテンプレート実引数は、クラステンプレートのメンバーのクラス外部での定義に指定することはできない。これは説明が難しい。この場合のテンプレート仮引数には、クラスのテンプレートと、クラスのメンバーのテンプレートがあるが、このどちらにも、デフォルトテンプレート実引数を指定することはできない。
</p>

<pre>
// クラステンプレートの定義
template &lt; typename T &gt;
struct X
{
 // メンバー関数テンプレートの宣言
    template &lt; typename U &gt;
    void f() ;
} ;

// クラス外部での定義
template &lt; typename T = int &gt; // エラー（クラスXのテンプレート）
template &lt; typename U = int &gt; // エラー（クラスXのメンバーfのテンプレート）
void X&lt;T&gt;::f()
{ } 
</pre>

<p>
この場合、デフォルトテンプレート実引数を指定したい場合は、それぞれ、クラステンプレートの定義や、メンバーの宣言に指定しなければならない。
</p>

<p>
デフォルトテンプレート実引数は、friendクラステンプレートのメンバー宣言に指定することはできない。
</p>

<pre>
template &lt; typename T &gt;
struct X
{
    // エラー
    template &lt; typename U = int &gt; 
    friend class X ;
} ;
</pre>

<p>
デフォルトテンプレート実引数が、friend関数テンプレート宣言に指定された場合、そのfriened関数テンプレート宣言は、定義でなければならない。
</p>

<pre>

template &lt; typename T &gt;
struct X
{
    // エラー、宣言
    template &lt; typename U = int &gt; 
    friend void f() ;

    // OK、定義
    template &lt; typename U = int &gt; 
    friend void g() { }
} ;
</pre>

<p>
これは、friend関数の宣言は、定義となることができるためである。詳しくは、<a href="#class.friend">friend</a>を参照。
</p>

<p>
デフォルトテンプレート実引数が指定されているテンプレート仮引数に続くテンプレート仮引数には、デフォルトテンプレート実引数が指定されていなければならない。
</p>

<pre>
// エラー、後続のテンプレート仮引数にテンプレート実引数が指定されていない
template &lt; typename T = int, typename U &gt;
struct X ;
</pre>

<p>
あるいは、後続のテンプレート仮引数は、可変引数テンプレート仮引数でなければならない。
</p>

<pre>
// OK
template &lt; typename T = int , typename ... Types &gt;
struct X { } ;
</pre>

<p>
同じ宣言のテンプレート仮引数には、二度以上デフォルトテンプレート実引数を指定してはならない。
</p>

<pre>
// OK
template &lt; typename T = int&gt; struct A ;
template &lt; typename T &gt; struct A { } ;

// OK
template &lt; typename T &gt; struct B ;
template &lt; typename T = int &gt; struct B { } ;

// エラー
template &lt; typename T = int &gt; struct C ;
template &lt; typename T = int &gt; struct C { } ;
</pre>

<p>
デフォルトテンプレート実引数に与える式に含まれる&gt;には注意が必要である。ネストされていない&gt;は、テンプレート宣言の終了とみなされる。
</p>

<pre>
// 文法エラー
template &lt; int i = 1 &gt; 2 &gt;
struct X { } ;

// OK
template &lt; int i = ( 1 &gt; 2 ) &gt;
sturct Y { } ;
</pre>

<p>
テンプレートテンプレート仮引数内のテンプレート仮引数にも、デフォルトテンプレート実引数を指定することができる。
</p>

<pre>
template &lt; template &lt; typename TT = int &gt; class T &gt;
struct X
{
    T&lt;&gt; a ; // T&lt; int &gt; 
} ;
</pre>



</article>

<article>
<h1 id="variadic-template-parameter"><a href="#variadic-template-parameter">可変テンプレート仮引数</a></h1>

<p>
識別子の前に...を記述したテンプレート仮引数は、仮引数パックの宣言となる。これは、可変引数テンプレート(Variadic Templates)のための仮引数の宣言である。詳しくは、<a href="#temp.variadic">可変引数テンプレート</a>を参照。
</p>

<pre>
template &lt; typename ... Types &gt;
struct X { } ;
</pre>



</article>

</article>

<article>
<h1 id="temp.names"><a href="#temp.names">テンプレート特殊化の名前(Names of template specializations
)</a></h1>

<p>
特殊化されたテンプレートは、テンプレートID(template-id)によって参照できる。これは普通の名前とは違い、特殊化したテンプレート実引数を指定する。テンプレートidとは、テンプレート名に続いて、&lt;を記述してテンプレート実引数を記述し、&gt;で閉じることによって記述できる。
</p>

<pre>
template &lt; typename T &gt;
struct X { } ;

X テンプレート名
X&lt;int&gt; テンプレートXをintに特殊化したテンプレートID
</pre>

</article>

<article>
<h1 id="temp.type"><a href="#temp.type">型の同一性(Type equivalence)</a></h1>

<p>
二つのテンプレートidが同じクラスや関数であるためには、以下の条件を満たさなければならない。
</p>


<ul>
<li>
<p>
テンプレート名、演算子関数ID（オーバーロード演算子のテンプレートの場合）、リテラル演算子ID（オーバーロードリテラル演算子のテンプレートの場合）が同じ
</p>
</li>

<li>
<p>
対応するテンプレート実引数の型が等しい。
</p>
</li>

<li>
<p>
対応する非型テンプレート実引数の値が同じ。
</p>

<pre>

#include &lt;type_traits&gt;

template &lt; int I &gt;
class X { } ;


int main()
{
    std::cout &lt;&lt; std::is_same&lt; X&lt;0&gt;, X&lt;0&gt; &gt;::value ; // true
    std::cout &lt;&lt; std::is_same&lt; X&lt;0&gt;, X&lt;1&gt; &gt;::value ; // false
    std::cout &lt;&lt; std::is_same&lt; X&lt;2&gt;, X&lt; 1 + 1 &gt; &gt;::value ; // true
}
</pre>
</li>
<li>
<p>
対応する非型テンプレート実引数が、ポインター、メンバーへのポインター、リファレンスの場合、同じ外部オブジェクトを指し示していなければならない。ポインターとメンバーへのポインターの場合、nullポインターでもよい。
</p>

<pre>
#include &lt;type_traits&gt;

template &lt; int * P &gt;
class X { } ;

int a ;
int b ;

int main()
{
    std::cout &lt;&lt; std::is_same&lt; X&lt;&amp;a&gt;, X&lt;&amp;a&gt; &gt;::value ; // true
    std::cout &lt;&lt; std::is_same&lt; X&lt;&amp;a&gt;, X&lt;&amp;b&gt; &gt;::value ; // false
    std::cout &lt;&lt; std::is_same&lt; X&lt;nullptr&gt;, X&lt;nullptr&gt; &gt;::value ; // true
}
</pre>
</li>

<li>
<p>
対応するテンプレートテンプレート実引数が同じ。
</p>

<pre>
#include &lt;type_traits&gt;

template &lt; template &lt; typename &gt; class T &gt;
class X { } ;

template &lt; typename T &gt;
class Y { } ;
template &lt; typename T &gt;
class Z { } ;

int main()
{
    std::cout &lt;&lt; std::is_same&lt; X&lt;Y&gt;, X&lt;Y&gt; &gt;::value ; // true
    std::cout &lt;&lt; std::is_same&lt; X&lt;Y&gt;, X&lt;Z&gt; &gt;::value ; // false
}
</pre>
</li>

</ul>

</article>

<article>
<h1 id="temp.decls"><a href="#temp.decls">テンプレート宣言(Template declarations)</a></h1>

<article>
<h1 id="temp.class"><a href="#temp.class">クラステンプレート(Class templates)</a></h1>
<p>
クラステンプレートはテンプレート仮引数に続けてクラス宣言を書くことで宣言できる。
</p>

<pre>
template &lt; typename T, std::size_t SIZE &gt;
class Array 
{
private :
    T buf[SIZE] ;
public :

    Array() : buf{}
    { }

    T &amp; operator []( std::size_t i )
    { return buf[i] ; }

    T const &amp; operator []( std::size_t i ) const
    { return buf[i] ; }

} ;

int main( )
{
    Array&lt; int, 10 &gt; a ;
    a[3] = 100 ;
}
</pre>

<p>
テンプレート仮引数は、型や値やテンプレートとして使うことができ、テンプレートが実体化されたときにテンプレート実引数によって置き換えられる。
</p>

<p>
クラステンプレートのメンバー関数、メンバークラス、メンバーenum、staticデータメンバー、メンバーテンプレートを、メンバーが属するクラステンプレート定義の外部で定義する場合は、メンバー定義には、メンバーが属するひとつ外側のクラステンプレートのテンプレート仮引数を記述し、さらにメンバーが属するひとつ外側のクラステンプレートのテンプレート名に続けてテンプレート実引数リストを、同じ順番で記述しなければならない。
</p>

<pre>
template &lt; typename T &gt;
class Outer
{
    // クラス定義内部のでのメンバーの宣言
    void member_function() ;
    class member_class ; 
    enum struct member_enum : int ;
    static int static_data_member ;

    template &lt; typename U &gt;
    class member_template ;
} ;

// クラス定義外部でのメンバーの定義

// メンバー関数
template &lt; typename T &gt;
void Outer&lt;T&gt;::member_function() { }

// メンバークラス
template &lt; typename T &gt;
class Outer&lt;T&gt;::member_class { } ;

// メンバーenum
template &lt; typename T &gt;
enum struct Outer&lt;T&gt;::member_enum : int
{ value = 1 } ;

// staticデータメンバー
template &lt; typename T &gt;
int Outer&lt;T&gt;::static_data_member ;

// メンバーテンプレート
// クラス以外のテンプレートも同じ方法で記述する
template &lt; typename T &gt; // Outerのテンプレート仮引数
template &lt; typename U &gt; // member_templateのテンプレート仮引数
class Outer&lt;T&gt;::member_template { } ;
</pre>

<p>
これは、一見すると、恐ろしいほど難しそうに見えるが、クラスのメンバーをクラス定義の外部で宣言する文法に、テンプレート仮引数が加わっただけだ。ただし、メンバーテンプレートの定義方法だけは、少し分かりにくい。クラステンプレートのメンバーテンプレートには、メンバーテンプレートのテンプレート仮引数と、メンバーテンプレートが属するクラステンプレートのテンプレート仮引数の、両方が必要だからだ。
</p>

<p>
もちろん、メンバーはいくらでもネストできるので、宣言はもっと複雑になることもある。
</p>

<pre>
template &lt; typename T &gt;
class Outer
{
    template &lt; typename U &gt;
    class Inner
    {
        template &lt; typename V &gt;
        class Deep ;
    } ;
} ;

template &lt; typename T &gt; // Outerのテンプレート仮引数
template &lt; typename U &gt; // Innerのテンプレート仮引数
template &lt; typename V &gt; // Deepのテンプレート仮引数
class Outer&lt;T&gt;::Inner&lt;U&gt;::Deep { } ;
</pre>



</article>

<article>
<h1 id="temp.mem"><a href="#temp.mem">メンバーテンプレート(Member Templates)</a></h1>

<p>
テンプレートは、クラス定義の内部で宣言することができる。そのようなテンプレートを、メンバーテンプレート(Member Templates)と呼ぶ。
</p>

<pre>
class Outer
{
    // メンバーテンプレート
    template &lt; typename T &gt;
    class Inner { } ;
} ;
</pre>

<p>
メンバーテンプレートは、クラス定義の内部でも外部でも定義できる。メンバーをクラス定義の外で定義する方法については、<a href="#temp.class">クラステンプレート(Class templates)</a>を参照。
</p>

<p>
メンバーテンプレートには、いくつかの制限や例外的なルールが存在する。
</p>

<p>
ローカルクラスはメンバーテンプレートを持つことができない。
</p>

<pre>
void f()
{
    // エラー、
    template &lt; typename T &gt;
    class X { } ;
}
</pre>

<p>
デストラクターはメンバーテンプレートとして宣言できない。
</p>

<pre>
class X
{
    // エラー
    template &lt; typename T &gt;
    ~X() { } 
} ;
</pre>

<p>
メンバー関数テンプレートはvirtual関数にはできない。
</p>

<pre>
class X
{
    // エラー
    template &lt; typename T &gt;
    virtual void f() ;
} ;
</pre>

<p>
また、メンバー関数テンプレートの特殊化は基本クラスのvirtual関数をオーバーライドすることはない。
</p>

<pre>
struct Base
{
    virtual void f( int ) ;
} ;

struct Derived : Base
{
    template &lt; typename T &gt;
    void f( T ) ; // Base::fをオーバーライドしない
} ;
</pre>

</article>

<article>
<h1 id="temp.variadic"><a href="#temp.variadic">可変引数テンプレート(Variadic Templates)</a></h1>

<p>
可変引数テンプレート(Variadic templates)は、0個以上のテンプレート実引数や関数実引数を取るテンプレートのことである。
</p>

<p>
テンプレート仮引数の宣言で、識別子の前に...が記述されているとき、これをテンプレート仮引数パック(Template parameter pack)と呼ぶ。
</p>


<pre>
// 型テンプレート仮引数パック
template &lt; typename ... Type_pack &gt;
class X { } ;

// 非型テンプレート仮引数パック
template &lt; int ... Int_pack &gt;
class Y { } ;

// テンプレートテンプレート仮引数パック
template &lt; template &lt; typename &gt; class ... Template_pack &gt;
class Z { } ;

// テンプレート実引数として与えるためのテンプレート
template &lt; typename T &gt;
class Arg { } ;

int main( )
{
    X&lt; &gt; x1 ;
    X&lt; int &gt; x2 ; 
    X&lt; int, int, double, float &gt; x3 ;

    Y&lt; &gt; y1 ;
    Y&lt; 0 &gt; y2 ;
    Y&lt; 1, 2, 3, 4, 5 &gt; y3 ;

    Z&lt; &gt; z1 ;
    Z&lt; Arg &gt; z2 ;
    Z&lt; Arg, Arg, Arg &gt; z3 ;
}
</pre>

<p>
上記の例のように、テンプレート仮引数パックは、0個以上の任意の数のテンプレート実引数を取る。
</p>

<p>
非型テンプレート仮引数として、オブジェクトや関数へのポインターやリファレンスなども可変引数テンプレートにできる。ただし、記述方法が少し分かりにくい。そのため、直接書くよりもtypedef名を使う方が読みやすくなる。
</p>

<pre>
// やや読みにくい宣言
template &lt; void ( * ... func_pack ) () &gt;
class X { } ;

using type = void (*)() ;
// 読みやすい宣言
template &lt; type ... func_pack &gt;
class Y { } ;
</pre>

<p>
可変引数テンプレートをテンプレート実引数に取るテンプレートテンプレート仮引数は、以下のように書く。
</p>

<pre>
// 可変引数テンプレートを取る可変引数テンプレート
template &lt;
    template &lt; typename Type &gt; class Template
&gt;
class X { } ;

// テンプレート実引数に渡すテンプレート
template &lt; typename ... Type_pack &gt;
class Arg { } ;

int main( )
{
    X&lt; Arg &gt; x ;
}
</pre>

<p>
もちろん、このクラステンプレートXを、さらに可変引数テンプレートにすることもできる。
</p>

<pre>
// 可変引数テンプレートを取る可変引数テンプレート
template &lt;
    template &lt; typename ... Type_pack &gt; class ... Template_pack
&gt;
class X { } ;

// テンプレート実引数に渡すテンプレート
template &lt; typename ... Type_pack &gt;
class Arg { } ;

int main( )
{
    X&lt; Arg, Arg, Arg &gt; x ;
}
</pre>

<p>
関数仮引数パック(function parameter pack)は、テンプレート仮引数パックを使って、0個以上の関数の実引数を得る関数仮引数である。宣言方法は、関数の仮引数の識別子の前の...を記述する。
</p>

<pre>
// 任意の型の0個以上の実引数をとる関数
template &lt; typename ... template_parameter_pack &gt;
void f( template_parameter_pack ... function_parameter_pack ) { }

int main( )
{
    f( ) ;
    f( 1 ) ;
    f( 1, 2, 3, 4, 5 ) ;
}
</pre>

<p>
テンプレート仮引数パックと関数仮引数パックをあわせて、仮引数パック(Parameter pack)という。
</p>

<p>
仮引数パックは、そのままでは使えない。仮引数パックを使うには、展開しなければならない。これをパック展開(Pack expansion)という。パック展開は、パターンと...を組み合わせて記述する。テンプレートの実体化の際に、0個以上の実引数が、パターンに合わせて展開される。パターンの範囲は文脈により異なるが、見た目上は、仮引数パックを含む文字列を繰り返しているように見えるよう設計されている。
</p>

<pre>
template &lt; typename ... pack &gt;
struct type_list_impl { } ;

template &lt; typename ... pack &gt;
struct type_list
{
    using type = type_list_impl&lt;
        pack // パターン
        ... 
    &gt; ;
} ;

int main()
{
    // type_list_impl&lt;&gt;
    type_list&lt;&gt;::type t1 ; 
    // type_list_impl&lt;int, int&gt;
    type_list&lt;int, int&gt;::type t2 ;
}
</pre>

<p>
この例では、type_listの仮引数パックであるpackをパック展開して、type_list_implのテンプレート実引数に渡している。"pack..."というのが、パック展開である。packがパターンだ。この場合は、そのまま展開している。
</p>

<p>
関数仮引数パックの場合も同様である。
</p>

<pre>
template &lt; typename ... Types &gt;
void f_impl( Types ... pack ) { }

template &lt; typename ... Types &gt;
void f( Types ... pack )
{
    f_impl( pack... ) ;
}

int main()
{
    // f_impl( )を呼ぶ
    f( ) ;
    // f_impl( 1, 2, 3 )を呼ぶ
    f( 1, 2, 3 ) ;
}
</pre>


<p>
ここでも、"pack..."がパック展開で、packがパターンになっている。
</p>

<p>
パターンの記述は、パック展開の文脈に依存する。パック展開中の仮引数パックに対するパターンには、その文脈で許される記述をすることができ、そのパターンによって展開される。
</p>

<pre>
template &lt; typename T &gt;
struct wrap { } ;


template &lt; typename ... pack &gt;
struct type_list_impl { } ;

template &lt; typename ... pack &gt;
struct type_list
{
    using pointers = type_list_impl&lt;
        pack *...
    &gt; ;

    using references = type_list_impl&lt;
        pack &amp;...
    &gt; ;

    using wraps = type_list_impl&lt;
        wrap&lt;pack&gt;...
    &gt; ;
} ;

int main()
{
    // type_list_impl&lt; char *, short *, int * &gt;
    type_list&lt; char, short, int &gt;::pointers t1 ;

    // type_list_impl&lt; char &amp;, short &amp;, int &amp; &gt;
    type_list&lt; char, short, int &gt;::references t2 ;

    // type_list_impl&lt; wrap&lt;char&gt;, wrap&lt;short&gt;, wrap&lt;int&gt; &gt;
    type_list&lt; char, short, int&gt;::wraps t3 ;
}
</pre>

<p>
packがテンプレート仮引数パックであるならば、pack * ...はそれぞれの実引数に*を加えたパターンとして展開される。wrap&lt;pack&gt;は、それぞれの実引数をクラステンプレートwrapの実引数に渡すパターンとして展開される。
</p>

<p>
関数仮引数パックの場合も同様。
</p>

<pre>
template &lt; typename ... param_pack &gt;
void f( param_pack ... ) { } // 仮引数名の省略

template &lt; typename T &gt;
T identity( T value )
{
    return value ;
}

template &lt; typename ... param_pack &gt;
void g( param_pack ... pack )
{
    f( pack ... ) ; // そのまま関数fに渡す
    f( (pack + 1)... ) ; // +1して関数fに渡す
    f( identity(pack)... ) ; // identity()の評価の結果を関数fに渡す

}

int main( )
{
    g( ) ;
    g( 1 ) ;
    g( 1, 2, 3, 4, 5 ) ;

}
</pre>

<p>
パック展開できる文脈は限られているが、一般に、型や式をコンマで区切って記述する文脈に書くことができる。
</p>

<p>
まず、特別なパック展開が三種類ある。ただし、規格上は区別されてない。この特別なパック展開は、パック展開でありながら、仮引数パックでもあるという特徴を持つ。
</p>

<ul>

<li>
<p>
関数仮引数パックの宣言
</p>

<p>
関数仮引数パックの宣言は、...以外がそのままパック展開のパターンにもなる。そのため、これは仮引数パックかつパック展開となる。
</p>

<pre>
template &lt; typename ... param_pack &gt;
void f( param_pack const &amp; ... pack ) ;
</pre>

<p>
この例では、"param const &amp;"がパターンとなる。
</p>

<p>
関数仮引数パックは、宣言自体がパターンとなっているので、実引数の型がパターンに一致しない場合、実引数推定が失敗する。これを利用して、型を部分的に限定することができる。
</p>

<pre>
// ポインター型しか実引数に指定できない関数
template &lt; typename ... Types &gt;
void f( Types * ... pack  )
{　}

int main( )
{
    int * p = nullptr ;
    f( p ) ; // OK
    f( 123 ) ; // エラー
}
</pre>

<p>
同様に、メンバーへのポインターや、関数へのポインターに限定することもできる。
</p>

<pre>
// 実引数を取らず、任意の型を戻り値に返す関数へのポインターを実引数に取る関数
template &lt; typename ... ReturnType &gt;
void f( ReturnType (* ... pack) ( ) )
{ }

void g( ) { }
int h( ) { }
double i( ) { }

int main( )
{
    f( &amp;g, &amp;h, &amp;i ) ; 
}
</pre>

<p>
パターンは...を除いた部分なので、この場合のパターンは、"ReturnType (*)()"となる。つまり関数へのポインター型になっている。
</p>

<p>
もっと複雑な条件で型を限定したい場合は、テンプレートメタプログラミングの技法を使うことができる。その詳細は本書の範疇を超えるので、ここには書かない。
</p>

</li>

<li>
<p>
テンプレート仮引数パックがパック展開となる場合
</p>

<p>
これには二種類ある。ひとつは、非型テンプレート仮引数パックの仮引数宣言に、先に宣言されたテンプレート仮引数が使われる場合。パターンは、...を除いた部分となる。
</p>

<pre>
template &lt; typename T, /* パターンここから */ T * /* パターンここまで */... Types &gt;
struct X { } ;

int main( )
{
    X&lt; int, nullptr &gt; x ;
}
</pre>

<p>
この例では、"T *"がパターンとなっている。関数仮引数パックと同じように、実引数の型を制限できる。
</p>

<p>
もうひとつは、テンプレートテンプレート仮引数パックの中で、先に宣言されたテンプレート仮引数パックが使われる場合。パターンは...を除いた部分となる
</p>


<pre>
template&lt; typename ... Types &gt;
struct Outer
{
    template&lt; template&lt; Types &gt; class ... pack &gt;
    struct Inner ;
} ;
</pre>

<p>
これは少し分かりにくい。仮引数パックTypesのパック展開が、クラステンプレートInnerのテンプレート仮引数で行われている。パターンは、"template&lt; Types &gt; class"だ。
</p>

<p>
今、Outer&lt; char, short, int &gt;のようにテンプレート実引数が渡されたとすると、Innerのパック展開の結果を擬似的に記述すると、以下のようになる。。
</p>

<pre>
template &lt; char, short, int &gt;
struct Outer
{
    template &lt;
        template &lt; char &gt; class pack_1,
        template &lt; short &gt; class pack_2,
        template &lt; int &gt; class pack_3
    &gt;
    struct Inner ;
} ;
</pre>

<p>
つまり、テンプレートInnerのテンプレート仮引数は、テンプレートテンプレート仮引数がパターンで、仮引数パックであるTypesに対してパターンを適用してパック展開されることになる。
</p>

<p>
これはあくまで解説のための擬似的なコードである。可変引数テンプレートは、パックとパック展開という形で使うので、手で書いたようなテンプレートに展開されるわけではない。
</p>

</li>

</ul>

<p>
その他のパック展開だけの文脈は以下の通り。
</p>

<ul>
<li>
<p>
初期化リストの中
</p>



<p>
関数呼び出し式の中の式リストも、初期化リストである。パターンは初期化子の式となる。
</p>

<pre>

sturct X
{
    template &lt; typename ... pack &gt;
    X( pack ... ) { }
} ;

template &lt; typename ... Types &gt;
void f( Types ... pack ) { }

template &lt; typename ... Types &gt;
void g( Types ... pack )
{
    X x( pack ... ) ; 
    f( pack... ) ;
    
    f( (pack + 1)... ) ;// パターンはpack+1
}
</pre>

</li>

<li>
<p>
基本クラス指定リストの中
</p>

<p>
これにより、仮引数パックに対するすべての実引数の型を基本クラスに指定することができる。パターンは基本クラス指定子。
</p>

<pre>
template &lt; typename ... pack &gt;
struct X : pack ...
{ } ;

struct A { } ;
struct B { } ;


int main( )
{
    X&lt; &gt; x1 ; // 基本クラスなし
    X&lt; A &gt; x2 ; // 基本クラスA
    X&lt; B &gt; x3 ; // 基本クラスB
    X&lt; A, B &gt; x4 ; // 基本クラスAとB

    X&lt; int &gt; x5 ; // エラー、intは基本クラスにできない
}
</pre>

<p>
複雑なパターンの例。
</p>

<pre>
template &lt; typename T &gt;
struct wrap { } ;


template &lt; typename ... pack &gt;
struct X : wrap&lt; pack &gt; ...
{ } ;

int main( )
{
    // Xの基本クラスはwrap&lt;int&gt;とwrap&lt;double&gt;
    X&lt; int, double &gt; x ;
}
</pre>

<p>
この例では、テンプレート実引数はwrap&lt;T&gt;に包まれて基本クラスに指定される。そのため、直接intから派生するのではなく、テンプレートwrapの特殊化から派生することになる。
</p>

</li>

<li>
<p>
メンバー初期化リスト
</p>

<p>
これは、初期化リストとほぼおなじだ。パターンはメンバー初期化子の式になる。
</p>

<pre>
struct X
{
    template &lt; typename ... pack &gt;
    X( pack ... ) { }
} ;

struct Y
{
    X x ;
    template &lt; typename ... pack &gt;
    Y( pack ... args )
        : x( args... )
    { }
} ;

int main( )
{
    Y y( 1, 2, 3 ) ;   
}
</pre>

</li>

<li>
<p>
テンプレート実引数リスト
</p>

<p>
パターンはテンプレート実引数。
</p>

<pre>
template &lt; typename ... pack &gt;
struct X { } ;

template &lt; typename T &gt;
struct wrap { } ;

template &lt; typename ... pack &gt;
struct Y
{
    // パターンはpack
    X&lt; pack ... &gt; x1 ;
    // パターンはwrap&lt;pack&gt;
    X&lt; wrap&lt;pack&gt; ... &gt; x2 ;
} ;
</pre>

</li>

<li>
<p>
アトリビュートリスト
</p>

<p>
パターンはアトリビュート
</p>

<pre>
template &lt; typename ... pack &gt;
struct X
{
    [[ pack ... ]] ;

} ;
</pre>

</li>

<li>
<p>
アライメント指定子
</p>

<p>
パターンは...を除いたアライメント指定子
</p>

<pre>
template &lt; typename ... pack &gt;
struct X
{
    alignas( pack ... ) int data_member ;
} ;
</pre>

<p>
たとえば、X&lt;int, short, double&gt;と実引数を与えると、この特殊化されたクラスXのデータメンバーdata_memberのアライメント指定は、alignas( int, short, double )と記述したものと等しくなる。
</p>

</li>


<li>
<p>
キャプチャーリスト
</p>

<p>
パターンはキャプチャー
</p>

<pre>
template &lt; typename ... Types &gt;
void f_impl( Types ... ) { }

template &lt; typename ... Types &gt;
void f( Types ... pack )
{
    // キャプチャーのパターンは&amp;pack
    [ &amp;pack ... ]{ f_impl( pack... ) ; }() ;
}
</pre>

<p>
この例では、関数仮引数パックをパック展開して、ラムダ式でリファレンスキャプチャーしている。
</p>
</li>

<li>
<p>
sizeof...式
</p>

<p>
sizeof...式も、パック展開の一種である。ただし、パターンは識別子なので、特に特別なことはできない。ただ、仮引数パックの数を返すだけだ。
</p>

<pre>
template &lt; typename ... Types &gt;
int f( Types ... args )
{
    sizeof...(Types) ; // 評価はテンプレート仮引数パックの数
    sizeof...(args) ; // 評価は関数仮引数パックの数

    return sizeof...(Types) ;
}


int main( )
{
    f() ; // 評価は0
    f( 1, 2, 3 ) ; // 評価は3
}
</pre>
</li>

</ul>

<article>
<h1 id="how-to-use-variadic-templates"><a href="#how-to-use-variadic-templates">可変引数テンプレートの使い方</a></h1>

<p>
本書はコア言語の文法と機能を解説するものであって、使い方を紹介するものではない。ただし、可変引数テンプレートでは、最低限の使い方を解説する。
</p>

<p>
仮引数テンプレートは、仮引数パックによって、0個以上の実引数を取ることができる。ただし、仮引数パックはそのままでは使えない。仮引数パックは、仮引数ではないからだ。仮引数パックを使うには、パック展開しなければならない。では、一体どうやって、任意個の実引数に対応した汎用的なコードを書くのか。それには、二つ方法がある。固定長の仮引数を取るものに渡すか再帰だ。
</p>

<p>
固定長の仮引数を取るものに渡すというのは、単にパック展開して渡せばよい。
</p>

<pre>
#include &lt;iostream&gt;

// 実引数ゼロ個の時は何もしない
void print_impl( ) { }

template &lt; typename T1 &gt;
void print_impl( T1 a1 )
{
    std::cout &lt;&lt; a1 &lt;&lt; std::endl ;
}

template &lt; typename T1, typename T2 &gt;
void print_impl( T1 a1, T2 a2 )
{
    std::cout &lt;&lt; a1 &lt;&lt; std::endl ;
    std::cout &lt;&lt; a2 &lt;&lt; std::endl ;
}

template &lt; typename ... Types &gt;
void print( Types ... pack )
{
    print_impl( pack ... ) ;
}

int main( )
{
    print( ) ; // エラー
    print( 1 ) ; // OK
    print( 1, 2 ) ; // OK
    print( 1, 2, 3 ) ; // エラー
}
</pre>

<p>
問題は、コード例をみても分かるように、このコードは汎用的ではないという事だ。固定長の仮引数を持つ関数に渡しているために、固定長しか扱えない。これではせっかくの可変引数の意味がない。
</p>

<p>
固定長の仮引数を取るものに渡すというのは、特定の条件で、特別な処理をしたい場合に使えるが、汎用的に使うことはできない。
</p>

<p>
任意の個数の実引数に対応した汎用的なコードを書くためには、再帰を使う。
</p>

<pre>
// 再帰の終了条件
void print(  ) { }

template &lt; typename T, typename ... Types &gt;
void print( T head, Types ... tail )
{
    std::cout &lt;&lt; head &lt;&lt; std::endl ;
    print( tail ... ) ; // 再帰的実体化
}

int main( )
{
    print( ) ; // エラー
    print( 1 ) ; // OK
    print( 1, 2 ) ; // OK
    print( 1, 2, 3 ) ; // OK
}
</pre>

<p>
再帰と言っても、同じ関数を再帰的に呼び出すわけではない。仮引数パックで受ける実引数の数をひとつづつ減らしていき、新たなテンプレートを実体化させて呼び出している。たとえば、print(1, 2, 3, 4, 5)を呼び出した場合、以下のように実体化されて呼び出される。
</p>

<pre>
print&lt;int, int, int, int, int&gt;( 1, 2, 3, 4, 5 )
print&lt;int, int, int, int&gt;( 2, 3, 4, 5 )
print&lt;int, int, int&gt;( 3, 4, 5 )
print&lt;int, int&gt;( 4, 5 )
print&lt;int&gt;( 5 ) 
print() 
</pre>

<p>
トリックは、実引数をすべて仮引数パックで受けるのではなく、一つを除いた残りを受ける形にすることだ。これにより、実引数をひとつづつ減らしながら再帰的にテンプレートを実体化して呼び出すことができる。ただし、仮引数パックは0個の実引数を受けることができるので、そのままではコンパイル時に無限ループしてしまう。コンパイル時無限ループを防ぎ、コンパイル時再帰を正しく終了させるために、仮引数を取らない非テンプレートな関数を用意している。オーバーロード解決により、非テンプレートな関数は、関数テンプレートの実体化より優先される。
</p>

<p>
また、仮引数パックを使わない関数テンプレートの実体化は、仮引数パックを使う関数テンプレートの実体化より、オーバーロード解決で優先される。たとえば、二つ以上の任意個の実引数を取り、最小の値を返す関数テンプレートminは、以下のように実装できる。
</p>

<pre>
// 終了条件
template &lt; typename T &gt;
T min ( T a1, T a2 )
{
    return a1 &lt; a2 ? a1 : a2 ;
}

template &lt; typename T, typename ... Types &gt;
T min( T head, Types ... tail )
{
    return min( head, min( tail ... ) ) ; 
}
</pre>


<p>
クラステンプレートのテンプレート仮引数パックの場合も、同様に、固定長へのパック展開か、再帰的な汎用コードが使える。
</p>

<p>
固定長へのパック展開の例は、以下の通り。
</p>

<pre>
template &lt; typename T1, typename T2, typename T3 &gt;
struct type_list_impl
{ } ;


template &lt; typename ... pack &gt;
struct type_list
    : type_list_impl&lt; pack ... &gt;
{ } ;
</pre>


<p>
明らかに、このコードは汎用的ではない。それに、クラステンプレートには、部分的特殊化があるので、このようなことはしなくても固定長への特殊化はできる。
</p>

<pre>
// Primary Class Template
template &lt; typename ... pack &gt;
struct type_list ; 

template &lt; typename T1 &gt;
struct type_list&lt; T1 &gt;
{ } ;

template &lt; typename T1, typename T2 &gt;
struct type_list&lt; T1, T2 &gt;
{ } ;

template &lt; typename T1, typename T2, typename T3 &gt;
struct type_list&lt; T1, T2, T3 &gt;
{ } ;
</pre>


<p>
ただし、固定長の別の関数にパック展開する関数仮引数パックと同じように、固定長の部分的特殊化は、汎用的ではない。特定の条件に対する特殊な別の実装のためには適切であっても、汎用的なコードは書けない。
</p>

<p>
テンプレート仮引数パックを使うクラステンプレートを汎用的に書くには、再帰を使えばよい。再帰の方法として、再帰的に基本クラスから派生する方法と、再帰的にデータメンバーとして持つ方法がある。
</p>

<pre>
// 再帰的に基本クラスから派生する方法
// primary class template
template &lt; typename ... &gt;
struct base_class_trick ;

// 部分的特殊化
template &lt; typename Head, typename ... Tail &gt;
struct base_class_trick&lt; Head, Tail ... &gt;
    : base_class_trick&lt; Tail ... &gt;
{ } ;

// 終了条件
template &lt;  &gt;
struct base_class_trick&lt; &gt;
{ } ;

// 再帰的にデータメンバーとして持つ方法
// primary template
template &lt; typename ... &gt;
struct data_member_trick ;

// 部分的特殊化
template &lt; typename Head, typename ... Tail &gt;
struct data_member_trick&lt; Head, Tail ... &gt;
{
    data_member_trick&lt; Tail ... &gt; tail ;
} ;

// 終了条件
template &lt; &gt;
struct data_member_trick&lt; &gt;
{ } ;
</pre>

<p>
自分自身から派生したり、自分自身をデータメンバーに持っているわけではない。再帰のたびに、別の実体化を発動させるので、派生したりデータメンバーに持っているのは、別のクラスである。再帰の終了には、部分的特殊化か、明示的特殊化を使う。
</p>

<p>
これを応用して、任意のテンプレート実引数の型と数をコンストラクターで受け取り、クラスのデータメンバーとして格納するクラスが書ける。
</p>

<pre>
template &lt; typename ... &gt;
struct tuple ;

template &lt; typename Head, typename ... Tail &gt;
struct tuple&lt; Head, Tail ... &gt;
    : tuple&lt; Tail ... &gt;
{
        Head data ;
        tuple( Head const &amp; head, Tail const &amp; ... tail )
            : tuple&lt; Tail ... &gt;( tail ... ),
              data( head ) 
        { }
} ;

// 終了条件
template &lt; &gt;
struct tuple&lt; &gt;
{ } ;

int main()
{
    tuple&lt; int, short, double, float &gt; t( 12, 34, 5.6, 7.8f ) ;
}
</pre>

<p>
クラステンプレートtupleは、別の実体化から再帰的に派生する。実体化されたtupleは、それぞれ先頭のテンプレート実引数の型をデータメンバーとして持つ。コンストラクターは先頭の型の値と、仮引数パックからなる実引数を取り、先頭の値をデータメンバーに格納して、残りを基本クラスに投げる。これが再帰的に行われるため、すべての実引数を格納することができる。
</p>

<p>
ただし、tupleから値を取り出すのは、少し面倒だ。なぜならば、対応するクラスの型にキャストしなければならないからだ。
</p>

<pre>
int main( )
{
    tuple&lt; int, short, double, float &gt; t( 12, 34, 5.6, 7.8f ) ;
    double d = static_cast&lt; tuple&lt; double, float&gt; &amp; &gt;(t).data ;
}
</pre>

<p>
これも可変引数テンプレートを使って解決できる。何番目の値が欲しいか実引数として与えれば、その値を返してくれる関数テンプレートを書けばいい。インデックスは0から始まるとする。この関数テンプレートは、以下のような形になる。
</p>

<pre>
template &lt; std::size_t I,  typename ... Types &gt;
戻り値の型 get( tuple&lt; Types ... &gt; &amp; t )
{
    return static_cast&lt; 対応する値が格納されているクラス型 &gt;(t).data ;
}

int main( )
{
    tuple&lt; int, short, double, float &gt; t( 12, 34, 5.6, 7.8f ) ;
    auto value = get&lt;2&gt;( t ) ; // 5.6
}
</pre>

<p>
さて、戻り値の型はどうやって指定すればいいのか。それには、インデックスを指定すれば、その型を返してくれるメタ関数を書けばよい。
</p>


<pre>
template &lt; std::size_t I, typename T  &gt;
struct tuple_element ;

template &lt; std::size_t I, typename Head, typename ... Types &gt;
struct tuple_element&lt; I, tuple&lt; Head, Types ... &gt; &gt;
    : tuple_element&lt; I - 1, tuple &lt; Types ... &gt; &gt;
{
    static_assert( I &lt; 1 + sizeof...( Types ), "index exceeds the tuple length." ) ;
} ;

template &lt; typename Head, typename ... Types &gt;
struct tuple_element &lt; 0, tuple&lt; Head, Types ... &gt; &gt;
{
    using type = Head ;
} ;

int main( )
{
    using type = tuple&lt; int, short, double, float &gt; ;
    tuple_element&lt; 2, type &gt;::type d ; // double
}
</pre>

<p>
tuple_elementは、0から始まるインデックスを数値として指定すると、対応する型を、ネストされた型名typeとして返すメタ関数だ。
</p>

<p>
次に、キャストすべき型を返してくれるメタ関数をつくる。
</p>

<pre>
template &lt; std::size_t, typename ... &gt;
struct tuple_get_type ;

template &lt; std::size_t I, typename Head, typename ... Tail &gt;
struct tuple_get_type&lt; I, Head, Tail ... &gt;
    : tuple_get_type&lt; I-1, Tail ... &gt;
{ } ;

template &lt; typename Head, typename ... Tail &gt;
struct tuple_get_type&lt; 0, Head, Tail ... &gt;
{
    using type = tuple&lt; Head, Tail ... &gt; ;
} ;


int main()
{
    // typeはtuple&lt; double, float &gt; 
    using type = tuple_get_type&lt; 2, int, short, double, float &gt;::type ; 
}
</pre>

<p>
この二つのメタ関数を合わせると、関数テンプレートgetは、以下のように書ける。
</p>

<pre>
template &lt; std::size_t I,  typename ... Types &gt;
typename tuple_element&lt; I, tuple&lt; Types ... &gt; &gt;::type &amp;
get( tuple&lt; Types ... &gt; &amp; t )
{
    return static_cast&lt; typename tuple_get_type&lt;I, Types ... &gt;::type &amp; &gt;(t).data ;
}
</pre>

<p>
まだまだ、面白い技法はたくさんあるのだが、本書はテンプレートメタプログラミングの解説書ではないので、ここで筆を止める。さらに深く調べたい者は、標準ライブラリのtupleやfunctionやbindから始めるといいだろう。もし十分な需要があれば、C++11によるテンプレートメタプログラミングの本も執筆するかもしれない。
</p>

</article>

</article>

<article>
<h1 id="temp.friend"><a href="#temp.friend">friend</a></h1>

<p>
friend宣言はテンプレートとして宣言できる。また、friend宣言はテンプレートの特殊化を指定できる。
</p>

<p>
非テンプレートなfriend宣言で、クラステンプレートや指定するには、特殊化を指し示していなければならない。関数テンプレートは、特殊化か、あるいは実引数推定されるものを指し示さなければならない。
</p>

<pre>
template &lt; typename T &gt;
class X ;

template &lt; typename T &gt;
void f( T ) ;


template &lt; typename T &gt;
class Y
{
    friend class X ; // エラー    

    friend class X&lt;int&gt; ; // OK
    friend void f( int ) ; // OK

    friend class X&lt;T&gt; ; // OK
    friend void f( T ) ; // OK 
    friend void f&lt;double&gt;(double) ; // OK

} ;
</pre>


<p>
friendで指定されたテンプレートの特殊化のみのがクラス、あるいはクラステンプレートのfriendとなる。その他の特殊化はfriendとはならない。
</p>

<pre>
template &lt; typename T &gt;
void f( ) ;


template &lt; typename T &gt;
class X
{
private :
    int data ;

    friend void f&lt;int&gt;( ) ;
} ;

template &lt; typename T &gt;
void f()
{
    Y y ;
    y.data = 0 ;
}

int main( )
{
    f&lt;int&gt;() ; // OK、f&lt;int&gt;はXのfriend
    f&lt;double&gt;() ; // エラー、f&lt;double&gt;はXのfriendではない
}
</pre>


<p>
friendテンプレートは、クラステンプレートと関数テンプレートの全ての実体化に対して働く。
</p>

<pre>
template &lt; typename T &gt;
void f() ;

template &lt; typename T &gt;
struct Y { } ;

class X
{
private :
    int data ;

    // 関数テンプレートfに対するfriendテンプレート
    template &lt; typename T &gt;
    friend void f() ;
    // クラステンプレートYに対するfriendテンプレート
    template &lt; typename T &gt;
    friend class Y ;

} ;

template &lt; typename T &gt;
void f()
{
    X x ;
    x.data = 0 ;
}


int main( )
{
    f&lt;int&gt;() ; // OK
    f&lt;double&gt;() ; // OK
}
</pre>

<p>
クラステンプレートのすべての特殊化のメンバー関数をfriendにする場合は、friendテンプレートを使う。
</p>

<pre>
template &lt; typename T &gt;
struct X
{
    static void f() ;
} ;

class Y
{
private :
    int data ;
    // クラステンプレートXのすべての特殊化のメンバー関数fに対するfriendテンプレート
    template &lt; typename T &gt;
    friend void X&lt;T&gt;::f() ;
} ;

template &lt; typename T &gt;
void X&lt;T&gt;::f()
{
    Y y ;
    y.data = 0 ;
}


int main( )
{
    X&lt;int&gt;::f() ; // OK
    X&lt;double&gt;::f() ; // OK
}
</pre>

<p>
friendテンプレートは、ローカルクラスでは宣言できない。
</p>

<p>
friendテンプレートは、部分的特殊化できない。
</p>

<pre>
template &lt; typename T &gt;
struct X { } ;

struct Y
{
    // エラー、部分的特殊化はできない
    template &lt; typename T &gt;
    friend struct X&lt; T * &gt; ;
} ;
</pre>

</article>

<article>
<h1 id="temp.class.spec"><a href="#temp.class.spec">クラステンプレートの部分的特殊化(Class template partial specializations)</a></h1>

<p>
クラステンプレートの部分的特殊化(Class template partial specializations)は、特殊化(specialization)という名前がついているが、テンプレートの実体化の結果生成される特殊化や、明示的特殊化とは異なる。これは部分的な特殊化であって、テンプレートである。
</p>

<p>
テンプレート宣言の際のテンプレート名が、識別子だけの基本となるクラステンプレートを、プライマリークラステンプレート(Primary class template)と呼ぶ。俗に、プライマリーテンプレートとも呼ばれる。
</p>

<pre>
// プライマリークラステンプレート
template &lt; typename T &gt;
class Identifier ; 
</pre>

<p>
クラステンプレートの部分的特殊化は、この基準となるプライマリークラステンプレートの一部を特殊化するものである。その宣言方法は、先に宣言したテンプレートと同名で、テンプレート実引数を加えた形のテンプレートIDで宣言する。
</p>

<pre>
// プライマリークラステンプレートX
template &lt; typename T &gt;
struct X { } ;

// Xの部分的特殊化
template &lt; typename T &gt;
struct X&lt; T * &gt;
{ } ;
</pre>

<p>
プライマリークラステンプレートは、部分的特殊化よりも先に宣言されていなければならない。
</p>

<p>
部分的特殊化は、直接参照することはできない。部分的特殊化のあるテンプレートを使う際に、最もテンプレート実引数に対して特殊化されたテンプレートが選ばれて実体化される。
</p>

<pre>
// #1
template &lt; typename T &gt;
struct X { } ;
// #2
template &lt; typename T &gt;
struct X&lt; T * &gt; { } ;
// #3
template &lt; typename T &gt;
struct X&lt; T &amp; &gt; { } ;

int main( )
{
    X&lt; int &gt; x1 ; // #1
    X&lt; int * &gt; x2 ; // #2
    X&lt; int &amp; &gt; x3 ; // #3
}
</pre>

<p>
この例では、テンプレート実引数int *は、T *が最も特殊化されているので、#2が選ばれる。
</p>

<p>
部分的特殊化は、名前通り部分的に特殊化していればいい。一部に具体的な型や値やテンプレートを与えることもできる。
</p>

<pre>
// #1
template &lt; typename T1, typename T2 &gt;
struct X { } ;

// #2
template &lt; typename T &gt;
struct X&lt; T, T &gt; { } ;

// #3
template &lt; typename T &gt;
struct X&lt; T, double &gt; { } ;

int main( )
{    
    X&lt; int, int &gt; x1 ; // #2
    X&lt; int, double &gt; x2 ; // #3

    // エラー、曖昧
    X&lt; double, double &gt; x3 ;
}
</pre>

<p>
プライマリークラステンプレートを使うつもりがないのであれば、プライマリークラステンプレートは宣言するだけで、定義しなくてもよい。以下の例は、テンプレート実引数としてポインター型だけを受け取るテンプレートである。
</p>

<pre>
// プライマリークラステンプレートの宣言
// 定義はしない
template &lt; typename T &gt;
struct RequirePointerType ;

// 部分的特殊化
template &lt; typename T &gt;
struct RequirePointerType&lt; T * &gt; { } ;


int main( )
{
    RequirePointerType&lt; int * &gt; x1 ; // OK
    RequirePointerType&lt; int &gt; x2 ; // エラー、定義がない
}
</pre>

<p>
このテンプレートに、ポインター以外の型をテンプレート実引数として渡しても、定義がないために、エラーとなる。
</p>

<p>
部分的特殊化のテンプレート仮引数の数は、プライマリークラステンプレートには左右されない。ただ、部分的特殊化として、テンプレートIDに指定する仮引数の数が一致していればよい。
</p>

<pre>
// #1
template &lt; typename T &gt;
struct X { } ;

// #2
template &lt; typename T, template &lt; typename &gt; class Temp &gt;
struct X&lt; Temp&lt;T&gt; &gt;
{ } ;

int main( )
{
    X&lt; X&lt;int&gt; &gt; x ;
}
</pre>

<p>
この例では、X&lt;int&gt;には#1のテンプレートが使われ、X&lt; X&lt;int&gt; &gt;には、#2のテンプレートが使われる。
</p>

<p>
テンプレートIDに与えるテンプレート実引数の数が、プライマリークラステンプレートに一致していなければ、エラーとなる。
</p>

<pre>
// #1
template &lt; typename T1, typename T2 &gt;
struct X { } ;

// エラー
template &lt; typename T &gt;
struct X&lt; T &gt; ;

// エラー
template &lt; typename T1, typename T2, typename T3 &gt;
struct X&lt; T1, T2, T3 &gt; ; 
</pre>

<p>
また、プライマリークラステンプレートのテンプレート仮引数の種類、すなわち、型テンプレート、非型テンプレート、テンプレートテンプレートに一致していなければならない。
</p>

<pre>
// 型、非型(int型)、テンプレート
template &lt; typename T, int I, template &lt; typename &gt; class Temp &gt;
struct X  ;

// OK
template &lt; typename T, template &lt; typename T &gt; class Temp &gt;
struct X&lt; T, 0, Temp&lt;T&gt; &gt; { } ;

// エラー、テンプレート仮引数の種類が一致していない。
template &lt; typename T &gt;
struct X&lt; 0, T, T &gt; { } ;
</pre>

<p>
テンプレートテンプレート仮引数の場合は、テンプレートテンプレート仮引数のテンプレート仮引数の数や種類にも対応していなければならない。
</p>

<pre>
// プライマリークラステンプレート
template &lt; template &lt; typename &gt; class Temp &gt;
struct X { } ;

// エラー、テンプレートテンプレート仮引数のテンプレート仮引数の数が一致していない
template &lt; template &lt; typename, typename &gt; class Temp &gt;
struct X&lt; Temp &gt; ;

// エラー、テンプレートテンプレート仮引数のテンプレート仮引数の種類が一致していない
template &lt; template &lt; int &gt; class Temp &gt;
struct X&lt; Temp &gt; ;
</pre>

<p>
可変引数テンプレートの場合は、0個以上の任意の数に特殊化できる。
</p>

<pre>
// プライマリークラステンプレート
template &lt; typename ... &gt;
struct X ;

template &lt; typename T &gt;
struct X&lt; T &gt; ;

template &lt; typename T1, typename T2 &gt;
struct X&lt; T1, T2 &gt; ;

template &lt; typename T1, typename ... Rest &gt;
struct X&lt; T1, Rest ... &gt; ;
</pre>

<p>
部分的特殊化は、プライマリークラステンプレートが宣言された名前空間スコープやクラススコープの外側で宣言できる。
</p>

<pre>
namespace NS
{

template &lt; typename T &gt;
struct Outer
{
    template &lt; typename U &gt;
    struct Inner ;
} ;

}


template &lt; typename T &gt;
template &lt; typename U &gt;
struct NS::Outer&lt; T &gt;::Inner&lt; U * &gt; { } ;
</pre>

<p>
部分的特殊化の宣言中のテンプレートIDの実引数には、いくつかの制限が存在する。
</p>

<p>
非型実引数の式は、部分的特殊化のテンプレート仮引数の識別子のみである時以外は、テンプレート仮引数とか関わってはならない。
</p>

<pre>
template &lt; int I, int J &gt;
struct X ;

// OK、識別子のみ
template &lt; typename I &gt;
struct X&lt; I, I &gt; ;

// エラー、部分的特殊化のテンプレート仮引数が関わる式
template &lt; int I &gt;
struct X&lt; I+1, I+2 > ;
</pre>

<p>
非型実引数の型は、部分的特殊化のテンプレート仮引数に依存してはならない。
</p>

<pre>
template &lt; typename T, T I &gt;
struct X ;

// エラー
template &lt; typename T &gt;
struct X&lt; T, 0 &gt; ;

template &lt; int I, int ( * Array_ptr)[I] &gt;
struct Y ;

int array[5] ;

// エラー
template &lt; int I &gt;
struct Y&lt; I, &amp;array > ;
</pre>

<p>
部分的特殊化の実引数リストは、プライマリークラステンプレートに暗黙的に生成される実引数リストと同一であってはならない。
</p>

<pre>
template &lt; typename T1, typename T2 &gt;
struct X ;

template &lt; typename T1, typename T2 &gt;
struct X&lt; T1, T2 &gt; ;
</pre>

<p>
部分的特殊化のテンプレート仮引数には、デフォルトテンプレート実引数は使えない。
</p>


<p>
部分的特殊化のテンプレート実引数には展開されていない仮引数パックがあってはならない。テンプレート実引数がパック展開ならば、最後に記述されなければならない。
</p>

<pre>
template &lt; typename ... &gt;
struct X ;

// エラー、展開されていない仮引数パック
template &lt; typename T, typename ... Pack &gt;
struct X&lt; T, Pack &gt; ;

// エラー、仮引数パックは最後に記述されなければならない
template &lt; typename T, typename ... Pack &gt;
struct X&lt; Pack ..., T &gt; ;

template &lt; typename ... &gt;
struct wrap { } ;

// OK
template &lt; typename ... Pack, typename T &gt;
struct X&lt; wrap&lt;Pack...&gt;, T > ;
</pre>

<article>
<h1 id="temp.class.spec.matchv"><a href="#temp.class.spec.matchv">クラステンプレートの部分的特殊化の一致度の比較(Matching of class template partial specializations)</a></h1>


<p>
クラステンプレートの部分的特殊化は、直接参照することはできない。クラステンプレートを使った時、プライマリークラステンプレートや部分的特殊化が比較され、最もテンプレート実引数に対して特殊化されたテンプレートが選ばれる。
</p>

<pre>
template &lt; typename T &gt;
struct X { } ; // #1

template &lt; typename T &gt;
struct X&lt; T * &gt; { } ; // #2

template &lt; typename T &gt;
struct X&lt; T const * &gt; { } ; // #3


int main( )
{
    X&lt; int &gt; x1 ; // #1
    X&lt; int * &gt; x2 ; // #2
    X&lt; int const * &gt; x3 ; // #3
}
</pre>

<p>
最適なテンプレートは、テンプレート実引数が、部分的特殊化のテンプレート実引数に、いかに一致しているかを比較することにより選択される。
</p>


<p>
この比較は以下のように行われる。
</p>

<ul>
<li>
<p>
一致する部分的特殊化が、ただひとつだけ発見された場合、その部分的特殊化が選ばれる。
</p>

<pre>
// プライマリークラステンプレート
template &lt; typename T1, typename T2 &gt;
struct X { } ;

// 部分的特殊化
template &lt; typename T1, typename T2 &gt;
struct X&lt; T2, T1 &gt; { } ;

int main( )
{
    X&lt; int, int &gt; x ; // 部分的特殊化が実体化される
}
</pre>

<p>
これは極端な例だが、この例では、部分的特殊化はプライマリーテンプレートと同一ではない。X&lt; int, int &gt;には、プライマリークラステンプレートと部分的特殊化の両方が一致するが、ただひとつの部分的特殊化が一致するために、部分的特殊化が選ばれる。
</p>

<p>
一致する部分的特殊化が一つでもある場合、プライマリークラステンプレートが使われることはない。
</p>

</li>

<li>
<p>
二つ以上の一致する部分的特殊化が発見された場合、<a href="#temp.class.order">半順序</a>の規則により、最も特殊化されている部分的特殊化が選ばれる。もし、他のすべての部分的特殊化よりもさらに特殊化されている部分的特殊化が見つからない場合、結果は曖昧となり、エラーとなる。
</p>

<pre>
template &lt; typename T &gt;
struct X { } ; // #1

template &lt; typename T &gt;
struct X&lt; T const &gt; { } ; // #2

template &lt; typename T &gt;
struct X&lt; T const volatile &gt; { } ; // #3

int main( )
{
    X&lt; int const &gt; x1 ; // #2
    X&lt; int const volatile &gt; x2 ; // #3

    X&lt; int &gt; x3 ; // #1
}
</pre>

<p>
以下のような場合は、曖昧でエラーとなる。
</p>

<pre>
template &lt; typename T1, typename T2 &gt;
struct X { } ;

template &lt; typename T &gt;
struct X&lt; T, int &gt; { } ;

template &lt; typename T &gt;
struct X&lt; int, T &gt; { } ;


int main( )
{
    X&lt; int, int &gt; x ; // エラー、曖昧
}
</pre>

<p>
この例では、プライマリークラステンプレートと、二つの部分的特殊化の、どのテンプレートを使っても実体化できる。ただし、二つ以上の一致する部分的特殊化があるために、プライマリークラステンプレートは使われない。二つの部分的特殊化は、どちらがより特殊化されているとも決定できないので、曖昧となる。
</p>

</li>

<li>
<p>
一致する部分的特殊化が発見されなかった場合、プライマリークラステンプレートが使われる。
</p>


</li>

</ul>


<p>
部分的特殊化が一致するかどうかは、テンプレート実引数から、部分的特殊化のテンプレート実引数を導けるかどうかで判断される。
</p>


<pre>
template &lt; typename T1, typename T2 &gt;
struct X { } ;

template &lt; typename T &gt;
struct X&lt; T, T &gt; { } ; // #1

template &lt; typename T &gt;
struct X&lt; T, int &gt; { } ; // #2

template &lt; typename T1, typename T2 &gt;
struct X&lt; T1 *, T2 &gt; {} ; // #3


int main( )
{
    X&lt; int, int &gt; x1 ; // #1, #2に一致
    X&lt; short, int &gt; x2 ; // #2に一致
    X&lt; int *, int * &gt; x3 ; // #1, #3に一致
    X&lt; int const *, int const * &gt; x4 ; // #1, #3に一致
    X&lt; int *, int &gt; x5 ; // #3に一致

    X&lt; int, short &gt; x6 ; // 一致する部分的特殊化なし
}
</pre>



</article>

<article>
<h1 id="temp.class.order"><a href="#temp.class.order">クラステンプレートの部分的特殊化の半順序(Partial ordering of class template specializations)</a></h1>


<p>
二つのクラステンプレートの部分的特殊化の間で、どちらがより特殊化されているかということを、半順序(partial ordering)という。クラステンプレートの部分的特殊化の半順序は、比較のために部分的特殊化を関数テンプレートに書き換えた上で、関数テンプレートの半順序に従って決定される。
</p>

<p class="todo">
関数テンプレートの半順序へのリンク
</p>

<p>
部分的特殊化の比較のための関数テンプレートへの書き換えは、以下のように行われる。
</p>

<p>
書き換えた関数テンプレートは、元の部分的特殊化と同じテンプレート仮引数を持つ。この関数テンプレートはひとつの仮引数をとる。仮引数の型は、元の部分的特殊化のクラステンプレート名に、テンプレート実引数として、部分的特殊化と同じ記述をしたものである。
</p>


<p>
たとえば、以下のような部分的特殊化の場合は、
</p>

<pre>
template &lt; typename T1, typename T2, typename T3 &gt;
struct X { } ;

template &lt; typename T &gt;
struct X&lt; T, T, T &gt; { } ;
</pre>

<p>
比較用の関数テンプレートへの書き換えは、以下のようになる。
</p>

<pre>
template &lt; typename T &gt;
void f( X&lt; T, T, T &gt; ) ;
</pre>

<p>
以下の二つの部分的特殊化を比較する場合、
</p>

<pre>
template &lt; typename T1, typename T2, typename T3 &gt;
struct X { } ;

// #1
template &lt; typename T1, typename T2 &gt;
struct X&lt; T1, T1, T2 &gt; { } ;

// #2
template &lt; typename T &gt;
struct X&lt; T, T, T &gt; { } ;
</pre>

<p>
以下のように、関数テンプレートに書き換えられて、関数テンプレートの半順序により判断される。
</p>

<pre>
// #1
template &lt; typenmame T1, typename T2 &gt;
void f( X&lt; T1, T1, T2 &gt; ) ;

// #2
template &lt; typename T &gt;
void f( X&lt; T, T, T &gt; ) ;
</pre>

<p>
この例では、#2の方がより特殊化されている。
</p>

</article>

<article>
<h1 id="temp.class.spec.mfunc"><a href="#temp.class.spec.mfunc">クラステンプレートの特殊化のメンバー</a></h1>

<p>
プライマリークラステンプレートと部分的特殊化の間は別物である。それぞれ異なるメンバーの宣言と定義を持つ。
</p>

<pre>
template &lt; typename T &gt;
struct X
{
    void foo() ;
} ;

template &lt; typename T &gt;
struct X&lt; T * &gt;
{
    void bar() ;
} ;

int main()
{
    X&lt; int &gt; x1 ;
    x1.foo() ; // OK
    x1.bar() ; // エラー

    X&lt; int * &gt; x2 ;
    x2.foo() ; // エラー
    x2.bar() ; // OK
} 
</pre>



<p>
部分的特殊化のメンバーをクラススコープの外で定義する場合、部分的特殊化と同じテンプレート仮引数とテンプレート実引数を使わなければならない。
</p>

<pre>
template &lt; typename T &gt;
struct X ;

template &lt; typename T &gt;
struct X&lt; T * &gt;
{
    // メンバーの宣言
    void bar() ;
} ;

// メンバーの定義
template &lt; typename T &gt;
void X&lt; T * &gt;::bar() { }
</pre>

<p>
メンバーテンプレートも部分的特殊化できる。
</p>

<pre>
template &lt; typename T &gt;
struct class_template
{
    // プライマリーメンバークラステンプレート
    template &lt; typename U &gt;
    struct member_template { } ;

    // 部分的特殊化
    template &lt; typename U &gt;
    struct member_template&lt; U * &gt; { } ;
} ;
</pre>

</article>

</article>

<article>
<h1 id="temp.fct"><a href="#temp.fct">関数テンプレート(Function templates)</a></h1>

<p>
関数テンプレートは、特定の型にとらわれない関数のテンプレートを記述できる。
</p>

<pre>
template &lt; typename T &gt;
void f( T param ) { }
</pre>

<p>
関数テンプレートは、クラステンプレートと同じように、テンプレート実引数を指定して実体化させ、呼び出すことができる。
</p>

<pre>
template &lt; typename T &gt;
void f( T param ) { }

int main( )
{
    f&lt;int&gt;( 0 ) ;
    f&lt;double&gt;( 0.0 ) ;
}
</pre>

<p>
関数テンプレートは、テンプレート実引数を指定せずに呼び出すことができる。この場合、関数の実引数から、テンプレート実引数が導かれる。これを、実引数推定(Argument Deduction)という。
</p>

<pre>
template &lt; typename T &gt;
void f( T param ) { }

int main( )
{
    f( 0 ) ; // f&lt;int&gt;
    f( 0.0 ) ; // f&lt;double&gt;
}
</pre>

<p>
実引数推定できない場合、エラーとなる。
</p>

<pre>
template &lt; typename T &gt;
void f( T * param ) { }

int main( )
{
    f( 0 ) ; // エラー、実引数推定できない
}
</pre>

<p>
より詳しくは、<a href="#temp.deduct">テンプレートの実引数推定</a>を参照。
</p>

</article>

<article>
<h1 id="temp.over.link"><a href="#temp.over.link">関数テンプレートのオーバーロード(Function Template Overloading)</a></h1>

<p>
関数テンプレートはオーバーロードできる。オーバーロードは、関数テンプレートと通常の関数の区別なく記述できる。
</p>

<pre>
template &lt; typename T &gt;
void f( T ) ;

template &lt; typename T &gt;
void f( T * ) ;

void f( int ) ;
</pre>


<p>
異なる複数の関数テンプレートが同じテンプレート実引数に対して実体化できる場合、それぞれ異なる実態を持つので、ODR違反とはならない。
</p>

<p>
たとえば、ある一つのプログラムを構成する二つのソースファイルがあり、それぞれ以下のように記述されていたとする。
</p>

<pre>
// ソースファイル1
template &lt; typename T &gt;
void f( T ) { }

void g( int * p )
{
    f( p ) ;
}
</pre>

<pre>
// ソースファイル2
template &lt; typename T &gt;
void f( T * ) { }

void h( int * p )
{
    f( p ) ;
}
</pre>

<p>
この場合、それぞれのテンプレートから、それぞれ実体化が行われ、異なる特殊化が使われる。ODR違反とはならない。
</p>


<p>
関数テンプレートのオーバーロードは、実体化された特殊化が、全く同じシグネチャであっても構わない。
</p>

<pre>
template &lt; typename T &gt; void f( ) ;
template &lt; int I &gt; void f( ) ;
</pre>

<p>
テンプレート仮引数が、関数テンプレートの仮引数リストや戻り値の型における式の中で参照された場合、その式は関数テンプレートのシグネチャの一部になる。これにより、式の違いによる異なる関数テンプレートを記述できる。
</p>

<pre>
template &lt; int I &gt;
struct X { } ;

template &lt; int I, int J &gt;
X&lt; I + J &gt; f( X&lt;I&gt;, X&lt;J&gt; ) ; // #1の宣言

template &lt; int K, int L &gt;
X&lt; K + L &gt; f( X&lt;K&gt;, X&lt;L&gt; ) ; // #1の再宣言

template &lt; int I, int J &gt;
X&lt; I - J &gt; f( X&lt;I&gt;, X&lt;J&gt; ) ; // #2、これは#1とは異なる宣言
</pre>

<p>
最初の二つの関数テンプレートは、同一の関数テンプレートである。しかし、#2は式が違うため、異なる関数テンプレートである。
</p>

<p>
この時、シグネチャの式を評価した結果が同じものを、「機能的に同一」という。シグネチャの式が同じものを「同一」という。機能的に同一だが、同一ではない二つの宣言がある場合、エラーとなる。
</p>

<pre>
template &lt; int I &gt;
struct X { } ;

template &lt; int I &gt;
void f( X&lt; I + 2 &gt; ) ;

template &lt; int I &gt;
void f( X&lt; I + 1 + 1 &gt; ) ; // エラー、機能的に同一だが、シグネチャの式が同一ではない
</pre>

<p>
ただし、規格上、実装はこの誤りを検出して報告する必要はない。したがって、このエラーはコンパイルで見つけることは期待できない。よく注意しなければならない。
</p>

</article>

<article>
<h1 id="temp.func.order"><a href="#temp.func.order">関数テンプレートの部分的特殊化(Partial ordering of function templates)</a></h1>

<p>
関数テンプレートがオーバーロードされている場合、どの関数テンプレートの特殊化を使うべきなのか曖昧になる。
</p>

<pre>
template &lt; typename T &gt;
void f( T ) { } // #1

template &lt; typename T &gt;
void f( T * ) { } // #2
 
int main()
{
    int * p = nullptr ;
    f( p ) ; // #2の特殊化が呼ばれる

    void ( *fp ) ( int * ) = &amp;f ; // #2の特殊化のアドレスを得る
}
</pre>

<p>
以下の文脈の場合、半順序(partial ordering)によって、最も特殊化されているテンプレートを決定する。
</p>

<ul>
<li>関数テンプレートの特殊化を呼び出す際のオーバーロード解決</li>
<li>関数テンプレートの特殊化のアドレスを取得するとき</li>
<li>プレイスメントoperator newに一致するプレイスメントoperator deleteを選択するとき</li>
<li>
<p>
friend関数宣言、明示的実体化、明示的特殊化が、ある関数テンプレートの特殊化を参照しているとき
</p>

<pre>
template &lt; typename T &gt;
void f( T ) { } // #1

template &lt; typename T &gt;
void f( T * ) { } // #2

class X
{
    int data ; 
    template &lt; typename T &gt;
    friend void f( T ) ; // #1をfriendに指定
} ;

// #2の明示的実体化
template void f( int * ) ;


// #1の明示的特殊化
template &lt; &gt;
void f&lt;double&gt;( double ) { }
</pre>
</li>
</ul>

<p>
半順序は、二つのテンプレートを、後述する方法によって変換して関数型とし、テンプレート実引数推定をして、どちらがより特殊であるかを選ぶ。
</p>

<p class="todo">
完全に理解してから書く。
</p>

</article>


<article>
<h1 id="temp.alias"><a href="#temp.alias">エイリアステンプレート(Alias templates)</a></h1>

<p>
宣言部分がエイリアス宣言のテンプレート宣言を、エイリアステンプレートと呼ぶ。エイリアステンプレートは、複数の型名をテンプレート化することができる。いわば、typedefのテンプレート版とも言える。
</p>

<pre>
template &lt; typename T &gt;
struct wrap { } ;

template &lt; typename T &gt;
using Alias = wrap&lt;T&gt; ;

Alias&lt;int&gt; t1 ; // wrap&lt;int&gt;
Alias&lt;double&gt; t2 ; // wrap&lt;double&gt;
</pre>

<p>
エイリアステンプレートによって宣言されたテンプレートIDは、エイリアスされた型の別名として使うことができる。エイリアステンプレートのテンプレートIDは、typedef名と同じく、型の別名であり、別の型ではない。Alias&lt;int&gt;は、wrap&lt;int>と同一の型である。
</p>

<p>
エイリアステンプレートの利用例を挙げる。
</p>

<pre>
template &lt; typename T, typename U &gt;
struct wrap
{
    using type = T ;
} ;

template &lt; typename T &gt;
using a1 = wrap&lt; T, int &gt; ;
using t1 = a1&lt;int&gt; ; // wrap&lt; int, int &gt;

template &lt; typename T &gt;
using a2 = wrap&lt; T, T &gt; ;
using t2 = a2&lt; int &gt; ; // wrap&lt; int, int &gt;

template &lt; typename T &gt;
using a3 = typename wrap&lt; T, void &gt;::type ;
using t3 = a3&lt;int&gt; ; // wrap&lt; int, void&gt;::type、すなわちint
</pre>

<p>
エイリアステンプレートは、その利用方法はさておき、以下のような記述もできる。
</p>

<pre>
template &lt; typename T &gt;
using a1 = T ; // a1&lt;T&gt;はTの別名

template &lt; typename T &gt;
using a2 = int ; // a2&lt;T&gt;はintの別名
</pre>

<p>
エイリアステンプレートは、テンプレート実引数の一部のみ指定し、残りをテンプレート化することができる。その利用方法は、例えば、カスタムアロケーターを指定したコンテナーテンプレートの別名を宣言できる。
</p>

<pre>
class MyAlloc ;

template &lt; typename T &gt;
using MyVec = std::vector&lt; T, MyAlloc &gt; ;
</pre>

<p>
従来のtypedef宣言では、これができない。
</p>

<p>
エイリアステンプレートは、名前通りテンプレートであるので、名前空間スコープかクラススコープの内側でしか宣言できない。たとえば、関数のブロックスコープの内側では宣言できない。
</p>

<pre>
void f()
{// 関数のブロックスコープ
    template &lt; typename T &gt; using A = T : // エラー
}
</pre>

<p>
エイリアステンプレート宣言内のテンプレートIDは、宣言中のエイリアステンプレートを参照してはならない。つまり、宣言中に自分自身の特殊化を使ってはならないという事である。
</p>

<pre>
template &lt; typename T &gt; struct A ;
template &lt; typename T &gt; using B = typename A&lt;T&gt;::U;
template &lt; typename T &gt; struct A
{
    typedef B&lt;T&gt; U;
} ;

// エラー、B&lt;int&gt;の実体化の際に、A&lt;int&gt;::Uとして、自分自身を使ってしまう。
B&lt;int&gt; b;
</pre>



</article>

</article>

<article>
<h1 id="temp.res"><a href="#temp.res">名前解決(Name Resolution)</a></h1>

<p>
テンプレート定義内での名前解決は非常に複雑である。これは、テンプレートはある場所で宣言され、別の場所で特殊な形に実体化されるからである。
</p>

<p>
テンプレート定義内では、三種類の名前がある。
</p>

<ul>
<li>テンプレート自身の名前、テンプレートで宣言された名前</li>
<li>テンプレート仮引数に依存する名前</li>
<li>テンプレート定義のあるスコープから見える名前</li>
</ul>

<p>
「テンプレート自身の名前、テンプレートで宣言された名前」というのは、テンプレート名と、テンプレート仮引数名である。
</p>

<p>
「テンプレート仮引数に依存する名前」は、依存名(Dependent Name)と呼ばれている。
</p>

<p>
「テンプレート定義のあるスコープから見える名前」とは、テンプレート定義のあるスコープやその外側のスコープで、すでに宣言された名前のことだ。
</p>

<p>
テンプレート仮引数に依存する名前は、暗黙に型を意味しないものと解釈される。
</p>

<pre>
template &lt; typename T &gt;
void f()
{
    int x = T::value ; // T::valueは型ではない
}
</pre>

<p>
この場合、Tに与えられるテンプレート実引数には、例えば以下のようなものが想定されている。
</p>

<pre>
struct X
{
    static constexpr int value = 0 ;
} ;
</pre>

<p>
テンプレート宣言や定義で、テンプレート仮引数に依存する名前を型として使おうとしてもエラーとなる。なぜならば、すでに述べたように、暗黙に型を意味しないものと解釈されるからだ。
</p>

<p>
template &lt; typename T &gt;
void f()
{
    typedef T::type type ; // エラー、T::typeは型ではない
}
</p>

<p>
依存名を型であると解釈させるには、明示的に、名前の直前に、typenameキーワードを記述して修飾しなければならない。
</p>

<pre>
template &lt; typename T &gt;
void f()
{
    typedef typename T::type type ; // OK、T::typeは型
}
</pre>

<p>
ただし、メンバー初期化子と基本クラス指定子には、文法上型しか記述できないので、typenameで修飾する必要はない。
</p>

<pre>
template &lt; typename T &gt;
struct X : T::type // OK
{
    X() : T::type // OK
    { } 
} ;
</pre>

<p>
また、メンバーテンプレートは、文脈により、テンプレートかどうかが曖昧になる。
</p>

<pre>
// Tに渡す型の例
struct X
{
    template &lt; typename T >
    void func() ;
} ;

template &lt; typename T &gt;
void f()
{
    T t ;
    t.func&lt;int&gt;(0) ; // エラー
}
</pre>

<p>
このコードの意味は、t.funcとintに、比較演算子である&lt;を適用し、さらに比較演算子&gt;とかっこに囲まれた0を適用するものである。メンバー関数テンプレートの特殊化を呼び出すものではない。
t.funcとintを&lt;演算子で比較するのは、文法上認められていないので、このコードはエラーになる。
</p>

<p>
依存名に.や-&gt;、あるいは::を用い、メンバーテンプレートの特殊化を記述する場合は、メンバーテンプレートは、templateキーワードで修飾しなければならない。これは、メンバー名がテンプレートであると明示的に解釈させるためである。
</p>

<pre>
// Tに渡す型の例
struct X
{
    template &lt; typename T &gt;
    struct MemberClass ;

    template &lt; typename T &gt;
    void MemberFunction() ;
} ;

template &lt; typename T &gt;
void f()
{
    typedef typename T:: template MemberClass&lt;int&gt; obj ;

    T t ;
    t. template MemberFunction&lt;int&gt;() ;

    T * p = &amp;t ;
    p-&gt; template MemberFunction&lt;int&gt;() ;
}
</pre>

<p>
これはメンバーテンプレートの特殊化を使う場合であって、メンバー関数テンプレートを実引数推定させて使う場合には、templateキーワードを記述する必要はない。
</p>

<pre>
// Tに渡す型の例
struct X
{
    template &lt; typename T &gt;
    void MemberFunction( T ) ;
} ;

template &lt; typename T &gt;
void f()
{
    T t ;
    t.MemberFunction( 0 ) ; // OK
}
</pre>

<p>
templateキーワードの指定は、実際には文法の曖昧性の問題であって、名前解決の問題ではないのだが、typenameキーワードの指定と似ているために、便宜上、本書では同時に説明することにした
</p>

<article>
<h1 id="dependent-name"><a href="#dependent-name">依存(Dependent)</a></h1>

<p>
依存(Dependent)とは、テンプレート仮引数に依存することである。テンプレート仮引数に依存するものは、名前と式とテンプレート実引数である。式とテンプレート実引数には、型依存式と値依存式が存在する。
</p>

<p>
なぜテンプレート仮引数に依存しているかどうかが問題になるのか。テンプレート仮引数というのは、具体的な内容が確定していない存在だからだ。テンプレートは、実体化されて初めて、その具体的な内容が確定する。
</p>

<pre>
依存の詳細は煩雑になるので省略するが、簡略化していえば、テンプレート仮引数が関わる名前や式は、すべて依存している。
</pre>


<pre>
void f( int ) ;

template &lt; typename T &gt;
struct identity
{
    using type = T ;
} ;

template &lt; typename T &gt;
struct X
{
    int data ;

    void member()
    {
        T t1 ; // Tは依存名
        T::value ; // 依存している。値と解釈される
        typename T::type t2 ; // 依存している。型と解釈される

        f( 0 ) ; // 依存していない

        &amp;X::data ; // 依存している
        this-&gt;data ; / 依存している

        typename identity&lt;T&gt;::type t ; // 依存している
    } 
} ;
</pre>

<p>
クラステンプレートの場合、クラス名やthisを介した式も、テンプレート仮引数に依存している。なぜならば、クラステンプレートの場合、クラス名自体がテンプレート仮引数に依存しているからだ。
</p>

<p>
依存していない名前や式を、非依存(Non-dependent)という。
</p>

</article>

<article>
<h1 id="non-dependent-name-resolution"><a href="#non-dependent-name-resolution">非依存名の名前解決</a></h1>

<p>
非依存名は、テンプレートが定義されている場所で名前解決される。
</p>

<pre>
void f( int ) ;


template &lt; typename T &gt;
void g()
{
    f( 0 ) ; // f(int)
}

void f( double ) ;


int main()
{
    g&lt;int&gt;() ;

}
</pre>

<p>
このコードの解釈は驚くにあたらない。ただし、状況によっては、意図しないことが起こる。
</p>

<pre>
// Derivedのテンプレート仮引数Baseが想定している型
struct Base
{
    void member() { }
} ;


template &lt; typename Base &gt;
struct Derived : Base
{
    void f()
    {
        member() ; // エラー、memberが見つからない
    }

} ;
</pre>

<p>
この、テンプレートクラス、Derivedは、テンプレート仮引数を基本クラスに指定している。そして、基本クラスはmemberという名前のメンバー関数を持っていることを期待している。Derived::f内で使われている、memberという名前は、非依存名であり、しかも非修飾名なので、メンバー関数であるとは解釈されない。そのため、外側のスコープのmemberという名前を探すが、見つからないためエラーになる。
</p>

<p>
このようなコードで、memberをメンバーとして扱いたい場合、memberを修飾して依存名にする必要がある。それには、三種類の方法がある。
</p>

<pre>
template &lt; typename Base &gt;
struct Derived : Base
{
    void f()
    {
        Derived::member() ; // OK、クラス名は依存名
        this-&gt;member() ; // OK、thisは依存式
        Base::member() ; // OK、テンプレート仮引数は依存名
    }

} ;
</pre>

</article>

<article>
<h1 id="dependent-name-resolution"><a href="#dependent-name-resolution">依存名の名前解決</a></h1>

<p>
依存名の名前解決は、実体化場所(Point of Instantiation)が重要になる。
</p>

<p>
実体化場所とは、テンプレートが実体化された場所のことである。
</p>

<p>
template &lt; typename T &gt;
void f( T ) { } // テンプレートの定義

struct Foo { } ;

int main()
{
    Foo foo ;
    f( foo ) ; // 実体化場所
}
</p>

<p>
依存名の名前解決は、テンプレートの定義ではなく、実体化場所で行われるので、テンプレートの定義の時点では見えていない、Fooという名前も使うことができる。また、テンプレートの定義中で、テンプレート仮引数のメンバー名やネストされた型名を参照しても、実体化の結果が一致しているならば、名前解決できる。
</p>

<p>
テンプレートの名前解決の理解を難しくしているのは、オーバーロード解決における、候補関数の見え方である。
</p>

<p>
非修飾名前解決と修飾名前解決を使った候補関数は、テンプレートの定義場所から見える名前のみに制限される。
</p>

<pre>
void f( int ) { }

// テンプレートの定義
template &lt; typename T &gt;
void call( )
{
    f( 0.0 ) ; // 候補関数はf(int)のみ
} 

void f( double ) { }

int main()
{
    call&lt;void&gt;() ; // 実体化場所
}
</pre>

<p>
このように、候補関数の非修飾名前解決と修飾名前解決は、実体化場所で行われるものの、発見される名前は、テンプレートの定義場所から見える名前のみに限定されているため、。上記の例では、もし、f(double)が候補関数に含まれていたならば、そちらが最適関数だが、候補関数として発見されないために、最適関数になることもない。
</p>

<p>
同様に、以下の例はエラーとなる。
</p>

<pre>
// テンプレートの定義
template &lt; typename T &gt;
void call( )
{
    f( 0 ) ; // エラー、名前fが見つからない
} 

void f( int ) { }

int main()
{
    call&lt;void&gt;() ; // 実体化場所
}
</pre>

<p>
ただし、ADLの場合は、例外的に異なる。ADLが発動した場合は、テンプレートの実体化場所から見える候補関数が発見される。
</p>

<pre>
// グローバル名前空間

// クラスFooの関連名前空間はグローバル名前空間
struct Foo { } ;

// テンプレートの定義
template &lt; typename T &gt;
void call_f( T t )
{
    f( t ) ;
} 

// グローバル名前空間内の名前
void f( Foo ) { }

int main()
{
    Foo foo ;
    call_f( foo ) ; // OK、ADLが発動
}
</pre>

<p>
この場合、関数call_f内で呼び出している非修飾名fは、非修飾名前解決では見つからないため、ADLが発動する。
</p>

<p>
これはADLが発動する場合のみの例外的なルールである。ADLが発動しない場合は、このような例外的な挙動にはならない。
</p>

<pre>
struct Foo { } ;

void f( Foo const &amp; ) { } // #1

template &lt; typename T &gt;
void call_f( T t )
{
    f( t ) ;
} 

void f( Foo &amp; ) { } // #2

int main()
{
    Foo foo ;
    call_f( foo ) ; // ADLは発動しない。#1が呼ばれる
}
</pre>

<p>
この場合では、非修飾名前解決により、#1が、名前fとして見つかるため、ADLは発動しない。ADLが発動しないので、#2が候補関数に選ばれることもない。もし、#2が候補関数に選ばれていたならば、オーバーロード解決により、#2は#1より最適な関数となるが、ADLが発動しない以上、#2は発見されず、したがって候補関数にもならない。
</p>

<p>
また、基本型には、関連名前空間が存在しないため、ADLは発動しない。
</p>

<p>
このように、テンプレート内の名前は、テンプレートの定義場所と、実体化場所で、二段階に分けて名前解決されるので、二段階名前解決(Two Phase Lookup)と呼ばれている。
</p>

</article>

</article>

<article>
<h1 id="temp.spec"><a href="#temp.spec">テンプレートの実体化と特殊化(Template instantiation and specialization)</a></h1>

<p>
テンプレートは、テンプレート実引数を与えられて実体化して始めて利用可能になる。これをテンプレート実体化(template instantiation)という。実体化には、暗黙の実体化と明示的な実体化がある。実体化したテンプレートのことを、特殊化(specialization)という。特殊化は、明示的に行うこともできる。テンプレートの部分的特殊化は、名前が似ているが、いまだにテンプレートであって、実体化された特殊化ではない。
</p>

<article>
<h1 id="temp.inst"><a href="#temp.inst">暗黙の実体化(Implicit instantiation)</a></h1>

<p>
明示的に実体化されず、明示的に特殊化されていないテンプレートは、オブジェクトの完全な型が必要な場合や、クラス型が完全であることがプログラムの意味に影響を与える文脈で参照された場合に、暗黙に実体化される。
</p>

<p>
クラステンプレートが暗黙に実体化されても、クラステンプレートのメンバーまで暗黙に実体化されるわけではない。
</p>

<pre>
template &lt; typename T &gt;
struct X
{
    void f() ;
    void g() ;
} ;


int main()
{
    typedef X&lt; int &gt; type ; //  X&lt;int&gt;の実体化は必要ない
    type a ; // X&lt;int&gt;の実体化が必要
    X&lt; char &gt; * b ; // X&lt;char&gt;の実体化は必要ない
    X&lt; double &gt; * p ; // X&lt;double&gt;の実体化は必要ない

    a.f() ; // X&lt;int&gt;::f()の実体化が必要
    b-&gt;f() ; // X&lt;char&gt;::f()の実体化が必要
}
</pre>

<p>
typedef名やポインター型の宣言は、クラスの完全な型が必要な文脈ではないので、テンプレートの暗黙の実体化は起こらない。
</p>
<p>
X&lt;char&gt;や X&lt;double&gt;の実体化が必要ないのは、クラスへのポインターを参照しているだけなので、クラスの完全な型が必要な文脈ではないからである。また、X&lt;int&gt;::g()やX&lt;double&gt;::g()も、参照されていないので実体化はされない。
</p>

<p>
関数テンプレートも、定義が必要な文脈で参照されなければ、暗黙に実体化されることはない。
</p>

<p>
実体化の必要のないクラステンプレートのメンバーが暗黙的に実体化されないという挙動は、規格上保証されている。
</p>

<p>
テンプレートが暗黙に実体化される場合、暗黙的な実体化が必要ない場合、また例外的に暗黙的に実体化されるかどうかが未規定の場合の詳細な解説は、煩雑になるので省略する。
</p>


</article>

<article>
<h1 id="temp.explicit"><a href="#temp.explicit">明示的実体化(Explicit instantiation)</a></h1>

<p>
クラス、関数、メンバーテンプレートの特殊化は、テンプレートから明示的に実体化できる。メンバー関数、メンバークラス、クラステンプレートのstaticデータメンバーは、クラステンプレートのメンバーの定義として、明示的に実体化できる。これを明示的実体化(Explicit instantiation)という。
</p>

<p>
明示的実体化を宣言する文法は、以下の通りである。
</p>

<pre>
extern<sub>省略可</sub> template 宣言
</pre>


<p>
externキーワードは省略できる。externキーワードの有無に意味上の違いはない。C++03までの規格では、externキーワードを使った文法は、明示的実体化の宣言ではなく、内部リンケージの宣言になり、プログラムの意味が変わってしまうので、注意が必要である。本書はC++11の規格のみを取り扱う。
</p>

<p>
クラス、もしくはメンバークラスに対する明示的実体化の場合、宣言中のクラス名はテンプレート実引数を指定した形で指定する。
</p>

<pre>
template &lt; typename T &gt;
struct X { } ;

// X&lt;int&gt;の明示的実体化
extern template struct X&lt; int &gt; ;
</pre>

<p>
externキーワードは省略できるので、上記の明示的実体化は、以下のように書くこともできる。
</p>

<pre>
template struct X&lt; int &gt; ;
</pre>


<p>
関数、もしくはメンバー関数に対する明示的実体化の場合、宣言中の関数名は、テンプレート実引数を指定しているか、引数リストからテンプレート実引数が推定できる形で指定する。
</p>


<pre>
template &lt; typename T &gt;
void f( T ) { }

// f&lt;int&gt;の明示的実体化
extern template void f&lt; int &gt;( int ) ;

template &lt; typename T &gt;
void g( T ) { }

// g&lt;int&gt;の明示的実体化
extern template void g( int ) ;
// 以下と同等
// extern template void g&lt; int &gt;( int ) ;
</pre>

<p>
クラスのメンバーに対する明示的実体化の場合は、メンバーの属するクラス名はテンプレート実引数を指定した形で指定する。
</p>

<pre>
template &lt; typename T &gt;
struct X
{
    void f() { }
} ;

extern template void X&lt;int&gt;::f() ;
</pre>

<p>
同じテンプレートとテンプレート実引数に対する明示的実体化は、プログラム中に一度しか現れてはならない。つまり、複数のソースファイルからなるプログラム全体でも、一度しか現れてはならない。規格上、実装はこの違反を検出できるよう規定されてはいないので、実装の出力するコンパイル時、実行時のエラーや警告のメッセージに頼ることは出来ない。
</p>


<p>
関数テンプレート、メンバー関数、クラステンプレートのstaticデータメンバーは、明示的実体化の前に宣言されていなければならない。
</p>

<pre>
// エラー、前方に宣言がない
extern template void f&lt;int&gt;() ;

template &lt; typename T &gt; void f() ;
</pre>

<p>
クラステンプレート、クラステンプレートのメンバークラス、メンバークラステンプレートは、明示的実体化の前に定義されていなければならない。
</p>

<pre>
template &lt; typename T &gt;
struct X ; // 宣言

// エラー、クラステンプレートXは前方で定義されていない
extern template struct X&lt;int&gt; ;

template &lt; typename T &gt;
struct X { } ; // 定義
</pre>

<p>
明示的実体化で、暗黙に宣言された特別なメンバー関数を指定した場合、エラーとなる。
</p>

<pre>
template &lt; typename T &gt;
struct X { } ;

// エラー、暗黙に宣言されたコンストラクター
extern template X&lt;int&gt;::X() ;

template &lt; typename T &gt;
struct Y
{
    Y() { } // 明示的な宣言
} ;

// OK
extern template Y&lt;int&gt;::Y() ; 
</pre>

<p>
同じテンプレート実引数の明示的特殊化の宣言の後に明示的実体化の宣言が現れた場合、明示的実体化は無効となる。これはエラーではない。
</p>

<pre>
template &lt; typename T &gt;
struct X { } ;

// X&lt;int&gt;に対する明示的特殊化
template &lt; &gt;
struct X&lt;int&gt; { } ;

// X&lt;int&gt;に対する明示的実体化。
// 無効、エラーではない
extern template struct X&lt;int&gt; ;
</pre>

<p>
同じテンプレート実引数に対する明示的特殊化の前に明示的実体化が現れた場合はエラーである。
</p>

<p>
明示的実体化を使えば、プログラム中のテンプレートを必要とするソースファイルすべてにトークン列が一致するテンプレートの完全な定義を持ち込む必要がなくなる。
</p>

<pre>
// func.h
// 関数テンプレートfuncの宣言
template &lt; typename T &gt;
void func( T ) ;
</pre>

<pre>
// func.cpp
// 関数テンプレートfuncの定義
#include &lt;func.h&gt;

template &lt; typename T &gt;
void func( T ) { }

// プログラム中で使われる実体化を明示的に宣言
extern template void func( int ) ;
extern template void func( double ) ;
</pre>

<pre>
// main.cpp

// このソースファイルmain.cppには、
// 関数テンプレートfuncの宣言のみ導入
#include &lt;func.h&gt;

int main()
{
    func( 0 ) ; // OK、プログラム中で明示的実体化されている
    func( 0.0 ) ; // OK、プログラム中で明示的実体化されている

    func ( 'a' ) ; // エラー、定義がないため、実体化できない。
}
</pre>

<p>
C++におけるテンプレートは、トークン列が一致するコード片を、テンプレートの特殊化を必要とするプログラム中のソースファイルすべてに持ち込むことで、ODRを例外的に回避している。明示的実体化を使えば、テンプレートの宣言と定義を分離し、すべてのソースファイルに定義を持ち込む必要がなくなる。ただし、明示的に実体化したテンプレートとそのテンプレート実引数に限定される。
</p>

</article>

<article>
<h1 id="temp.expl.spec"><a href="#temp.expl.spec">明示的特殊化(Explicit specialization)</a></h1>

<p>
テンプレートはあるテンプレート実引数について、元となるテンプレートとは別に、明示的に特殊化することができる。これを明示的特殊化(Explicit specialization)という。明示的特殊化を使うと、ある与えられたテンプレート実引数に対しては、汎用のテンプレートから実体化される特殊化は異なる特殊化を与えることができる。明示的特殊化と、部分的特殊化は、名前は似ているは全くの別物である。
</p>

<p>
明示的特殊化の文法は以下の通り。
</p>

<pre>
template &lt; &gt; 宣言
</pre>

<pre>
template &lt; typename T &gt;
bool f( T ) { return false ; }

// 明示的特殊化
template &lt; &gt;
bool f( int ) { return true ; }

int main()
{
    f( 0 ) ; // true
    f( 0.0 ) ; // false
    f( 'a' ) ; // false
}
</pre>

<p>
この例では、関数テンプレートfにテンプレート実引数intを与えた場合だけ、元のテンプレート定義とは別の、明示的特殊化による定義を使用する。そのため、f&lt;int&gt;はtrueを返す。
</p>

<p>
明示的特殊化は、元のテンプレートの定義の影響を受けない。たとえば、関数テンプレートの場合は戻り値の型を異なるものにできるし、クラステンプレートの場合、クラスのメンバーを全く違ったものにすることもできる。
</p>

<pre>
template &lt; typename T &gt;
struct X
{
    void f() { }
} ;

template &lt; &gt;
struct X&lt;int&gt;
{
    void g() ;
}
</pre>

<p>
この例では、元のテンプレートの定義であるメンバー関数X::fがなく、全く別名のメンバー関数gを定義している。
</p>

<p>
明示的特殊化できるテンプレートは、以下の通り。
</p>

<ul>
<li>
<p>関数テンプレート</p>

<pre>
template &lt; typename T &gt;
void f( T ) { }

// 明示的特殊化
template &lt; &gt;
bool f( int ) { return true ; }

// 明示的なテンプレート実引数の指定によるもの
template &lt; &gt;
void f&lt;short&gt;( short ) { }
</pre>
</li>

<li>
<p>
クラステンプレート
</p>

<pre>
template &lt; typename T &gt;
struct X { } ;

// 明示的特殊化
template &lt; &gt;
struct X&lt;int&gt;
{
    int data ;
} ;
</pre>
</li>

<li>
<p>
クラステンプレートのメンバー関数
</p>

<pre>
template &lt; typename T &gt;
struct X
{
    void f() { }
    void g() { }
    int data ;
} ;

// ひとつのメンバー関数のみを明示的特殊化
template &lt; &gt;
bool X&lt;int&gt;::f() { return true ; }
</pre>

<p>
クラステンプレートのメンバー関数を個別に明示的特殊化することができる。この場合、クラステンプレートXにテンプレート実引数intを与えて実体化させた特殊化は、X::fのみ明示的特殊化の定義を使い、残りのメンバーはテンプレートから実体化された特殊化を使う。
</p>

</li>

<li>
<p>
クラステンプレートのstaticデータメンバー
</p>

<pre>
template &lt; typename T &gt;
struct X
{
    static int data ; // 宣言
} ;

template &lt; typename T &gt;
int X&lt;T&gt;::data ; // 定義

// 明示的特殊化
template &lt; &gt;
int X&lt;int&gt;::data ;
</pre>

<p>
クラステンプレートのstaticデータメンバーの明示的特殊化は、宣言の型を変えることはできない。
</p>

<pre>
template &lt; typename T &gt;
struct X
{
    static int d1 ;
    static T d2 ;
} ;

// 汎用的な定義
template &lt; typename T &gt;
int X&lt;T&gt;::data = 0 ;


template &lt; &gt;
double X&lt;int&gt;::d1 ; // エラー、型が宣言と一致しない

template &lt; &gt;
double X&lt;int&gt;::d2 ; // エラー、型が宣言と一致しない
</pre>

<p>
ただし、初期化式を変えることはできる。
</p>

<pre>
template &lt; typename T &gt;
struct X
{
    static int data ;
} ;

template &lt; typename T &gt;
int X&lt;T&gt;::data = 0 ;

template &lt; &gt;
int X&lt;int&gt;::data = 1 ;

template &lt; &gt;
int X&lt;double&gt;::data = 2 ;
</pre>


</li>

<li>
<p>
クラステンプレートのメンバークラス
</p>

<pre>
template &lt; typename T &gt;
struct Outer
{
    struct Inner { /* 定義 */ } ;
} ;

// 明示的特殊化
template &lt; &gt;
struct Outer&lt;int&gt;::Inner
{
// 定義
} ;
</pre>
</li>


<li>
<p>
クラステンプレートのメンバーenum
</p>

<pre>
template &lt; typename T &gt;
struct X
{
    enum struct E { foo, bar } ;
} ;

// 明示的特殊化
template &lt; &gt;
enum struct X&lt;int&gt;::E
{
    hoge, moke
} ;
</pre>
</li>

<li>
<p>
クラス、あるいはクラステンプレートのメンバークラステンプレート
</p>

<pre>
// クラス
struct Outer_class
{
    template &lt; typename T &gt;
    struct Inner_class_template { } ;
} ;

// 明示的特殊化
template &lt; &gt;
struct Outer_class::Inner_class_template&lt;int&gt;
{
// 定義
} ;

// クラステンプレート
template &lt; typename T &gt;
struct Outer_class_template
{
    template &lt; typename U &gt;
    struct Inner_class_template { } ;
} ;

// 明示的特殊化
template &lt; &gt; // Outer_class_templateの明示的特殊化
template &lt; &gt; // Inner_class_templateの明示的特殊化
struct Outer_class_template&lt;int&gt;::Inner_class_template&lt;int&gt;
{
// 定義
} ;
</pre>

<p>
クラス、クラステンプレートを問わず、メンバークラステンプレートの明示的特殊化ができる。
</p>
</li>

<li>
<p>
クラス、あるいはクラステンプレートのメンバー関数テンプレート
</p>

<pre>
// クラス
struct Outer_class
{
    template &lt; typename T &gt;
    void member_function_template() { }
} ;

// 明示的特殊化
template &lt; &gt;// クラス
struct Outer_class
{
    template &lt; typename T &gt;
    void member_function_template() { }
} ;

// メンバー関数テンプレートの明示的特殊化
template &lt; &gt;
void Outer_class::member_function_template&lt;int&gt;()
{
// 定義
}


// クラステンプレート
template &lt; typename T &gt;
struct Outer_class_template
{
    template &lt; typename U &gt;
    void member_function_template() { }
} ;

// メンバー関数テンプレートの明示的特殊化
template &lt; &gt; // Outer_class_templateの明示的特殊化
template &lt; &gt; // member_function_templateの明示的特殊化
void Outer_class_template&lt;int&gt;::member_function_template&lt;int&gt;()
{
// 定義
}
</pre>
</li>
</ul>

<p>
テンプレートの明示的特殊化は、修飾名の場合、テンプレートの宣言されている名前空間の外側で宣言することもできる。
</p>

<pre>
namespace ns {

template &lt; typename T &gt;
void f( T ) { }
}

// ns::fの明示的特殊化
template &lt; &gt;
void ns::f( int ) { }
</pre>

<p>
関数テンプレートとクラステンプレートの場合、明示的特殊化の元となるテンプレートの宣言は、明示的特殊化の宣言より先行していなければならない。
</p>

<pre>
// エラー、テンプレートの宣言が先行していない
template &lt; &gt;
void f( int ) ; 

// テンプレートの宣言
template &lt; typename T &gt;
void f( T ) ;

// OK、テンプレートの宣言が先行している
template &lt; &gt;
void f( short ) ;
</pre>

<p>
メンバーテンプレートに対する明示的特殊化の定義には、メンバーの属するクラスもしくはクラステンプレートの定義が先行していなければならない。
</p>

<pre>
// クラスの宣言
struct Outer ;

// エラー、クラスの定義が先行していない
template &lt; &gt;
struct Outer::Inner&lt;int&gt; { } ;

// クラスの定義
struct Outer
{
    // メンバーテンプレート
    template &lt; typename T &gt;
    struct Inner { } ;
} ;

// OK、クラスの定義が先行している
template &lt; &gt;
struct OUter::Inner&lt;short&gt; { } ;
</pre>

<p>
メンバー関数、メンバー関数テンプレート、メンバークラス、メンバーenum、メンバークラステンプレート、クラステンプレートのstaticデータメンバーは、暗黙に実体化されるクラスの特殊化に対しても、明示的に特殊化できる。
</p>

<pre>
template &lt; typename T &gt;
struct X
{
    void f() { }
    void g() { }
} ;

// X&lt;int&gt;::fの明示的特殊化
template &lt; &gt;
void X&lt;int&gt;::f() { }


int main()
{
    X&lt;int&gt; x ; // X&lt;int&gt;を暗黙的に実体化
    x.f() ; // 明示的特殊化を使う
    x.g() ; // 暗黙に実体化された特殊化を使う
}
</pre>

<p>
このように、一部のメンバーだけを明示的に特殊化できる。明示的に特殊化されなかったメンバーが使われた場合は、クラステンプレートから暗黙の実体化による特殊化が使われる。
</p>

<p>
メンバーの明示的特殊化より、クラステンプレートの定義が先行していなければならない。
</p>

<pre>
// エラー
template &lt; &gt;
void X&lt;int&gt;::f() { }

template &lt; typename T &gt;
struct X
{
    void f() { }
} ;
</pre>

<p>
暗黙に宣言される特別なメンバー関数を明示的特殊化することはできない。
</p>

<pre>
template &lt; typename T &gt;
struct X
{
// デフォルトコンストラクタ―は暗黙に宣言される
} ;

// エラー
// 暗黙に宣言される特別なメンバー関数の明示的特殊化
template &lt; &gt;
X&lt;int&gt;::X() { }

template &lt; typename T &gt;
struct Y
{
    Y() { } // 特別なメンバー関数の明示的な宣言
} ;

// OK
// 暗黙に宣言されていない特別なメンバー関数の明示的特殊化
template &lt; &gt;
Y&lt;int&gt;::Y() { }
</pre>

<p>
このように、特別なメンバー関数を明示的特殊化する場合には、クラステンプレートの定義内で、明示的に宣言する必要がある。
</p>

<p>
明示的特殊化されたクラステンプレートのメンバーは、元のクラステンプレートとは独立して存在する。そのため、元のクラステンプレートとは全く違うメンバーの宣言にすることができる。
</p>

<pre>
template &lt; typename T &gt;
struct X
{
    void f() ;
} ;

// 明示的特殊化
template &lt; &gt;
struct X&lt;int&gt;
{ // 元のクラステンプレートとは違うメンバー
    void g() ;
} ;
</pre>

<p>
明示的特殊化されたクラステンプレートの定義内のメンバー宣言は、通常のクラス定義のように記述する。つまり、template &lt; &gt;をつける必要はない。メンバーの定義をクラス定義の外に記述する場合も同じ。
</p>

<pre>
template &lt; typename T &gt;
struct X { } ;

// 明示的特殊化されたクラステンプレート
template &lt; &gt;
struct X&lt;int&gt;
{
    void f() ; // 宣言
} ;

// 明示的特殊化されたクラステンプレート定義のメンバーの定義
// template &lt; &gt;は必要ない
void X&lt;int&gt;::f() { }
</pre>

<p>
ただし、明示的に特殊化されたメンバークラステンプレートのメンバーを定義するときには、template &lt; &gt;が必要である。メンバークラスではなく、メンバークラステンプレートであることに注意。
</p>

<pre>
template &lt; typename T &gt;
struct Outer
{
    // メンバークラス
    struct Inner { } ;

    // メンバークラステンプレート
    template &lt; typename U &gt;
    struct Inner_temp { } ;
} ;

// 特殊化Outer&lt;int&gt;のメンバークラスの明示的特殊化
template &lt; &gt;
struct Outer&lt;int&gt;::Inner
{
    void f() ;
} ;

// メンバークラスのメンバーの定義
// template &lt; &gt;は必要ない
void Outer&lt;int&gt;::Inner::f() { }

// 特殊化Outer&lt;int&gt;のメンバークラステンプレートの明示的特殊化
template &lt; &gt;
template &lt; typename U &gt;
struct Outer&lt;int&gt;::Inner_temp
{
    void f() ;
} ;

// メンバークラステンプレートのメンバーの定義
// template &lt; &gt;が必要
template &lt; &gt;
template &lt; typename U &gt;
void Outer&lt;int&gt;::Inner_temp&lt;U&gt;::f() { }
</pre>

<p>
テンプレート、メンバーテンプレート、クラステンプレートのメンバーが明示的に特殊化されている場合、暗黙の実体化が起こる前に、明示的特殊化が宣言されていなければならない。
</p>

<pre>
template &lt; typename T &gt;
struct X
{ } ;

// テンプレートの特殊化X&lt;int&gt;の使用
// X&lt;int&gt;に対する暗黙の実体化が起こる。
X&lt;int&gt; i ;

// エラー、明示的特殊化の宣言より前に、特殊化の暗黙の実体化が起こっている。
template &lt; &gt;
struct X&lt;int&gt; { } ;
</pre>

<p>
テンプレートの明示的特殊化の名前空間スコープは、テンプレートの名前空間スコープと同じ。
</p>

<p>
宣言されているが定義されていない明示的特殊化を指すテンプレート名は、不完全定義されたクラスと同様に使うことができる。
</p>

<pre>
template &lt; typename T &gt;
struct X { } ;

// 明示的特殊化の宣言
// X&lt;int&gt;はまだ定義されていない
template &lt; &gt;
struct X&lt;int&gt; ;

X&lt;int&gt; * p ; // OK、不完全型へのポインター
X&lt;int&gt; obj ; // エラー、不完全型のオブジェクト
</pre>

<p>
関数テンプレートの明示的特殊化の際のテンプレート名のテンプレート引数は、テンプレート実引数の型が、関数の実引数の型から推定できる場合は、省略することができる。
</p>

<pre>
template &lt; typename T &gt; struct X { } ;

template &lt; typename T &gt;
void f( X&lt;T&gt; ) ;

// 関数テンプレートf&lt;int&gt;の明示的特殊化
// テンプレートの特殊化の型は実引数の型から推定可能
template &lt; &gt;
void f( X&lt;int&gt; ) { }
</pre>

<p>
ある関数テンプレートと同じ名前で、関数テンプレートの特殊化と同じ型の関数であっても、その関数は、関数テンプレートの明示的特殊化ではない。
</p>

<pre>
// 関数テンプレートf
template &lt; typename T &gt;
void f( T ) { }

// 関数テンプレートfの明示的特殊化f&lt;int&gt;
template &lt; &gt;
void f( int ) { }

// 関数f
// 関数テンプレートfの明示的特殊化ではない
void f( int ) { }
</pre>

<p>
関数テンプレートの明示的特殊化は、宣言にinline指定子があるか、deleted定義されている場合のみ、inlineとなる。元の関数テンプレートのinline指定子の有無には影響されない。
</p>

<pre>
// inline指定子のある関数テンプレート
template &lt; typename T &gt;
inline void f( T ) { }

// 非inline関数
// 元のテンプレートのinline指定子には影響されない
template &lt; &gt;
void f( int ) { }

// inline関数
template &lt; &gt;
inline void f( short ) { }
</pre>

<p>
テンプレートのstaticデータメンバーの明示的特殊化の宣言は、初期化子を含む場合、定義となる。初期化子を含まない場合は宣言となる。デフォルト初期化が必要なstaticデータメンバーを定義する場合は、文法上の制約から、初期化リストを使う必要がある。
</p>

<pre>
template &lt; typename T &gt;
struct X
{
    static int data ;
} ;

// 明示的特殊化の宣言、定義ではない
template &lt; &gt;
int X&lt;int&gt;::data ; 

// エラー、メンバー関数int ()の宣言
// 文法上の制約による
template &lt; &gt;
int X&lt;int&gt;::data () ;

// 明示的特殊化の定義
template &lt; &gt;
int X&lt;int&gt;::data { } ;
</pre>

<p>
クラステンプレートのメンバーとメンバーテンプレートは、クラステンプレートで定義されていて、クラステンプレートが暗黙に実体化されていても、明示的特殊化できる。
</p>

<pre>
template &lt; typename T &gt;
struct X
{
    void f() { } 
    void g() { }
} ;

// 明示的特殊化
template &lt; &gt;
void X&lt;int&gt;::f() { }

int main()
{
    X&lt;int&gt; x ; // X&lt;int&gt;の暗黙の実体化
    x.f() ; // 明示的特殊化が使われる
    x.g() ; // 暗黙の実体化により生成された特殊化が使われる
}
</pre>

<p>
これにより、メンバーやメンバーテンプレートの一部だけを明示的に特殊化することができる。
</p>

<p>
ネストしたクラステンプレートのメンバーやメンバーテンプレートを明示的特殊化する場合、ネストした数だけtemplate&lt;&gt;を記述する必要がある。
</p>

<pre>
template &lt; typename T1 &gt;
struct Outer
{
    template &lt; typename T2 &gt;
    struct Inner
    {
        template &lt; typename T3 &gt;
        void f() { }
    } ;
} ;

template &lt; &gt; // Outer&lt;int&gt;の明示的特殊化
template &lt; &gt; // Outer&lt;int&gt;::Inner&lt;int&gt;の明示的特殊化
template &lt; &gt; // Outer&lt;int&gt;::Inner&lt;int&gt;::f&lt;int&gt;の明示的特殊化
void Outer&lt;int&gt;::Inner&lt;int&gt;::f&lt;int>( ) { }
</pre>


</article>



</article>

<article>
<h1 id="temp.fct.spec"><a href="#temp.fct.spec">関数テンプレートの特殊化(Function template specializations)</a></h1>

<p class="todo">
partial orderingの解説。
</p>
</article>


</article>

<article>
<h1 id="except"><a href="#except">例外(Exception handling)</a></h1>

<p>
例外(Exception)は、実行を例外ハンドラーに移す機能である。例外はスレッドごとに存在する。実行を例外ハンドラーに移す際に、オブジェクトを渡すことができる。例外ハンドラーに実行を移すには、tryブロックの中か、tryブロックの中で呼ばれている関数の中でthrow式を使う。
</p>

<pre>
tryブロック:
    try 複合文 ハンドラーseq

関数tryブロック:
    try コンストラクター初期化子<sub>opt</sub> 複合文 ハンドラーseq

ハンドラーseq:
    ハンドラー ハンドラーseq

ハンドラー:
    catch ( 例外宣言 ) 複合文

throw式:
    throw 代入式<sub>opt</sub>
</pre>

<p>
tryブロック文の文法は、キーワードtryに続いて複合文を書き、ひとつ以上のハンドラーを記述する。throw式の型はvoidである。throw式を実行するコードのことを、「例外を投げる(throw an exception)」コードといい、処理がハンドラーに移る。
</p>


<pre>
int main()
{
    try
    {
        throw 0 ; // int型のオブジェクトをthrowする
    }
    catch ( int i )
    {
        // int型のオブジェクトがthrowされた時に実行される
    }
    catch( double d )
    {
        // double型のオブジェクトがthrowされた時に実行される
    }
    catch( ... )
    {
        // 任意の型のオブジェクトがthrowされた時に実行される
    }
}
</pre>

<p>
goto文やswitch文を使い、tryブロックやハンドラーの外側から内側に処理を移してはならない。tryブロック内やハンドラー内の移動はできる。
</p>

<pre>
int main()
{
    // エラー、tryブロックの外側から内側に処理を移す
    goto begin_try_block ;
    // エラー、ハンドラーの外側から内側に処理を移す
    goto begin_handler ; 
    try
    {
        begin_try_block: ;

        // OK、tryブロック内の移動
        goto end_try_block ;

        end_try_block: ;
    }
    catch( ... )
    {
        begin_handler: ;

        // OK、ハンドラー内の移動
        goto end_handler ;

        end_handler: ;
    }
}
</pre>

<pre>
void f( int i )
{
    switch( i )
    {
        // OK
        case 0 : ;

        try {
            // エラー
            case 1 : ;
        }
        catch ( ... )
        {
            // エラー
            case 2 : ; 
        }

        // OK
        case 4 : ; 
    }
}
</pre>

<p>
goto文、break文、return文、continue文を使って、tryブロックとハンドラーの内側から外側に抜けることができる。
</p>

<pre>
void f()
{
    try
    {
        goto end_f ; // OK
    }
    catch ( ... )
    {
        return ; // OK
    }

end_main : ;
}
</pre>


<p>
関数tryブロック(function-try-block)は、関数の本体に記述できる
</p>

<pre>
void f()
try {

}
catch( ... )
{

}
</pre>

<p>
コンストラクターの関数の本体として記述する場合には、tryと複合文の間にコンストラクター初期化子を記述する。
</p>

<pre>
struct X
{
    int m1 ;
    int m2 ;

    X()
    try
    : m1(0), m2(0) // コンストラクター初期化子
    { }
    catch( ... ) { }
} ;
</pre>

<p>
関数tryブロックがコンストラクターかデストラクターの本体に用いられた場合、複合文と、構築と破棄の際にクラスのサブオブジェクトが例外を投げた場合、ハンドラーに処理が移る
</p>

<p>
コンストラクターに関数tryブロックを使う例：
</p>

<pre>
// 構築時の例外を投げるクラス
struct throw_at_construction
{
    throw_at_construction()
    {
        throw 0 ;
    }
} ;

struct X
{
    // 構築時に例外を投げるデータメンバー
    throw_at_construction member ;

    X()
    try : member()
    {  }
    catch ( ... ) { } // ハンドラーに処理が渡る
} ;

// 構築時に例外を投げる基本クラス
struct Y : throw_at_construction
{
    Y()
    try { }
    catch ( ... ) { } // ハンドラーに処理が渡る
} ;
</pre>

<p>
デストラクターに関数tryブロックを使う例：
</p>

<pre>
// 破棄時に例外を投げるクラス
struct throw_at_destruction
{
    ~throw_at_destruction()
    {
        throw 0 ;
    }
} ;

struct X
{
    throw_at_destruction member ;

    ~X()
    try {}
    catch( ... ) { }
    
} ;

struct Y : throw_at_destruction
{
    ~Y()
    try { }
    catch ( ... ) { }
} ;
</pre>

<article>
<h1 id="except.throw"><a href="#except.throw">例外を投げる(Throwing an exception)</a></h1>

<p>
例外を投げる(throwing an exception)とは、日本語では他にも、送出するとかスローするなどとも書かれている。
</p>

<p>
例外を投げると、処理はハンドラーに移る。例外を投げるときには、オブジェクトが渡される。オブジェクトの型によって、処理が渡されるハンドラーが決まる
</p>

<pre>
// int型
throw 0 ;

// const char *型
throw "hello" ;

struct X { } ;
X x ;
// X型
throw x ; 
</pre>

<p>
例外が投げられると、型が一致する最も近い場所にあるハンドラーに処理が移る。「最も近い」というのは、最近に入って、まだ抜けていないtryブロックに対応するハンドラーである。
</p>

<pre>
// 例外を投げる
void f() { throw 0 ; }

int main()
{
    try
    {
        try
        {
            try { f() } // 関数fの中で例外を投げる
            catch( ... ) { } // ここに処理が移る
        }
        catch( ... ) { }
    }
    catch( ... ) { }
}
</pre>

<p>
throw式はオペランドから一時オブジェクトを初期化する。この一時オブジェクトを例外オブジェクト(exception object)という。例外オブジェクトの型を決定するには、throw式のオペランドの型からトップレベルのCV修飾子を取り除き、T型への配列型はTへのポインター型へ、T型を返す関数型は、T型を返す関数へのポインター型に変換する。
</p>

<pre>
throw 0 ; // int

int const a = 0 ;
throw a ; // int

int const volatile * const volatile p = &amp;a ;
throw p ; // int const volatile *

int b[5] ;
throw b ; // int *

int f( int ) ;
throw f ; // int (*)(int)
</pre>

<p>
この一時オブジェクトはlvalueであり、型が適合するハンドラーの変数の初期化に使われる。
</p>

<pre>
void f()
{
    try
    {
        throw 0 ; // 例外オブジェクトはint型のlvalue
    }
    catch( int exception_object ) // 例外オブジェクトで初期化される
    { }
}
</pre>

<p>
例外オブジェクトの型が不完全型か不完全型へのポインター型である場合は、エラーとなる。
</p>

<pre>
struct incomplete_type ;

void f()
{
    // エラー、不完全型へのポインター型
    throw static_cast&lt;incomplete_type *&gt;(nullptr) ;
}
</pre>

<p>
ただし、void型はその限りではない。
</p>

<pre>
void f()
{
    // OK、void *
    throw static_cast&lt;void *&gt;(nullptr) ;
}
</pre>

<p>
いくつかの制限を除けば、throw式のオペランドは、関数への実引数やreturn文のオペランドとほぼ同じ扱いになっている。
</p>

<p>
例外オブジェクトのメモリーは、未規定の方法で確保される。
</p>

<p>
例外オブジェクトの寿命の決定にはふたつの条件があり、どちらか遅い方に合わせて破棄される。
</p>

<p>
ひとつは例外を再び投げる以外の方法で、例外を捉えたハンドラーから抜け出すこと。
</p>

<pre>
void f()
{

    try
    {
        throw 0 ;
    }
    catch ( ... )
    {
    // return文やgoto文などでハンドラーの複合分の外側に移動するか
    // あるいはハンドラーの複合分を最後まで処理が到達すれば、例外オブジェクトは破棄される
    }

}
</pre>

<p>
例外が再び投げられた場合は、例外オブジェクトの寿命は延長される。
</p>

<pre>
void f() ; // 例外を投げるかもしれない関数

void g() {

    try { f() ; }
    catch ( ... ) 
    {
        throw ; // 例外を再び投げる
    }
}
</pre>

<p>
この場合、例外オブジェクトは破棄されずに、例外処理が続行する。
</p>

<p>
もうひとつの条件は、例外オブジェクトを参照する最後のstd::exception_ptrが破棄された場合。これはライブラリの話になるので、本書ではstd::exception_ptrについては解説しない。
</p>

<p>
例外オブジェクトのストレージが解放される方法は未規定である。
</p>

<p>
例外オブジェクトの型がクラスである場合、クラスのコピーコンストラクターかムーブコンストラクターのどちらか片方と、デストラクターにアクセス可能でなければならない。
</p>

<p>
以下のようなクラスは、例外オブジェクトとして投げることができる。
</p>

<pre>
// 例外オブジェクトとして投げられるクラス
// コピーコンストラクター、ムーブコンストラクター、デストラクターにアクセス可能
struct throwable1
{
    throwable1( throwable1 const &amp; ) { }
    throwable1( throwable1 &amp;&amp; ) { }
    ~throwable1() { }
} ;

// 例外オブジェクトとして投げられるクラス
// コピーコンストラクター、デストラクターにアクセス可能

struct throwable2
{
    throwable2( throwable2 const &amp; ) { }
    throwable2( throwable2 &amp;&amp; ) = delete ;
    ~throwable2() { }
} ;

// 例外オブジェクトとして投げられるクラス
//　ムーブコンストラクター、デストラクターにアクセス可能
struct throwable3
{
    throwable3( throwable3 const &amp; ) = delete ;
    throwable3( throwable3 &amp;&amp; ) { }
    ~throwable3() { }
} ;
</pre>

<p>
例外オブジェクトとして投げられるクラスの条件を満たすには、コピーコンストラクターとムーブコンストラクターは、どちらか片方だけアクセスできればよい。デストラクターには必ずアクセス可能でなければならない。
</p>

<p>
以下のようなクラスは投げることができない。
</p>

<pre>
// 例外オブジェクトとして投げられないクラス
struct unthrowable
{
    // コピーコンストラクター、ムーブコンストラクター両方にアクセスできない
    unthrowable( unthrowable const &amp; ) = delete ;
    unthrowable( unthrowable &amp;&amp; ) = delete ;

    // デストラクターにアクセスできない
    ~unthrowable() = delete ;
} ;
</pre>

<p>
たとえ、コピーやムーブが省略可能な文脈でも、コピーコンストラクターかムーブコンストラクターのどちらか片方にはアクセス可能という条件を満たしていなければ、クラスは例外オブジェクトとして投げることができない。
</p>

<p>
例外は、あるハンドラーに処理が移った段階で、とらえられた(キャッチされた)とみなされる。ただし、例外がとらえられたハンドラーから再び投げられた場合は、再びとらえられていない状態に戻る。
</p>

<pre>
try
{
    throw 0 ;
}
catch( ... )
{
    // 例外はとらえられた

    throw ; // 再びとらえられていない状態に戻る
}
</pre>

<p>
例外オブジェクトとして投げられる初期化式の評価が完了した後から、例外がとらえられるまでの間に、別の例外が投げられた場合は、std::terminateが呼ばれる。
</p>

<p>
これが起こるよくある状況は、スタックアンワインディングの最中にデストラクターから例外が投げられることだ.
</p>

<pre>
// デストラクターが例外を投げるクラス
struct C
{
    // デストラクターに明示的な例外指定がない場合、この文脈では暗黙にthrow()になるため
    // デストラクターの外に例外を投げるには例外指定が必要
    ~C() noexcept( false ) { throw 0 ; }
} ;

int main()
{
    try 
    {
        C c ;
        throw 0 ;
        // C型のオブジェクトcが破棄される
        // 例外中に例外が投げられたため、std::terminateが呼ばれる
    }
    catch( ... ){ }
}
</pre>

<p>
一般的に、デストラクターから例外を投げるべきではない。
</p>

<p>
初期化式の評価が完了した後という点に注意。throw式のオペランドの初期化式の評価中の例外はこの条件に当てはまらない。
</p>

<pre>
struct X
{
    X() { throw 0 ; }
} ;

int main( )
{
    try
    {
        // OK、初期化式の評価中の例外
        // 例外オブジェクトの型はint
        throw X() ;
    }
    catch( X &amp; exception ) { }
    catch( int exception ) { } // このハンドラーでとらえられる
}
</pre>

<p>
この例ではX型のオブジェクトを例外としてthrowする前に、初期化中にint型の例外が投げられたので、結果として投げられる例外オブジェクトの型はint型になる。
</p>

<p>
ただし、初期化式の評価が完了した後という点に注意。初期化完了の後に例外が投げられた場合は、std::terminateが呼ばれる。
</p>

<pre>
// この例がstd::terminateを呼ぶかどうかは、C++の実装次第である。

struct X
{
    X( X const &amp; ) { throw 0 ; }
} ;

int main( )
{
    try
    {
        // 実装がコピーを省略しない場合、std::terminateが呼ばれる
        // コピーコンストラクターの実行は評価完了後
        throw X() ;
    }
    catch( ... ) { }
}
</pre>

<p>
この文脈では、賢いC++の実装ならば、コピーを省略できる。ただし、コピーが省略される保証はない。もし、例外オブジェクトを構築する際にコピーが行われたならば、それはthrow式のオペランドの初期化式の評価完了後なので、この条件に当てはまり、std::terminateが呼ばれる。
</p>

<p>
また、現行の規格の文面にや誤りがあり、以下のコードではstd::terminateが呼ばれるよう解釈できてしまう。
</p>

<pre>
// 例外によって抜け出す関数
void f() { throw 0 ; }

struct C
{

    ~C()
    {
        // 例外によって抜け出す関数を呼ぶ
        try { f() ; }
        catch( ... ) { }
    }
} ;

int main()
{
    try 
    {
        C c ;
        throw 0 ;
        // 例外がハンドラーにとらえられる前に、cのデストラクターが呼ばれる
    }
    catch( ... ){ }
}
</pre>

<p>
これは規格の誤りであり、本書執筆の時点で、修正が検討されている。
</p>

<p>
オペランドのないthrow式は、現在とらえられている例外を再び投げる(rethrow)。これは、最送出とかリスローなどとも呼ばれている。例外が再び有効になり、例外オブジェクトは破棄されずに再利用される。つまり、例外をふたたび投げる際に一時オブジェクトを新たに作ることはない。例外は再びとらえられているものとはみなされなくなり、std::uncaught_exception()の値も、またtrueになる。
</p>

<pre>
int main()
{
    try
    {
        try
        {
            throw 0 ;
        }
        catch ( int e )
        { // 例外をとらえる
            throw ; // 一度捉えた例外を再び投げる
        }
    }
    catch( int e )
    {
        // 再び投げられた例外をとらえる
    }

}
</pre>

<p>
例外がとらえられていない状態でオペランドのないthrow式を実行すると、std::terminateが呼ばれる。
</p>

<pre>
int main()
{
    throw ; // std::terminateが呼ばれる
}
</pre>

</article>

<article>
<h1 id="except.ctor"><a href="#except.ctor">コンストラクターとデストラクター(Constructors and destructors)</a></h1>


<p>
処理がthrow式からハンドラーに移るにあたって、tryブロックの中で構築された自動オブジェクトのデストラクターが呼び出される。自動オブジェクトの破棄は構築の逆順に行われる。
</p>

<pre>
struct X
{
    X() { }
    ~X() { }
} ;


int main()
{
    try
    {
        X a ;
        X b ;
        X c ;
        // a, b, cの順に構築される

        throw 0 ;
    }
    // このハンドラーに処理が移る過程で、
    // c, b, aの順に破棄される
    catch( int ) { }
}
</pre>

<p>
オブジェクトの構築、破棄が、例外により中断された場合、完全に構築されたサブオブジェクトに対してデストラクターが実行される。オブジェクトが構築されたストレージの種類は問わない。
</p>

<pre>
struct Base
{
    Base() { }
    ~Base() { }
} ;


// コンストラクターに実引数trueが渡された場合、例外を投げるクラス
struct Member
{
    Member( bool b )
    {
        if ( b )
            throw 0 ;
    }
    ~Member() { }
} ;

// Xのサブオブジェクトは、基本クラスBaseと、非staticデータメンバー、a, b, c
struct X : Base
{
    Member a, b, c ;

    X() : a(false), b(true), c(false)
    { }
    // Base, aのデストラクターが実行される。
    ~X() { }
    
} ;



int main()
{
    try
    {
        X x ;
    }
    catch( int ) { }
}
</pre>

<p>
この例では、クラスXは、サブオブジェクトとして、Base型の基本クラスと、Member型の非staticデータメンバー、a, b, cを持つ。その初期化順序は、基本クラスBase, a, b, c, Xである。クラスMemberは、コンストラクターの実引数にtrueが渡された場合、例外を投げる。クラスXのコンストラクターは、bのコンストラクターにtrueを与えている。その結果、クラスXのオブジェクトの構築は、例外によって中断される。
</p>

<p>
この時、デストラクターが実行されるのは、基本クラスBaseのオブジェクトと、Member型の非staticデータメンバーaのオブジェクトである。bは、コンストラクターを例外によって抜けだしたため、構築が完了していない。cは、まだコンストラクターが実行されていないため、構築が完了していない。そのため、b, cのオブジェクトに対してデストラクターは実行されない。
</p>

<p>
ただし、union風クラスのvariantメンバーには、デストラクターは呼び出されない。
</p>

<pre>
struct Member 
{
    Member() { }
    ~Member() { }
} ;


struct X
{
    union { Member m ; }  ;

    X() { throw 0 ; } // mのデストラクターは実行されない
    ~X() { } 
} ;
</pre>

<p>
あるオブジェクトの非デリゲートコンストラクターの実行が完了し、その非デリゲートコンストラクターを呼び出したデリゲートコンストラクターが例外によって抜けだした場合、そのオブジェクトに対してデストラクターが呼ばれる。
</p>

<pre>
struct X
{
    // 非デリゲートコンストラクター
    X( bool ) { }

    // デリゲートコンストラクター
    X() : X( true )
    {
        throw 0 ; // Xのデストラクターが呼ばれる
    }

    ~X() { }
} ;
</pre>

<p>
これは、オブジェクトの構築完了は、非デリゲートコンストラクターの実行が完了した時点だからだ。
</p>

<p>
例外によって構築が中断されたオブジェクトがnew式によって構築された場合、使われた確保関数に対応する解放関数があれば、ストレージを開放するために自動的に呼ばれる。
</p>

<pre>
struct X
{
    X() { throw 0 ; }
    ~X() { } 

    // 確保関数
    void * operator new( std::size_t size ) noexcept
    {
        return std::malloc( size ) ;
    }

    // 上記確保関数に対応する解放関数
    void operator delete( void * ptr ) noexcept
    {
        std::free( ptr ) ;
    }
} ;

int main()
{
    try
    {
        new X ; // 対応する解放関数が呼ばれる
    }
    catch( int ) { }
}
</pre>

<p>
この例では、Xを構築するためにmallocで確保されたストレージは、正しくfreeで解放される。
</p>

<p>
throw式から処理を移すハンドラーまでのtryブロック内の自動ストレージ上のオブジェクトのデストラクターを自動的に呼ぶこの一連の過程は、スタックアンワインディング(stack unwinding)と呼ばれている。もし、スタックアンワインディング中に呼ばれたデストラクターが例外によって抜けだした場合、std::terminateが呼ばれる。
</p>

<pre>
struct X
{
    X() { }
    ~X() noexcept(false)
    {
        throw 0 ;
    }
} ;

int main()
{
    try
    {
        X x ;
        throw 0 ; // std::terminateが呼ばれる
    }
    catch( int ) { }
}
</pre>

<p>
現行の文面を解釈すると、以下のコードもstd::terminateを呼ぶように解釈できるが、これは誤りであり、将来の規格改定で修正されるはずである。
</p>

<pre>
struct Y
{
    Y() { }
    ~Y() noexcept(false) { throw 0 ; }
} ;

struct X
{
    X() { }
    ~X() noexcept(false)
    {
        try {
        // スタックアンワインディング中に呼ばれたデストラクターが例外によって抜け出す
        // 現行の規格の文面解釈ではstd::terminateが呼ばれてしまう
            Y y ; 
        } catch( int ) { }
    }
} ;

int main()
{
    try
    {
        X x ;
        throw 0 ;
    }
    catch( int ) { }
}
</pre>

<p>
一般に、デストラクターを例外によって抜け出すようなコードは書くべきではない。デストラクターはスタックアンワインディングのために呼ばれるかもしれないからだ。スタックアンワインディング中かどうかを調べる、std::uncaught_excpetionのような標準ライブラリもあるにはあるが、スタックアンワインディング中かどうかを調べる必要は、通常はない。
</p>

<p>
C++11からは、デストラクターはデフォルトで例外指定がつくようになり、ほとんどの場合、noexcept(true)と互換性のある例外指定になる変更がなされたのも、通常はデストラクターを例外で抜け出す必要がないし、またそうすべきではないからだ。
</p>

</article>

<article>
<h1 id="except.handle"><a href="#except.handle">例外の捕捉(Handling an exception)</a></h1>

<p>
throw式によって投げられた例外は、tryブロックのハンドラーによって補足される。ハンドラーの文法は以下の通り。
</p>

<pre>
catch ( 例外宣言 ) 複合文
</pre>

<pre>
int main()
{
    try
    {
        throw 0 ; 例外オブジェクトの型はint
    }
    catch( double d ) {} 
    catch( float f ) { }
    catch( int i ) {} // このハンドラーに処理が移る

}
</pre>

<p>
例外が投げられると、処理は、例外オブジェクトの型と適合(match)する例外宣言を持つハンドラーに移される。
</p>

<p>
ハンドラーの例外宣言は、不完全型、抽象クラス型、rvalueリファレンス型であってはならない。
</p>

<pre>
struct incomplete ; // 不完全型

struct abstract
{
    void f() = 0 ;
} ;

int main()
{
    try { }
    catch ( incomplete x ) { } // エラー、不完全型
    catch ( abstract a ) { } // エラー、抽象クラス型
    catch( abstract * a ) { } // OK、抽象クラスへのポインター型
    catch( abstract &amp; a ) { } // OK、抽象クラスへのリファレンス型
    catch( int &amp;&amp; rref) { } // エラー、rvalueリファレンス型
}
</pre>

<p>
また、例外宣言の型は、不完全型へのポインターやリファレンスであってはならない。ただし、void *, const void *, volatile void *, const volatile void *は、不完全型へのポインター型だが、例外的に許可されている。
</p>


<p>
ハンドラーの例外宣言が「Tへの配列」の場合、「Tへのポインター」型に変換される。「Tを返す関数」型は、「Tを返す関数へのポインター」型に変換される。
</p>

<pre>
catch ( int [5] ) // int *と同じ
catch ( int f( void ) ) // int (*f)(void)と同じ
</pre>

<p>
あるハンドラーが、例外オブジェクトの型Eと適合する条件は以下の通り
</p>

<ul>
<li>
<p>
ハンドラーの型が cv Tもしくは cv T &amp;で、EとTが同じ型である場合。
</p>

<p>
cvは任意のCV修飾子(const, volatile)のことで、トップレベルのCV修飾子は無視される。
</p>

<p>
たとえば、例外オブジェクトの型がintの場合、以下のようなハンドラーが適合する。
</p>

<pre>
catch ( int )
catch ( const int )
catch ( volatile int )
catch ( const volatile int )
catch ( int &amp; )
catch ( const int &amp; )
catch ( volatile int &amp; )
catch ( const volatile int &amp; )
</pre>
</li>

<li>
<p>
ハンドラーの型がcv Tかcv T &amp;で、TはEの曖昧性のないpublicな基本クラスである場合
</p>

<p>
例えば、以下のような例が適合する。
</p>

<pre>
struct Base { } ;
struct Derived : public Base { } ;

int main()
{
    try
    {
        Derived d ;
        throw d ; // 例外オブジェクトの型はDerived
    }
    catch( Base &amp; ) { } // 適合、BaseはDerivedの曖昧性のないpublicな基本クラス
}
</pre>

<p>
以下のような例は適合しない。
</p>

<pre>
struct Base { } ;
struct Ambiguous { } ;
struct Derived : private Base, public Ambiguous { } ;

struct Sub : public Derived, public Ambiguous { } ;

int main()
{
    try
    {
        Sub sub ;
        throw sub ; // 例外オブジェクトの型はSub
    }
    catch( Base &amp; ) { } // 適合しない、非public基本クラス
    catch( Ambiguous &amp; ) { } // 適合しない、曖昧
}
</pre>

</li>

<li>
<p>
ハンドラーの型がcv1 T* cv2で、Eがポインター型で、以下のいずれかの方法でハンドラーの型に変換可能な場合
</p>

<ul>
<li>
<p>
標準ポインター型変換で、privateやprotectedなポインターへの変換や、曖昧なクラスへの変換を伴わないもの
</p>

<pre>
struct Base { } ;
struct Derived : public Base { } ;

int main()
{
    try
    {
        Derived d ;
        throw &amp;d ; // 例外オブジェクトの型はDerived
    }
    catch( Base * ) { } // 適合、BaseはDerivedの曖昧性のないpublicな基本クラス
}
</pre>

</li>

<li>
<p>
修飾変換
</p>

<pre>

int main()
{
    int i ;
    try
    {

        throw &amp;i ;
    }
    catch( const int * ) { }
}
</pre>
</li>
</ul>

</li>


<li>
<p>
ハンドラーの型がポインターかメンバーへのポインターで、Eがstd::nullptr_tの場合
</p>

<pre>

struct X
{
    int member ;
} ;

int main()
{
    try
    {
        throw nullptr ;
    }
    catch( void * ) { } // 適合
    catch( int * ) { } // 適合
    catch( X * ) { } // 適合
    catch( int X::* ) { } // 適合
}

</pre>

<p>
nullptrの型であるstd::nullptr_t型の例外オブジェクトは、あらゆるポインター型、メンバーへのポインター型に適合する。
</p>

</li>

</ul>

<p>
throw式のオペランドが定数式で0と評価される場合でも、ポインターやメンバーへのポインター型のハンドラーには適合しない。
</p>

<pre>
int main()
{
    try
    {
        throw 0 ; // 例外オブジェクトの型はint
    }
    catch( int * ) // 適合しない
}
</pre>

<p>
tryブロックのハンドラーは、書かれている順番に比較される。
</p>

<pre>
int main()
{
    try
    {
        throw 0 ; // 例外オブジェクトの型はint
    }
    catch ( int ) { } // 適合する。処理はこのハンドラーに移る
    catch ( const int ) { }
    catch ( int &amp; ) { }
}
</pre>

<p>
この例では、3つのハンドラーはどれも例外オブジェクトの型に適合するが、比較は書かれている順番に行われる。一番初めに適合したハンドラーに処理が移る。関数のオーバーロード解決のような、ハンドラー同士の型の適合の優劣の比較は行われない。
</p>

<p>
ハンドラーの例外宣言に...が使われた場合、そのハンドラーはどの例外にも適合する。
</p>

<pre>
void f()
{
    try { }
    catch( int ) { }
    catch( double ) { }
    catch( ... ) { } // どの例外にも適合する
}
</pre>

<p>
...ハンドラーを使う場合は、tryブロックのハンドラーの最後に記述しなければならない。
</p>

<pre>
void f()
{
    try { }
    catch( ... ) { }
    catch( int ) { } // エラー
}
</pre>

<p>
tryブロックのハンドラーのうちに、適合するハンドラーが見つからない場合、同じスレッド内で、そのtryブロックのひとつ上のtryブロックが試みられる。
</p>

<pre>

void f()
{
    try { throw 0 ; } // 例外オブジェクトの型はint
    catch( double ) { } // 適合しない
}

void g()
{

    try
    {
        f() ;
    }
    catch( int ) { } // 適合する
}

int main()
{
    try {
        g() ;
    }
    catch( ... ) { }
}
</pre>

<p>
catch句の仮引数の初期化が完了した時点で、ハンドラーはアクティブ(active)になったとみなされる。スタックはこの時点でアンワインドされている。例外を投げた結果、std::terminateやstd::unexpectedが呼ばれた場合、暗黙のハンドラーというものがアクティブになったものとみなされる。catch句から抜けだした場合、ハンドラーはアクティブではなくなる。
</p>

<p>
現在、アクティブなハンドラーが存在する場合、直前に投げられた例外を、現在補足されている例外(currently handled exception)と呼ぶ。
</p>

<p>
適合するハンドラーが見つからない場合、std::terminateが呼ばれる。std::terminateが呼ばれる際、スタックがアンワインドされるかどうかは実装次第である。
</p>

<p>
コンストラクターとデストラクターの関数tryブロック内で、非staticデータメンバーかオブジェクトの基本クラスを参照した場合、挙動は未定義である。
</p>

<pre>
struct S
{
    int member ;

    S()
    try
    {
        throw 0 ;
    }
    catch ( ... )
    {
        int x = member ; // 挙動は未定義
    }
} ;
</pre>

<p>
コンストラクターの関数tryブロックのハンドラーに処理が移る前に、完全に構築された基本クラスと非staticメンバーのオブジェクトは、破棄される。
</p>

<pre>
struct Base
{
    Base() { }
    ~Base() { }
} ;

struct Derived : Base
{

    Derived()
    try
    {
        throw 0 ;
    }
    catch ( ... )
    {
        // 基本クラスBaseのオブジェクトはすでに破棄されている
        // 非staticデータメンバーのオブジェクトについても同様
    }
} ;
</pre>

<p>
オブジェクトの非デリゲートコンストラクターの実行が完了したあとに、デリゲートコンストラクターが例外を投げた場合は、オブジェクトのデストラクターが実行されたあとに、関数tryブロックのハンドラーに処理が移る。
</p>

<pre>
struct S
{

    // 非デリゲートコンストラクター
    S() { }

    // デリゲートコンストラクター
    S( int ) try
        : S()
    { throw 0 ; }
    catch( ... )
    {
        // デストラクターS::~Sはすでに実行されている
    }

    ~S() { }
} ;

int main()
{
    S s(0) ;
}
</pre>

<p>
非デリゲートコンストラクターの実行完了をもって、オブジェクトは構築されている。デリゲートコンストラクターが例外を投げた場合の関数tryブロックのハンドラーに処理が移る前に、オブジェクトを破棄されなければならない。そのために、ハンドラーに処理が移る前にデストラクターが呼び出されることになる。
</p>

<p>
デストラクターの関数tryブロックのハンドラーに処理が移る前に、オブジェクトの基本クラスと非variantメンバーは破棄される。
</p>

<pre>
struct Base
{
    Base() { }
    ~Base() { }
} ;

struct Derived : Base
{
    ~Derived() noexcept(false)
    try { throw 0 ; }
    catch( ... )
    {
        // 基本クラスはすでに破棄されている
        // 非staticデータメンバーについても同様
    }
} ;
</pre>

<p>
関数のコンストラクターの仮引数のスコープと寿命は、関数tryブロックのハンドラー内まで延長される。
</p>

<pre>
void f( int param )
try
{
    throw 0 ;
}
catch ( ... )
{
    int x = param ; // OK、延長される
}
</pre>

<p>
静的ストレージ上のオブジェクトのデストラクターから投げられる例外が、main関数の関数tryブロックのハンドラーで補足されることはない。threadストレージ上のオブジェクトのデストラクターから投げられる例外が、スレッドの初期関数の関数tryブロックのハンドラーで補足されることはない。
</p>

<p>
コンストラクターの関数tryブロックのハンドラーの中にreturn文がある場合、エラーとなる。
</p>

<pre>
struct S
{
    S()
    try { }
    catch( ... )
    {
        return ; // エラー
    }
} ;
</pre>

<p>
コンストラクターとデストラクターの関数tryブロックで、処理がハンドラーの終わりに達したときは、現在ハンドルされている例外が、再びthrowされる。
</p>

<pre>
struct S
{
    S()
    try {
        throw 0 ;
    }
    catch ( int )
    {
        // 例外が再びthrowされる
    }
} ;
</pre>

<p>
コンストラクターとデストラクター以外の関数の関数tryブロック、処理がハンドラーの終わりに達したときは、関数からreturnする。このreturnは、オペランドなしのreturn文と同等になる。
</p>

<pre>
void f()
try
{
    throw 0 ;
}
catch( int )
{
// return ;と同等
}
</pre>

<p>
もしこの場合に、関数が戻り値を返す関数の場合、挙動は未定義である。
</p>

<p>
int f()
try
{
    throw 0 ;
}
catch( ... )
{
// 挙動は未定義
}
</p>

<p>
例外宣言が例外の型と名前を指定する場合、例外の型のオブジェクトがその名前で、例外オブジェクトからコピー初期化される。
</p>

<pre>
int main()
{
    try
    {
        throw 123 ; // 例外オブジェクの型はint、値は123
    }
    catch( int e )
    {
        // eの型はint、値は123
    }
}
</pre>

<p>
例外宣言が、例外の型のみで名前を指定していない場合、例外の型の一時オブジェクトが生成され、例外オブジェクトからコピー初期化される
</p>

<pre>
int main()
{
    try
    {
        throw 123 ;
    }
    catch( int )
    {
        // int型の一時オブジェクトが生成され、例外オブジェクトからコピー初期化される
        // 名前がないので、参照する方法はない
    }
}
</pre>

<p>
例外宣言の名前の指し示すオブジェクト、あるいは無名の一時オブジェクトの寿命は、処理がハンドラーから抜けだして、ハンドラー内で初期化された一時オブジェクトが解放された後である。
</p>

<pre>
struct S
{
    int * p ;
    S( int * p ) : p(p) { }
    ~S() { *p = 0 ; }
} ;

int main()
{
    try
    {
        throw 123 ;
    }
    catch( int e )
    {
        S s( &amp;e ) ;
    
    // sが破棄された後に、eが破棄される
    }
}
</pre>

<p>
そのため、上のコードは問題なく動作する。なぜならば、eが破棄されるのはsよりも後だからだ。
</p>

<p>
ハンドラーの例外宣言が、非constな型のオブジェクトの場合、ハンドラー内でそのオブジェクトに対する変更は、throw式によって生成された一時的な例外オブジェクトには影響しない。
</p>

<pre>
int main()
{
    try
    {
        try
        {
            throw 0 ;
        }
        catch( int e )
        {
            ++e ; // 変更
            throw ; // 例外オブジェクトの再throw
        }
    }
    catch ( int e )
    {
        // eは0
    }
}
</pre>

<p>
ハンドラーの例外宣言が、非constな型へのリファレンス型のオブジェクトの場合、ハンドラー内でそのオブジェクトに対する変更は、throw式によって生成された一時的な例外オブジェクトを変更する。この副作用は、ハンドラー内で再throwされたときにも効果を持つ。
</p>

<pre>
int main()
{
    try
    {
        try
        {
            throw 0 ;
        }
        catch( int &amp; e )
        {
            ++e ; // 変更
            throw ; // 例外オブジェクトの再throw
        }
    }
    catch ( int e )
    {
        // eは1
    }
}

</pre>

</article>

<article>
<h1 id="except-spec"><a href="#except-spec">例外指定(Exception specifications)</a></h1>

<p>
例外指定(Exception specification)とは、関数宣言で、関数が例外を投げるかどうかを指定する機能である。
</p>

<p>
関数宣言における例外指定の文法は、リファレンス修飾子の後、アトリビュートの前に記述する。
</p>

<pre>
T D( 仮引数宣言 ) cv修飾子 リファレンス修飾子 例外指定 アトリビュート指定子

例外指定:
noexcept( 定数式 )
noexcept
</pre>

<pre>
void f() noexcept ;

struct S
{
    void f() const &amp; noexcept [[ ]] ;
} ;
</pre>

<p>
例外指定は、関数宣言と定義のうち、関数型、関数へのポインター型、関数型へのリファレンス、メンバー関数へのポインター型に適用できる。また、関数へのポインター型が仮引数や戻り値の型に使われる場合も指定できる。
</p>

<pre>
void f() noexcept           ; // OK
void (*fp)() noexcept = &amp;f  ; // OK
void (&amp;fr)() noexcept = f   ; // OK

// OK、仮引数として
void g( void (*fp)() noexcept ) ;
// OK、戻り値の型として
auto h() -&gt; void (*)() noexcept ;

struct S
{
    void f() noexcept ; // OK
} ;
</pre>

<p>
typedef宣言とエイリアス宣言には使用できない。
</p>

<pre>
typedef void (*func_ptr_type)() noexcept ; // エラー
using type = void (*)() noexcept ; // エラー
</pre>

<p>
例外指定のない関数宣言は、例外を許可する関数である。
</p>

<p>
例外指定にnoexceptが指定された場合、その関数は例外を許可しないと指定したことになる。
</p>


<p>
例外指定に、noexcept(定数式)を指定し、定数式がtrueと評価される場合、その関数は例外を許可しないと指定したことになる。定数式がfalseと評価される場合、その関数は例外を許可する関数と指定したことになる。
</p>

<pre>
void f1() ; // 例外を許可
void f2() noexcept ; // 例外を許可しない
void f3() noexcept( true ) ; // 例外を許可しない
void f4() noexcept( false ) ; // 例外を許可
</pre>

<p>
noxcept(定数式)は、コンパイル時の条件に従って、関数の例外指定を変えることに使える。
</p>

<pre>
template &lt; typename T &gt;
constexpr bool is_nothrow()
{
    return std::is_fundamental&lt;T&gt;::value ;
}

// テンプレート仮引数が基本型なら例外を投げない実装ができる関数
template &lt; typename T &gt;
void f( T x ) noexcept( is_nothrow&lt;T&gt;() ) ;
</pre>

<p>
この例では、関数fは、テンプレート仮引数が基本型の場合、例外を投げない実装ができるものとする。そこで、テンプレートのインスタンス化の際に、型を調べることによって、例外を許可するかどうかをコンパイル時に切り替えることができる。
</p>

<p>
もし、例外を許可しない関数が、例外のthrowによって抜け出した場合、std::terminateが呼ばれる。
</p>

<pre>
// 例外を許可する関数
void allow_exception()
{
    throw 0 ; // OK
}

// 例外を許可しない関数
void disallow_exception() noexcept
{
    try
    {
        throw 0 ; // OK、例外は関数の外に抜けない
    }
    catch ( int ) { }

    throw 0 ; // 実行時にstd::terminateが呼ばれる
}
</pre>

<p>
例外を許可しないというのは、例外によって関数から抜け出すことを禁止するものであり、関数の中で例外を使うことを禁止するものではない。
</p>

<p>
例外を許可しない関数は、例外を投げる可能性があったとしても、違法ではない。C++実装は、そのようなコードを合法にするように明確に義務付けられている。
</p>

<pre>
void f() noexcept
{
    throw 0 ; // OK、コンパイルが通る
    // 実行時にstd::terminateが呼ばれる
}

void g( bool b ) noexcept
{
    if ( b )
        throw 0 ; // OK、コンパイルが通る
    // 実行時にbがtrueの場合、std::terminateが呼ばれる
}
</pre>

<p>
もちろん、そのような関数を呼び出して、結果として関数の外に例外が投げられた場合、std::terminateが呼ばれる。
</p>

<p>
この他に、C++11では非推奨(deprecated)扱いになっている機能に、動的例外指定(dynamic-exception-specification)がある。この機能は将来廃止されるので、詳しく解説しないが、概ね以下のような機能となっている。
</p>

<pre>
// 例外を許可しない
void f() throw( ) ; 

// int型のthrowを許可する
void g() throw( int ) ;

// int型とshort型のthrowを許可する
void h() throw( int, short ) ;
</pre>

<p>
動的例外指定のある関数では、例外を関数の外にthrowすると、std::unexpectedが呼ばれる。もし、許可した型の例外をthrowした場合は、そのままハンドラーの検索が行われるが、許可しない型をthrowした場合は、std::terminateが呼ばれるとされている。
</p>

<p>
少なくとも、当初のC++の設計はそうであったが、現実には、そのように実装するC++実装は出てこなかった。ほとんどの実装では、動的例外指定は、単に無視された。
</p>

<p>
その後、何も例外として許可する型を指定子ない、throw()だけが、関数が例外を外に投げないものとして
</p>

<p>
クラスの暗黙に宣言される特別なメンバー関数は、この動的例外指定を暗黙に指定される。その型リストは、暗黙の実装が呼び出す関数が投げる可能性のある例外のみを持つ。
</p>

<p>
これは、基本クラスや非staticメンバーが、明示的に例外を許可するものでないかぎり、クラスの暗黙の特別なメンバーは、無例外指定されるということである。
</p>

<pre>
class S
{
// 暗黙のコンストラクター、デストラクター、代入演算子は、
// 例外指定throw()が指定される
} ;
</pre>

<p>
解放関数の宣言に、明示的な例外指定がない場合は、noexcept(true)が指定されたものとみなされる。
</p>

<pre>
// 暗黙にnoexcept(true)が指定される
void operator delete( void * ) ;
</pre>

</article>

</article>

</div>

<div class="gfdl">
<h3 style="text-align: center;">GNU Free Documentation License</h3>

<p style="text-align: center;">Version 1.3, 3 November 2008</p>

<p> Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     &lt;<a href="http://fsf.org/">http://fsf.org/</a>&gt;
 </p><p>Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.</p>

<h4><a name="section0"></a>0. PREAMBLE</h4>

<p>The purpose of this License is to make a manual, textbook, or other
functional and useful document &quot;free&quot; in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.</p>

<p>This License is a kind of &quot;copyleft&quot;, which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.</p>

<p>We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.</p>

<h4><a name="section1"></a>1. APPLICABILITY AND DEFINITIONS</h4>

<p>This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The &quot;Document&quot;, below,
refers to any such manual or work.  Any member of the public is a
licensee, and is addressed as &quot;you&quot;.  You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.</p>

<p>A &quot;Modified Version&quot; of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.</p>

<p>A &quot;Secondary Section&quot; is a named appendix or a front-matter section of
the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall
subject (or to related matters) and contains nothing that could fall
directly within that overall subject.  (Thus, if the Document is in
part a textbook of mathematics, a Secondary Section may not explain
any mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.</p>

<p>The &quot;Invariant Sections&quot; are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.  If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant.  The Document may contain zero
Invariant Sections.  If the Document does not identify any Invariant
Sections then there are none.</p>

<p>The &quot;Cover Texts&quot; are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.</p>

<p>A &quot;Transparent&quot; copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount
of text.  A copy that is not &quot;Transparent&quot; is called &quot;Opaque&quot;.</p>

<p>Examples of suitable formats for Transparent copies include plain
ASCII without markup, Texinfo input format, LaTeX input format, SGML
or XML using a publicly available DTD, and standard-conforming simple
HTML, PostScript or PDF designed for human modification.  Examples of
transparent image formats include PNG, XCF and JPG.  Opaque formats
include proprietary formats that can be read and edited only by
proprietary word processors, SGML or XML for which the DTD and/or
processing tools are not generally available, and the
machine-generated HTML, PostScript or PDF produced by some word
processors for output purposes only.</p>

<p>The &quot;Title Page&quot; means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, &quot;Title Page&quot; means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.</p>

<p>The &quot;publisher&quot; means any person or entity that distributes copies of
the Document to the public.</p>

<p>A section &quot;Entitled XYZ&quot; means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as &quot;Acknowledgements&quot;,
&quot;Dedications&quot;, &quot;Endorsements&quot;, or &quot;History&quot;.)  To &quot;Preserve the Title&quot;
of such a section when you modify the Document means that it remains a
section &quot;Entitled XYZ&quot; according to this definition.</p>

<p>The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.</p>

<h4><a name="section2"></a>2. VERBATIM COPYING</h4>

<p>You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no
other conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.</p>

<p>You may also lend copies, under the same conditions stated above, and
you may publicly display copies.</p>

<h4><a name="section3"></a>3. COPYING IN QUANTITY</h4>

<p>If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document's license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.</p>

<p>If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.</p>

<p>If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material.
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.</p>

<p>It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to
give them a chance to provide you with an updated version of the
Document.</p>

<h4><a name="section4"></a>4. MODIFICATIONS</h4>

<p>You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:</p>

<ul>


<li>A. Use in the Title Page (and on the covers, if any) a title distinct
   from that of the Document, and from those of previous versions
   (which should, if there were any, be listed in the History section
   of the Document).  You may use the same title as a previous version
   if the original publisher of that version gives permission.
</li>

<li>B. List on the Title Page, as authors, one or more persons or entities
   responsible for authorship of the modifications in the Modified
   Version, together with at least five of the principal authors of the
   Document (all of its principal authors, if it has fewer than five),
   unless they release you from this requirement.
</li>

<li>C. State on the Title page the name of the publisher of the
   Modified Version, as the publisher.
</li>

<li>D. Preserve all the copyright notices of the Document.
</li>

<li>E. Add an appropriate copyright notice for your modifications
   adjacent to the other copyright notices.
</li>

<li>F. Include, immediately after the copyright notices, a license notice
   giving the public permission to use the Modified Version under the
   terms of this License, in the form shown in the Addendum below.
</li>

<li>G. Preserve in that license notice the full lists of Invariant Sections
   and required Cover Texts given in the Document's license notice.
</li>

<li>H. Include an unaltered copy of this License.
</li>

<li>I. Preserve the section Entitled &quot;History&quot;, Preserve its Title, and add
   to it an item stating at least the title, year, new authors, and
   publisher of the Modified Version as given on the Title Page.  If
   there is no section Entitled &quot;History&quot; in the Document, create one
   stating the title, year, authors, and publisher of the Document as
   given on its Title Page, then add an item describing the Modified
   Version as stated in the previous sentence.
</li>

<li>J. Preserve the network location, if any, given in the Document for
   public access to a Transparent copy of the Document, and likewise
   the network locations given in the Document for previous versions
   it was based on.  These may be placed in the &quot;History&quot; section.
   You may omit a network location for a work that was published at
   least four years before the Document itself, or if the original
   publisher of the version it refers to gives permission.
</li>

<li>K. For any section Entitled &quot;Acknowledgements&quot; or &quot;Dedications&quot;,
   Preserve the Title of the section, and preserve in the section all
   the substance and tone of each of the contributor acknowledgements
   and/or dedications given therein.
</li>

<li>L. Preserve all the Invariant Sections of the Document,
   unaltered in their text and in their titles.  Section numbers
   or the equivalent are not considered part of the section titles.
</li>

<li>M. Delete any section Entitled &quot;Endorsements&quot;.  Such a section
   may not be included in the Modified Version.
</li>

<li>N. Do not retitle any existing section to be Entitled &quot;Endorsements&quot;
   or to conflict in title with any Invariant Section.
</li>

<li>O. Preserve any Warranty Disclaimers.</li>

</ul>

<p>If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice.
These titles must be distinct from any other section titles.</p>

<p>You may add a section Entitled &quot;Endorsements&quot;, provided it contains
nothing but endorsements of your Modified Version by various
parties—for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.</p>

<p>You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.</p>

<p>The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.</p>

<h4><a name="section5"></a>5. COMBINING DOCUMENTS</h4>

<p>You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.</p>

<p>The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.</p>

<p>In the combination, you must combine any sections Entitled &quot;History&quot;
in the various original documents, forming one section Entitled
&quot;History&quot;; likewise combine any sections Entitled &quot;Acknowledgements&quot;,
and any sections Entitled &quot;Dedications&quot;.  You must delete all sections
Entitled &quot;Endorsements&quot;.</p>

<h4><a name="section6"></a>6. COLLECTIONS OF DOCUMENTS</h4>

<p>You may make a collection consisting of the Document and other
documents released under this License, and replace the individual
copies of this License in the various documents with a single copy
that is included in the collection, provided that you follow the rules
of this License for verbatim copying of each of the documents in all
other respects.</p>

<p>You may extract a single document from such a collection, and
distribute it individually under this License, provided you insert a
copy of this License into the extracted document, and follow this
License in all other respects regarding verbatim copying of that
document.</p>

<h4><a name="section7"></a>7. AGGREGATION WITH INDEPENDENT WORKS</h4>

<p>A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an &quot;aggregate&quot; if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation's users beyond what the individual works permit.
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.</p>

<p>If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document's Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.</p>

<h4><a name="section8"></a>8. TRANSLATION</h4>

<p>Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.</p>

<p>If a section in the Document is Entitled &quot;Acknowledgements&quot;,
&quot;Dedications&quot;, or &quot;History&quot;, the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.</p>

<h4><a name="section9"></a>9. TERMINATION</h4>

<p>You may not copy, modify, sublicense, or distribute the Document
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense, or distribute it is void, and
will automatically terminate your rights under this License.</p>

<p>However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally
terminates your license, and (b) permanently, if the copyright holder
fails to notify you of the violation by some reasonable means prior to
60 days after the cessation.</p>

<p>Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.</p>

<p>Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, receipt of a copy of some or all of the same material does
not give you any rights to use it.</p>

<h4><a name="section10"></a>10. FUTURE REVISIONS OF THIS LICENSE</h4>

<p>The Free Software Foundation may publish new, revised versions of the
GNU Free Documentation License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in
detail to address new problems or concerns.  See
<a href="http://www.gnu.org/copyleft/">http://www.gnu.org/copyleft/</a>.</p>

<p>Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License &quot;or any later version&quot; applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.  If the Document
specifies that a proxy can decide which future versions of this
License can be used, that proxy's public statement of acceptance of a
version permanently authorizes you to choose that version for the
Document.</p>

<h4><a name="section11"></a>11. RELICENSING</h4>

<p>&quot;Massive Multiauthor Collaboration Site&quot; (or &quot;MMC Site&quot;) means any
World Wide Web server that publishes copyrightable works and also
provides prominent facilities for anybody to edit those works.  A
public wiki that anybody can edit is an example of such a server.  A
&quot;Massive Multiauthor Collaboration&quot; (or &quot;MMC&quot;) contained in the site
means any set of copyrightable works thus published on the MMC site.</p>

<p>&quot;CC-BY-SA&quot; means the Creative Commons Attribution-Share Alike 3.0 
license published by Creative Commons Corporation, a not-for-profit 
corporation with a principal place of business in San Francisco, 
California, as well as future copyleft versions of that license 
published by that same organization.</p>

<p>&quot;Incorporate&quot; means to publish or republish a Document, in whole or in 
part, as part of another Document.</p>

<p>An MMC is &quot;eligible for relicensing&quot; if it is licensed under this 
License, and if all works that were first published under this License 
somewhere other than this MMC, and subsequently incorporated in whole or 
in part into the MMC, (1) had no cover texts or invariant sections, and 
(2) were thus incorporated prior to November 1, 2008.</p>

<p>The operator of an MMC Site may republish an MMC contained in the site
under CC-BY-SA on the same site at any time before August 1, 2009,
provided the MMC is eligible for relicensing.</p>

<h3><a name="addendum"></a>ADDENDUM: How to use this License for your documents</h3>

<p>To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:</p>

<pre>    Copyright (C)  YEAR  YOUR NAME.
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled &quot;GNU
    Free Documentation License&quot;.
</pre>

<p>If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the &quot;with … Texts.&quot; line with this:</p>

<pre>    with the Invariant Sections being LIST THEIR TITLES, with the
    Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
</pre>

<p>If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.</p>

<p>If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.
</p>

</div>
</body>
</html>
